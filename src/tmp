Vim: Warning: Output is not to a terminal
chdir(/usr/share/vim)[?25l[J
fchdir() to previous dir[J
sourcing "$VIM/vimrc"[J
line 1: " **************************************************************************** "[J

line 2: "                                                                              "[J

line 3: "                                                         :::      ::::::::    "[J

line 4: "    vimrc                                              :+:      :+:    :+:    "[J

line 5: "                                                     +:+ +:+         +:+      "[J

line 6: "    By: zaz <zaz@staff.42.fr>                      +#+  +:+       +#+         "[J

line 7: "                                                 +#+#+#+#+#+   +#+            "[J

line 8: "    Created: 2013/06/15 12:45:34 by zaz               #+#    #+#              "[J

line 9: "    Updated: 2013/06/24 11:03:24 by zaz              ###   ########.fr        "[J

line 10: "                                                                              "[J

line 11: " **************************************************************************** "[J

line 12: [J

line 13: "Do not edit this file[J

line 14: "Put your own configuration options in ~/.myvimrc[J

line 15: [J

line 16: "Activate indentation[J

line 17: filetype off[J

Searching for "ftoff.vim" in "/Users/ygarrot/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/ftoff.vim"[J
Searching for "/usr/share/vim/vimfiles/ftoff.vim"[J
Searching for "/usr/share/vim/vim74/ftoff.vim"[J
chdir(/usr/share/vim/vim74)[J
fchdir() to previous dir[J
line 17: sourcing "/usr/share/vim/vim74/ftoff.vim"[J
line 1: " Vim support file to switch off detection of file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2001 Jun 11[J

line 5: [J

line 6: if exists("did_load_filetypes")[J

line 7:   unlet did_load_filetypes[J

line 8: endif[J

line 9: [J

line 10: " Remove all autocommands in the filetypedetect group[J

line 11: silent! au! filetypedetect *[J

finished sourcing /usr/share/vim/vim74/ftoff.vim[J
continuing in /usr/share/vim/vimrc[J
Searching for "/usr/share/vim/vimfiles/after/ftoff.vim"[J
Searching for "/Users/ygarrot/.vim/after/ftoff.vim"[J
line 18: filetype plugin indent on[J

Searching for "filetype.vim" in "/Users/ygarrot/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/filetype.vim"[J
Searching for "/usr/share/vim/vimfiles/filetype.vim"[J
Searching for "/usr/share/vim/vim74/filetype.vim"[J
chdir(/usr/share/vim/vim74)[J
fchdir() to previous dir[J
line 18: sourcing "/usr/share/vim/vim74/filetype.vim"[J
line 1: " Vim support file to detect file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2015 Oct 13[J

line 5: [J

line 6: " Listen very carefully, I will say this only once[J

line 7: if exists("did_load_filetypes")[J

line 8:   finish[J

line 9: endif[J

line 10: let did_load_filetypes = 1[J

line 11: [J

line 12: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 13: let s:cpo_save = &cpo[J

line 14: set cpo&vim[J

line 15: [J

line 16: augroup filetypedetect[J

line 17: [J

line 18: " Ignored extensions[J

line 19: if exists("*fnameescape")[J

line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))[J

line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short[J

line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif[J

line 33: elseif &verbose > 0[J

line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"[J

line 35: endif[J

line 36: [J

line 37: " Pattern used to match file names which should not be inspected.[J

line 38: " Currently finds compressed files.[J

line 39: if !exists("g:ft_ignore_pat")[J

line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'[J

line 41: endif[J

line 42: [J

line 43: " Function used for patterns that end in a star: don't set the filetype if the[J

line 44: " file name matches ft_ignore_pat.[J

line 45: func! s:StarSetf(ft)[J

line 50: [J

line 51: " Abaqus or Trasys[J

line 52: au BufNewFile,BufRead *.inp^I^I^Icall s:Check_inp()[J

line 53: [J

line 54: func! s:Check_inp()[J

line 73: [J

line 74: " A-A-P recipe[J

line 75: au BufNewFile,BufRead *.aap^I^I^Isetf aap[J

line 76: [J

line 77: " A2ps printing utility[J

line 78: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps[J

line 79: [J

line 80: " ABAB/4[J

line 81: au BufNewFile,BufRead *.abap^I^I^Isetf abap[J

line 82: [J

line 83: " ABC music notation[J

line 84: au BufNewFile,BufRead *.abc^I^I^Isetf abc[J

line 85: [J

line 86: " ABEL[J

line 87: au BufNewFile,BufRead *.abl^I^I^Isetf abel[J

line 88: [J

line 89: " AceDB[J

line 90: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb[J

line 91: [J

line 92: " Ada (83, 9X, 95)[J

line 93: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada[J

line 94: if has("vms")[J

line 95:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada[J

line 96: else[J

line 97:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada[J

line 98: endif[J

line 99: [J

line 100: " AHDL[J

line 101: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl[J

line 102: [J

line 103: " AMPL[J

line 104: au BufNewFile,BufRead *.run^I^I^Isetf ampl[J

line 105: [J

line 106: " Ant[J

line 107: au BufNewFile,BufRead build.xml^I^I^Isetf ant[J

line 108: [J

line 109: " Arduino[J

line 110: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino[J

line 111: [J

line 112: " Apache style config file[J

line 113: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')[J

line 114: [J

line 115: " Apache config file[J

line 116: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache[J

line 117: [J

line 118: " XA65 MOS6510 cross assembler[J

line 119: au BufNewFile,BufRead *.a65^I^I^Isetf a65[J

line 120: [J

line 121: " Applescript[J

line 122: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript[J

line 123: [J

line 124: " Applix ELF[J

line 126: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif[J

line 127: [J

line 128: " ALSA configuration[J

line 129: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf[J

line 130: [J

line 131: " Arc Macro Language[J

line 132: au BufNewFile,BufRead *.aml^I^I^Isetf aml[J

line 133: [J

line 134: " APT config file[J

line 135: au BufNewFile,BufRead apt.conf^I^I       setf aptconf[J

line 136: au BufNewFile,BufRead */.aptitude/config       setf aptconf[J

line 137: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf[J

line 138: [J

line 139: " Arch Inventory file[J

line 140: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch[J

line 141: [J

line 142: " ART*Enterprise (formerly ART-IM)[J

line 143: au BufNewFile,BufRead *.art^I^I^Isetf art[J

line 144: [J

line 145: " AsciiDoc[J

line 146: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc[J

line 147: [J

line 148: " ASN.1[J

line 149: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn[J

line 150: [J

line 151: " Active Server Pages (with Visual Basic Script)[J

line 157: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif[J

line 158: [J

line 159: " Active Server Pages (with Perl or Visual Basic Script)[J

line 167: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif[J

line 168: [J

line 169: " Grub (must be before catch *.lst)[J

line 170: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub[J

line 171: [J

line 172: " Assembly (all kinds)[J

line 173: " *.lst is not pure assembly, it has two extra columns (address, byte codes)[J

line 174: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall s:FTasm()[J

line 175: [J

line 176: " This function checks for the kind of assembly that is wanted by the user, or[J

line 177: " can be detected from the first five lines of the file.[J

line 178: func! s:FTasm()[J

line 199: [J

line 200: func! s:FTasmsyntax()[J

line 212: [J

line 213: " Macro (VAX)[J

line 214: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm[J

line 215: [J

line 216: " Atlas[J

line 217: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas[J

line 218: [J

line 219: " Autoit v3[J

line 220: au BufNewFile,BufRead *.au3^I^I^Isetf autoit[J

line 221: [J

line 222: " Autohotkey[J

line 223: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey[J

line 224: [J

line 225: " Automake[J

line 226: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake[J

line 227: [J

line 228: " Autotest .at files are actually m4[J

line 229: au BufNewFile,BufRead *.at^I^I^Isetf m4[J

line 230: [J

line 231: " Avenue[J

line 232: au BufNewFile,BufRead *.ave^I^I^Isetf ave[J

line 233: [J

line 234: " Awk[J

line 235: au BufNewFile,BufRead *.awk^I^I^Isetf awk[J

line 236: [J

line 237: " B[J

line 238: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b[J

line 239: [J

line 240: " BASIC or Visual Basic[J

line 241: au BufNewFile,BufRead *.bas^I^I^Icall s:FTVB("basic")[J

line 242: [J

line 243: " Check if one of the first five lines contains "VB_Name".  In that case it is[J

line 244: " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.[J

line 245: func! s:FTVB(alt)[J

line 252: [J

line 253: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET[J

line 254: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb[J

line 255: [J

line 256: " IBasic file (similar to QBasic)[J

line 257: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic[J

line 258: [J

line 259: " FreeBasic file (similar to QBasic)[J

line 260: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic[J

line 261: [J

line 262: " Batch file for MSDOS.[J

line 263: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch[J

line 264: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.[J

line 266: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif[J

line 267: [J

line 268: " Batch file for 4DOS[J

line 269: au BufNewFile,BufRead *.btm^I^I^Icall s:FTbtm()[J

line 270: func! s:FTbtm()[J

line 277: [J

line 278: " BC calculator[J

line 279: au BufNewFile,BufRead *.bc^I^I^Isetf bc[J

line 280: [J

line 281: " BDF font[J

line 282: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf[J

line 283: [J

line 284: " BibTeX bibliography database file[J

line 285: au BufNewFile,BufRead *.bib^I^I^Isetf bib[J

line 286: [J

line 287: " BibTeX Bibliography Style[J

line 288: au BufNewFile,BufRead *.bst^I^I^Isetf bst[J

line 289: [J

line 290: " BIND configuration[J

line 291: au BufNewFile,BufRead named.conf,rndc.conf^Isetf named[J

line 292: [J

line 293: " BIND zone[J

line 294: au BufNewFile,BufRead named.root^I^Isetf bindzone[J

line 295: au BufNewFile,BufRead *.db^I^I^Icall s:BindzoneCheck('')[J

line 296: [J

line 297: func! s:BindzoneCheck(default)[J

line 304: [J

line 305: " Blank[J

line 306: au BufNewFile,BufRead *.bl^I^I^Isetf blank[J

line 307: [J

line 308: " Blkid cache file[J

line 309: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml[J

line 310: [J

line 311: " Bazel (http://bazel.io)[J

line 312: autocmd BufRead,BufNewFile *.bzl,BUILD,WORKSPACE setfiletype bzl[J

line 313: [J

line 314: " C or lpc[J

line 315: au BufNewFile,BufRead *.c^I^I^Icall s:FTlpc()[J

line 316: [J

line 317: func! s:FTlpc()[J

line 330: [J

line 331: " Calendar[J

line 332: au BufNewFile,BufRead calendar^I^I^Isetf calendar[J

line 333: [J

line 334: " C#[J

line 335: au BufNewFile,BufRead *.cs^I^I^Isetf cs[J

line 336: [J

line 337: " CSDL[J

line 338: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl[J

line 339: [J

line 340: " Cabal[J

line 341: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal[J

line 342: [J

line 343: " Cdrdao TOC[J

line 344: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc[J

line 345: [J

line 346: " Cdrdao config[J

line 347: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf[J

line 348: [J

line 349: " Cfengine[J

line 350: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine[J

line 351: [J

line 352: " ChaiScript[J

line 353: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript[J

line 354: [J

line 355: " Comshare Dimension Definition Language[J

line 356: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl[J

line 357: [J

line 358: " Conary Recipe[J

line 359: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe[J

line 360: [J

line 361: " Controllable Regex Mutilator[J

line 362: au BufNewFile,BufRead *.crm^I^I^Isetf crm[J

line 363: [J

line 364: " Cyn++[J

line 365: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp[J

line 366: [J

line 367: " Cynlib[J

line 368: " .cc and .cpp files can be C++ or Cynlib.[J

line 370: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif[J

line 372: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif[J

line 373: [J

line 374: " C++[J

line 375: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp[J

line 376: if has("fname_case")[J

line 377:   au BufNewFile,BufRead *.C,*.H setf cpp[J

line 378: endif[J

line 379: [J

line 380: " .h files can be C, Ch C++, ObjC or ObjC++.[J

line 381: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is[J

line 382: " detected automatically.[J

line 383: au BufNewFile,BufRead *.h^I^I^Icall s:FTheader()[J

line 384: [J

line 385: func! s:FTheader()[J

line 400: [J

line 401: " Ch (CHscript)[J

line 402: au BufNewFile,BufRead *.chf^I^I^Isetf ch[J

line 403: [J

line 404: " TLH files are C++ headers generated by Visual C++'s #import from typelibs[J

line 405: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp[J

line 406: [J

line 407: " Cascading Style Sheets[J

line 408: au BufNewFile,BufRead *.css^I^I^Isetf css[J

line 409: [J

line 410: " Century Term Command Scripts (*.cmd too)[J

line 411: au BufNewFile,BufRead *.con^I^I^Isetf cterm[J

line 412: [J

line 413: " Changelog[J

line 415: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog[J

line 416: [J

line 422: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif[J

line 423: [J

line 427: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif[J

line 428: [J

line 429: " CHILL[J

line 430: au BufNewFile,BufRead *..ch^I^I^Isetf chill[J

line 431: [J

line 432: " Changes for WEB and CWEB or CHILL[J

line 433: au BufNewFile,BufRead *.ch^I^I^Icall s:FTchange()[J

line 434: [J

line 435: " This function checks if one of the first ten lines start with a '@'.  In[J

line 436: " that case it is probably a change file.[J

line 437: " If the first line starts with # or ! it's probably a ch file.[J

line 438: " If a line has "main", "include", "//" ir "/*" it's probably ch.[J

line 439: " Otherwise CHILL is assumed.[J

line 440: func! s:FTchange()[J

line 463: [J

line 464: " ChordPro[J

line 465: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro[J

line 466: [J

line 467: " Clean[J

line 468: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean[J

line 469: [J

line 470: " Clever[J

line 471: au BufNewFile,BufRead *.eni^I^I^Isetf cl[J

line 472: [J

line 473: " Clever or dtd[J

line 474: au BufNewFile,BufRead *.ent^I^I^Icall s:FTent()[J

line 475: [J

line 476: func! s:FTent()[J

line 495: [J

line 496: " Clipper (or FoxPro; could also be eviews)[J

line 502: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif[J

line 503: [J

line 504: " Clojure[J

line 505: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure[J

line 506: [J

line 507: " Cmake[J

line 508: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake[J

line 509: [J

line 510: " Cmusrc[J

line 511: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc[J

line 512: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc[J

line 513: [J

line 514: " Cobol[J

line 515: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol[J

line 516: "   cobol or zope form controller python script? (heuristic)[J

line 522: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif[J

line 523: [J

line 524: " Coco/R[J

line 525: au BufNewFile,BufRead *.atg^I^I^Isetf coco[J

line 526: [J

line 527: " Cold Fusion[J

line 528: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf[J

line 529: [J

line 530: " Configure scripts[J

line 531: au BufNewFile,BufRead configure.in,configure.ac setf config[J

line 532: [J

line 533: " CUDA  Cumpute Unified Device Architecture[J

line 534: au BufNewFile,BufRead *.cu^I^I^Isetf cuda[J

line 535: [J

line 536: " Dockerfile[J

line 537: au BufNewFile,BufRead Dockerfile^I^Isetf dockerfile[J

line 538: [J

line 539: " WildPackets EtherPeek Decoder[J

line 540: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd[J

line 541: [J

line 542: " Enlightenment configuration files[J

line 543: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c[J

line 544: [J

line 545: " Eterm[J

line 546: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm[J

line 547: [J

line 548: " Euphoria 3 or 4[J

line 549: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()[J

line 550: if has("fname_case")[J

line 551:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()[J

line 552: endif[J

line 553: [J

line 554: func! s:EuphoriaCheck()[J

line 561: [J

line 562: " Lynx config files[J

line 563: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx[J

line 564: [J

line 565: " Quake[J

line 566: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake[J

line 567: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake[J

line 568: [J

line 569: " Quake C[J

line 570: au BufNewFile,BufRead *.qc^I^I^Isetf c[J

line 571: [J

line 572: " Configure files[J

line 573: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg[J

line 574: [J

line 575: " Cucumber[J

line 576: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber[J

line 577: [J

line 578: " Communicating Sequential Processes[J

line 579: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp[J

line 580: [J

line 581: " CUPL logic description and simulation[J

line 582: au BufNewFile,BufRead *.pld^I^I^Isetf cupl[J

line 583: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim[J

line 584: [J

line 585: " Debian Control[J

line 586: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol[J

line 590: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif[J

line 591: [J

line 592: " Debian Sources.list[J

line 593: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources[J

line 594: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources[J

line 595: [J

line 596: " Deny hosts[J

line 597: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts[J

line 598: [J

line 599: " dnsmasq(8) configuration files[J

line 600: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq[J

line 601: [J

line 602: " ROCKLinux package description[J

line 603: au BufNewFile,BufRead *.desc^I^I^Isetf desc[J

line 604: [J

line 605: " the D language or dtrace[J

line 606: au BufNewFile,BufRead *.d^I^I^Icall s:DtraceCheck()[J

line 607: [J

line 608: func! s:DtraceCheck()[J

line 619: [J

line 620: " Desktop files[J

line 621: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop[J

line 622: [J

line 623: " Dict config[J

line 624: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf[J

line 625: [J

line 626: " Dictd config[J

line 627: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf[J

line 628: [J

line 629: " Diff files[J

line 630: au BufNewFile,BufRead *.diff,*.rej,*.patch^Isetf diff[J

line 631: [J

line 632: " Dircolors[J

line 633: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors[J

line 634: [J

line 635: " Diva (with Skill) or InstallShield[J

line 641: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif[J

line 642: [J

line 643: " DCL (Digital Command Language - vms) or DNS zone file[J

line 644: au BufNewFile,BufRead *.com^I^I^Icall s:BindzoneCheck('dcl')[J

line 645: [J

line 646: " DOT[J

line 647: au BufNewFile,BufRead *.dot^I^I^Isetf dot[J

line 648: [J

line 649: " Dylan - lid files[J

line 650: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid[J

line 651: [J

line 652: " Dylan - intr files (melange)[J

line 653: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr[J

line 654: [J

line 655: " Dylan[J

line 656: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan[J

line 657: [J

line 658: " Microsoft Module Definition[J

line 659: au BufNewFile,BufRead *.def^I^I^Isetf def[J

line 660: [J

line 661: " Dracula[J

line 662: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula[J

line 663: [J

line 664: " Datascript[J

line 665: au BufNewFile,BufRead *.ds^I^I^Isetf datascript[J

line 666: [J

line 667: " dsl[J

line 668: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl[J

line 669: [J

line 670: " DTD (Document Type Definition for XML)[J

line 671: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd[J

line 672: [J

line 673: " DTS/DSTI (device tree files)[J

line 674: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts[J

line 675: [J

line 676: " EDIF (*.edf,*.edif,*.edn,*.edo)[J

line 677: au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)^Isetf edif[J

line 678: [J

line 679: " Embedix Component Description[J

line 680: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd[J

line 681: [J

line 682: " Eiffel or Specman or Euphoria[J

line 683: au BufNewFile,BufRead *.e,*.E^I^I^Icall s:FTe()[J

line 684: [J

line 685: " Elinks configuration[J

line 686: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks[J

line 687: [J

line 688: func! s:FTe()[J

line 703: [J

line 704: " ERicsson LANGuage; Yaws is erlang too[J

line 705: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang[J

line 706: [J

line 707: " Elm Filter Rules file[J

line 708: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt[J

line 709: [J

line 710: " ESMTP rc file[J

line 711: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc[J

line 712: [J

line 713: " ESQL-C[J

line 714: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc[J

line 715: [J

line 716: " Esterel[J

line 717: au BufNewFile,BufRead *.strl^I^I^Isetf esterel[J

line 718: [J

line 719: " Essbase script[J

line 720: au BufNewFile,BufRead *.csc^I^I^Isetf csc[J

line 721: [J

line 722: " Exim[J

line 723: au BufNewFile,BufRead exim.conf^I^I^Isetf exim[J

line 724: [J

line 725: " Expect[J

line 726: au BufNewFile,BufRead *.exp^I^I^Isetf expect[J

line 727: [J

line 728: " Exports[J

line 729: au BufNewFile,BufRead exports^I^I^Isetf exports[J

line 730: [J

line 731: " Falcon[J

line 732: au BufNewFile,BufRead *.fal^I^I^Isetf falcon[J

line 733: [J

line 734: " Fantom[J

line 735: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan[J

line 736: [J

line 737: " Factor[J

line 738: au BufNewFile,BufRead *.factor^I^I^Isetf factor[J

line 739: [J

line 740: " Fetchmail RC file[J

line 741: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail[J

line 742: [J

line 743: " FlexWiki - disabled, because it has side effects when a .wiki file[J

line 744: " is not actually FlexWiki[J

line 745: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki[J

line 746: [J

line 747: " Focus Executable[J

line 748: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec[J

line 749: [J

line 750: " Focus Master file (but not for auto.master)[J

line 751: au BufNewFile,BufRead auto.master^I^Isetf conf[J

line 752: au BufNewFile,BufRead *.mas,*.master^I^Isetf master[J

line 753: [J

line 754: " Forth[J

line 755: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth[J

line 756: [J

line 757: " Reva Forth[J

line 758: au BufNewFile,BufRead *.frt^I^I^Isetf reva[J

line 759: [J

line 760: " Fortran[J

line 761: if has("fname_case")[J

line 762:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran[J

line 763: endif[J

line 764: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran[J

line 765: [J

line 766: " Framescript[J

line 767: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript[J

line 768: [J

line 769: " FStab[J

line 770: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab[J

line 771: [J

line 772: " GDB command files[J

line 773: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb[J

line 774: [J

line 775: " GDMO[J

line 776: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo[J

line 777: [J

line 778: " Gedcom[J

line 779: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom[J

line 780: [J

line 781: " Git[J

line 782: au BufNewFile,BufRead COMMIT_EDITMSG^I^Isetf gitcommit[J

line 783: au BufNewFile,BufRead MERGE_MSG^I^I^Isetf gitcommit[J

line 784: au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig[J

line 785: au BufNewFile,BufRead *.git/modules/*/config^Isetf gitconfig[J

line 786: au BufNewFile,BufRead */.config/git/config^Isetf gitconfig[J

line 787: if !empty($XDG_CONFIG_HOME)[J

line 788:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^Isetf gitconfig[J

line 789: endif[J

line 790: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase[J

line 794: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif[J

line 798: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif[J

line 799: [J

line 800: " Gkrellmrc[J

line 801: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc[J

line 802: [J

line 803: " GP scripts (2.0 and onward)[J

line 804: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp[J

line 805: [J

line 806: " GPG[J

line 807: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg[J

line 808: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg[J

line 809: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg[J

line 810: [J

line 811: " gnash(1) configuration files[J

line 812: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash[J

line 813: [J

line 814: " Gitolite[J

line 815: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite[J

line 816: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')[J

line 817: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl[J

line 818: [J

line 819: " Gnuplot scripts[J

line 820: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot[J

line 821: [J

line 822: " Go (Google)[J

line 823: au BufNewFile,BufRead *.go^I^I^Isetf go[J

line 824: [J

line 825: " GrADS scripts[J

line 826: au BufNewFile,BufRead *.gs^I^I^Isetf grads[J

line 827: [J

line 828: " Gretl[J

line 829: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl[J

line 830: [J

line 831: " Groovy[J

line 832: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy[J

line 833: [J

line 834: " GNU Server Pages[J

line 835: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp[J

line 836: [J

line 837: " Group file[J

line 838: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group[J

line 839: [J

line 840: " GTK RC[J

line 841: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc[J

line 842: [J

line 843: " Haml[J

line 844: au BufNewFile,BufRead *.haml^I^I^Isetf haml[J

line 845: [J

line 846: " Hamster Classic | Playground files[J

line 847: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster[J

line 848: [J

line 849: " Haskell[J

line 850: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell[J

line 851: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell[J

line 852: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell[J

line 853: [J

line 854: " Haste[J

line 855: au BufNewFile,BufRead *.ht^I^I^Isetf haste[J

line 856: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc[J

line 857: [J

line 858: " Hercules[J

line 859: au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum^Isetf hercules[J

line 860: [J

line 861: " HEX (Intel)[J

line 862: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex[J

line 863: [J

line 864: " Tilde (must be before HTML)[J

line 865: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde[J

line 866: [J

line 867: " HTML (.shtml and .stm for server side)[J

line 868: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()[J

line 869: [J

line 870: " Distinguish between HTML, XHTML and Django[J

line 871: func! s:FThtml()[J

line 886: [J

line 887: " HTML with Ruby - eRuby[J

line 888: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby[J

line 889: [J

line 890: " HTML with M4[J

line 891: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4[J

line 892: [J

line 893: " HTML Cheetah template[J

line 894: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah[J

line 895: [J

line 896: " Host config[J

line 897: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf[J

line 898: [J

line 899: " Hosts access[J

line 900: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess[J

line 901: [J

line 902: " Hyper Builder[J

line 903: au BufNewFile,BufRead *.hb^I^I^Isetf hb[J

line 904: [J

line 905: " Httest[J

line 906: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest[J

line 907: [J

line 908: " Icon[J

line 909: au BufNewFile,BufRead *.icn^I^I^Isetf icon[J

line 910: [J

line 911: " IDL (Interface Description Language)[J

line 912: au BufNewFile,BufRead *.idl^I^I^Icall s:FTidl()[J

line 913: [J

line 914: " Distinguish between standard IDL and MS-IDL[J

line 915: func! s:FTidl()[J

line 926: [J

line 927: " Microsoft IDL (Interface Description Language)  Also *.idl[J

line 928: " MOF = WMI (Windows Management Instrumentation) Managed Object Format[J

line 929: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl[J

line 930: [J

line 931: " Icewm menu[J

line 932: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu[J

line 933: [J

line 934: " Indent profile (must come before IDL *.pro!)[J

line 935: au BufNewFile,BufRead .indent.pro^I^Isetf indent[J

line 936: au BufNewFile,BufRead indent.pro^I^Icall s:ProtoCheck('indent')[J

line 937: [J

line 938: " IDL (Interactive Data Language)[J

line 939: au BufNewFile,BufRead *.pro^I^I^Icall s:ProtoCheck('idlang')[J

line 940: [J

line 941: " Distinguish between "default" and Cproto prototype file. */[J

line 942: func! s:ProtoCheck(default)[J

line 954: [J

line 955: [J

line 956: " Indent RC[J

line 957: au BufNewFile,BufRead indentrc^I^I^Isetf indent[J

line 958: [J

line 959: " Inform[J

line 960: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform[J

line 961: [J

line 962: " Initng[J

line 963: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng[J

line 964: [J

line 965: " Innovation Data Processing[J

line 966: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat[J

line 967: au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c ^Isetf upstreamlog[J

line 968: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog[J

line 969: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog[J

line 970: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog[J

line 971: [J

line 972: " Ipfilter[J

line 973: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter[J

line 974: [J

line 975: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)[J

line 976: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl[J

line 977: [J

line 978: " .INI file for MSDOS[J

line 979: au BufNewFile,BufRead *.ini^I^I^Isetf dosini[J

line 980: [J

line 981: " SysV Inittab[J

line 982: au BufNewFile,BufRead inittab^I^I^Isetf inittab[J

line 983: [J

line 984: " Inno Setup[J

line 985: au BufNewFile,BufRead *.iss^I^I^Isetf iss[J

line 986: [J

line 987: " J[J

line 988: au BufNewFile,BufRead *.ijs^I^I^Isetf j[J

line 989: [J

line 990: " JAL[J

line 991: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal[J

line 992: [J

line 993: " Jam[J

line 994: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam[J

line 995: [J

line 996: " Java[J

line 997: au BufNewFile,BufRead *.java,*.jav^I^Isetf java[J

line 998: [J

line 999: " JavaCC[J

line 1000: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc[J

line 1001: [J

line 1002: " JavaScript, ECMAScript[J

line 1003: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx   setf javascript[J

line 1004: [J

line 1005: " Java Server Pages[J

line 1006: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp[J

line 1007: [J

line 1008: " Java Properties resource file (note: doesn't catch font.properties.pl)[J

line 1009: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties[J

line 1010: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')[J

line 1011: [J

line 1012: " Jess[J

line 1013: au BufNewFile,BufRead *.clp^I^I^Isetf jess[J

line 1014: [J

line 1015: " Jgraph[J

line 1016: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph[J

line 1017: [J

line 1018: " Jovial[J

line 1019: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial[J

line 1020: [J

line 1021: " JSON[J

line 1022: au BufNewFile,BufRead *.json,*.jsonp^I^Isetf json[J

line 1023: [J

line 1024: " Kixtart[J

line 1025: au BufNewFile,BufRead *.kix^I^I^Isetf kix[J

line 1026: [J

line 1027: " Kimwitu[++][J

line 1028: au BufNewFile,BufRead *.k^I^I^Isetf kwt[J

line 1029: [J

line 1030: " Kivy[J

line 1031: au BufNewFile,BufRead *.kv^I^I^Isetf kivy[J

line 1032: [J

line 1033: " KDE script[J

line 1034: au BufNewFile,BufRead *.ks^I^I^Isetf kscript[J

line 1035: [J

line 1036: " Kconfig[J

line 1037: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig[J

line 1038: [J

line 1039: " Lace (ISE)[J

line 1040: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace[J

line 1041: [J

line 1042: " Latte[J

line 1043: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte[J

line 1044: [J

line 1045: " Limits[J

line 1046: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits[J

line 1047: [J

line 1048: " LambdaProlog (*.mod too, see Modsim)[J

line 1049: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog[J

line 1050: [J

line 1051: " LDAP LDIF[J

line 1052: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif[J

line 1053: [J

line 1054: " Ld loader[J

line 1055: au BufNewFile,BufRead *.ld^I^I^Isetf ld[J

line 1056: [J

line 1057: " Less[J

line 1058: au BufNewFile,BufRead *.less^I^I^Isetf less[J

line 1059: [J

line 1060: " Lex[J

line 1061: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex[J

line 1062: [J

line 1063: " Libao[J

line 1064: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao[J

line 1065: [J

line 1066: " Libsensors[J

line 1067: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors[J

line 1068: [J

line 1069: " LFTP[J

line 1070: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp[J

line 1071: [J

line 1072: " Lifelines (or Lex for C++!)[J

line 1073: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines[J

line 1074: [J

line 1075: " Lilo: Linux loader[J

line 1076: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo[J

line 1077: [J

line 1078: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)[J

line 1079: if has("fname_case")[J

line 1080:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp[J

line 1081: else[J

line 1082:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp[J

line 1083: endif[J

line 1084: [J

line 1085: " SBCL implementation of Common Lisp[J

line 1086: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp[J

line 1087: [J

line 1088: " Liquid[J

line 1089: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid[J

line 1090: [J

line 1091: " Lite[J

line 1092: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite[J

line 1093: [J

line 1094: " LiteStep RC files[J

line 1095: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep[J

line 1096: [J

line 1097: " Login access[J

line 1098: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess[J

line 1099: [J

line 1100: " Login defs[J

line 1101: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs[J

line 1102: [J

line 1103: " Logtalk[J

line 1104: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk[J

line 1105: [J

line 1106: " LOTOS[J

line 1107: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos[J

line 1108: [J

line 1109: " Lout (also: *.lt)[J

line 1110: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout[J

line 1111: [J

line 1112: " Lua[J

line 1113: au BufNewFile,BufRead *.lua^I^I^Isetf lua[J

line 1114: [J

line 1115: " Luarocks[J

line 1116: au BufNewFile,BufRead *.rockspec^I^Isetf lua[J

line 1117: [J

line 1118: " Linden Scripting Language (Second Life)[J

line 1119: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl[J

line 1120: [J

line 1121: " Lynx style file (or LotusScript!)[J

line 1122: au BufNewFile,BufRead *.lss^I^I^Isetf lss[J

line 1123: [J

line 1124: " M4[J

line 1126: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif[J

line 1127: [J

line 1128: " MaGic Point[J

line 1129: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp[J

line 1130: [J

line 1131: " Mail (for Elm, trn, mutt, muttng, rn, slrn)[J

line 1132: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail[J

line 1133: [J

line 1134: " Mail aliases[J

line 1135: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases[J

line 1136: [J

line 1137: " Mailcap configuration file[J

line 1138: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap[J

line 1139: [J

line 1140: " Makefile[J

line 1141: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make[J

line 1142: [J

line 1143: " MakeIndex[J

line 1144: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist[J

line 1145: [J

line 1146: " Mallard[J

line 1147: au BufNewFile,BufRead *.page^I^I^Isetf mallard[J

line 1148: [J

line 1149: " Manpage[J

line 1150: au BufNewFile,BufRead *.man^I^I^Isetf man[J

line 1151: [J

line 1152: " Man config[J

line 1153: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf[J

line 1154: [J

line 1155: " Maple V[J

line 1156: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple[J

line 1157: [J

line 1158: " Map (UMN mapserver config file)[J

line 1159: au BufNewFile,BufRead *.map^I^I^Isetf map[J

line 1160: [J

line 1161: " Markdown[J

line 1162: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown[J

line 1163: [J

line 1164: " Mason[J

line 1165: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason[J

line 1166: [J

line 1167: " Matlab or Objective C[J

line 1168: au BufNewFile,BufRead *.m^I^I^Icall s:FTm()[J

line 1169: [J

line 1170: func! s:FTm()[J

line 1194: [J

line 1195: " Mathematica notebook[J

line 1196: au BufNewFile,BufRead *.nb^I^I^Isetf mma[J

line 1197: [J

line 1198: " Maya Extension Language[J

line 1199: au BufNewFile,BufRead *.mel^I^I^Isetf mel[J

line 1200: [J

line 1201: " Mercurial (hg) commit file[J

line 1202: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit[J

line 1203: [J

line 1204: " Mercurial config (looks like generic config file)[J

line 1205: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg[J

line 1206: [J

line 1207: " Messages (logs mostly)[J

line 1208: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages[J

line 1209: [J

line 1210: " Metafont[J

line 1211: au BufNewFile,BufRead *.mf^I^I^Isetf mf[J

line 1212: [J

line 1213: " MetaPost[J

line 1214: au BufNewFile,BufRead *.mp^I^I^Isetf mp[J

line 1215: [J

line 1216: " MGL[J

line 1217: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl[J

line 1218: [J

line 1219: " MIX - Knuth assembly[J

line 1220: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix[J

line 1221: [J

line 1222: " MMIX or VMS makefile[J

line 1223: au BufNewFile,BufRead *.mms^I^I^Icall s:FTmms()[J

line 1224: [J

line 1225: " Symbian meta-makefile definition (MMP)[J

line 1226: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp[J

line 1227: [J

line 1228: func! s:FTmms()[J

line 1244: [J

line 1245: [J

line 1246: " Modsim III (or LambdaProlog)[J

line 1252: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif[J

line 1253: [J

line 1254: " Modula 2  (.md removed in favor of Markdown)[J

line 1255: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2[J

line 1256: [J

line 1257: " Modula 3 (.m3, .i3, .mg, .ig)[J

line 1258: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3[J

line 1259: [J

line 1260: " Monk[J

line 1261: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk[J

line 1262: [J

line 1263: " MOO[J

line 1264: au BufNewFile,BufRead *.moo^I^I^Isetf moo[J

line 1265: [J

line 1266: " Modconf[J

line 1267: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf[J

line 1268: [J

line 1269: " Mplayer config[J

line 1270: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf[J

line 1271: [J

line 1272: " Motorola S record[J

line 1273: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec[J

line 1274: [J

line 1275: " Mrxvtrc[J

line 1276: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc[J

line 1277: [J

line 1278: " Msql[J

line 1279: au BufNewFile,BufRead *.msql^I^I^Isetf msql[J

line 1280: [J

line 1281: " Mysql[J

line 1282: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql[J

line 1283: [J

line 1284: " Mutt setup files (must be before catch *.rc)[J

line 1285: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')[J

line 1286: [J

line 1287: " M$ Resource files[J

line 1288: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc[J

line 1289: [J

line 1290: " MuPAD source[J

line 1291: au BufRead,BufNewFile *.mu^I^I^Isetf mupad[J

line 1292: [J

line 1293: " Mush[J

line 1294: au BufNewFile,BufRead *.mush^I^I^Isetf mush[J

line 1295: [J

line 1296: " Mutt setup file (also for Muttng)[J

line 1297: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc[J

line 1298: [J

line 1299: " Nano[J

line 1300: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc[J

line 1301: [J

line 1302: " Nastran input/DMAP[J

line 1303: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran[J

line 1304: [J

line 1305: " Natural[J

line 1306: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural[J

line 1307: [J

line 1308: " Netrc[J

line 1309: au BufNewFile,BufRead .netrc^I^I^Isetf netrc[J

line 1310: [J

line 1311: " Ninja file[J

line 1312: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja[J

line 1313: [J

line 1314: " Novell netware batch files[J

line 1315: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf[J

line 1316: [J

line 1317: " Nroff/Troff (*.ms and *.t are checked below)[J

line 1321: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif[J

line 1322: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff[J

line 1323: au BufNewFile,BufRead *.[1-9]^I^I^Icall s:FTnroff()[J

line 1324: [J

line 1325: " This function checks if one of the first five lines start with a dot.  In[J

line 1326: " that case it is probably an nroff file: 'filetype' is set and 1 is returned.[J

line 1327: func! s:FTnroff()[J

line 1334: [J

line 1335: " Nroff or Objective C++[J

line 1336: au BufNewFile,BufRead *.mm^I^I^Icall s:FTmm()[J

line 1337: [J

line 1338: func! s:FTmm()[J

line 1350: [J

line 1351: " Not Quite C[J

line 1352: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc[J

line 1353: [J

line 1354: " NSIS[J

line 1355: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis[J

line 1356: [J

line 1357: " OCAML[J

line 1358: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml[J

line 1359: [J

line 1360: " Occam[J

line 1361: au BufNewFile,BufRead *.occ^I^I^Isetf occam[J

line 1362: [J

line 1363: " Omnimark[J

line 1364: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark[J

line 1365: [J

line 1366: " OpenROAD[J

line 1367: au BufNewFile,BufRead *.or^I^I^Isetf openroad[J

line 1368: [J

line 1369: " OPL[J

line 1370: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl[J

line 1371: [J

line 1372: " Oracle config file[J

line 1373: au BufNewFile,BufRead *.ora^I^I^Isetf ora[J

line 1374: [J

line 1375: " Packet filter conf[J

line 1376: au BufNewFile,BufRead pf.conf^I^I^Isetf pf[J

line 1377: [J

line 1378: " Pam conf[J

line 1379: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf[J

line 1380: [J

line 1381: " PApp[J

line 1382: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp[J

line 1383: [J

line 1384: " Password file[J

line 1385: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd[J

line 1386: [J

line 1387: " Pascal (also *.p)[J

line 1388: au BufNewFile,BufRead *.pas^I^I^Isetf pascal[J

line 1389: [J

line 1390: " Delphi project file[J

line 1391: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal[J

line 1392: [J

line 1393: " PDF[J

line 1394: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf[J

line 1395: [J

line 1396: " Perl[J

line 1397: if has("fname_case")[J

line 1398:   au BufNewFile,BufRead *.pl,*.PL^I^Icall s:FTpl()[J

line 1399: else[J

line 1400:   au BufNewFile,BufRead *.pl^I^I^Icall s:FTpl()[J

line 1401: endif[J

line 1402: au BufNewFile,BufRead *.plx,*.al^I^Isetf perl[J

line 1403: au BufNewFile,BufRead *.p6,*.pm6^I^Isetf perl6[J

line 1404: [J

line 1405: func! s:FTpl()[J

line 1419: [J

line 1420: " Perl, XPM or XPM2[J

line 1428: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif[J

line 1429: [J

line 1430: " Perl POD[J

line 1431: au BufNewFile,BufRead *.pod^I^I^Isetf pod[J

line 1432: [J

line 1433: " Php, php3, php4, etc.[J

line 1434: " Also Phtml (was used for PHP 2 in the past)[J

line 1435: " Also .ctp for Cake template file[J

line 1436: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php[J

line 1437: [J

line 1438: " Pike[J

line 1439: au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike[J

line 1440: [J

line 1441: " Pinfo config[J

line 1442: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo[J

line 1443: [J

line 1444: " Palm Resource compiler[J

line 1445: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc[J

line 1446: [J

line 1447: " Pine config[J

line 1448: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine[J

line 1449: [J

line 1450: " PL/1, PL/I[J

line 1451: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli[J

line 1452: [J

line 1453: " PL/M (also: *.inp)[J

line 1454: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm[J

line 1455: [J

line 1456: " PL/SQL[J

line 1457: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql[J

line 1458: [J

line 1459: " PLP[J

line 1460: au BufNewFile,BufRead *.plp^I^I^Isetf plp[J

line 1461: [J

line 1462: " PO and PO template (GNU gettext)[J

line 1463: au BufNewFile,BufRead *.po,*.pot^I^Isetf po[J

line 1464: [J

line 1465: " Postfix main config[J

line 1466: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain[J

line 1467: [J

line 1468: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)[J

line 1469: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr[J

line 1470: [J

line 1471: " PostScript Printer Description[J

line 1472: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd[J

line 1473: [J

line 1474: " Povray[J

line 1475: au BufNewFile,BufRead *.pov^I^I^Isetf pov[J

line 1476: [J

line 1477: " Povray configuration[J

line 1478: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini[J

line 1479: [J

line 1480: " Povray, PHP or assembly[J

line 1481: au BufNewFile,BufRead *.inc^I^I^Icall s:FTinc()[J

line 1482: [J

line 1483: func! s:FTinc()[J

line 1504: [J

line 1505: " Printcap and Termcap[J

line 1507: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap[J

line 1509: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap[J

line 1510: [J

line 1511: " PCCTS / ANTRL[J

line 1512: "au BufNewFile,BufRead *.g^I^I^Isetf antrl[J

line 1513: au BufNewFile,BufRead *.g^I^I^Isetf pccts[J

line 1514: [J

line 1515: " PPWizard[J

line 1516: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz[J

line 1517: [J

line 1518: " Obj 3D file format[J

line 1519: " TODO: is there a way to avoid MS-Windows Object files?[J

line 1520: au BufNewFile,BufRead *.obj^I^I^Isetf obj[J

line 1521: [J

line 1522: " Oracle Pro*C/C++[J

line 1523: au BufNewFile,BufRead *.pc^I^I^Isetf proc[J

line 1524: [J

line 1525: " Privoxy actions file[J

line 1526: au BufNewFile,BufRead *.action^I^I^Isetf privoxy[J

line 1527: [J

line 1528: " Procmail[J

line 1529: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail[J

line 1530: [J

line 1531: " Progress or CWEB[J

line 1532: au BufNewFile,BufRead *.w^I^I^Icall s:FTprogress_cweb()[J

line 1533: [J

line 1534: func! s:FTprogress_cweb()[J

line 1545: [J

line 1546: " Progress or assembly[J

line 1547: au BufNewFile,BufRead *.i^I^I^Icall s:FTprogress_asm()[J

line 1548: [J

line 1549: func! s:FTprogress_asm()[J

line 1571: [J

line 1572: " Progress or Pascal[J

line 1573: au BufNewFile,BufRead *.p^I^I^Icall s:FTprogress_pascal()[J

line 1574: [J

line 1575: func! s:FTprogress_pascal()[J

line 1599: [J

line 1600: [J

line 1601: " Software Distributor Product Specification File (POSIX 1387.2-1995)[J

line 1602: au BufNewFile,BufRead *.psf^I^I^Isetf psf[J

line 1606: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif[J

line 1607: [J

line 1608: " Prolog[J

line 1609: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog[J

line 1610: [J

line 1611: " Promela[J

line 1612: au BufNewFile,BufRead *.pml^I^I^Isetf promela[J

line 1613: [J

line 1614: " Google protocol buffers[J

line 1615: au BufNewFile,BufRead *.proto^I^I^Isetf proto[J

line 1616: [J

line 1617: " Protocols[J

line 1618: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols[J

line 1619: [J

line 1620: " Pyrex[J

line 1621: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex[J

line 1622: [J

line 1623: " Python[J

line 1624: au BufNewFile,BufRead *.py,*.pyw^I^Isetf python[J

line 1625: [J

line 1626: " Quixote (Python-based web framework)[J

line 1627: au BufNewFile,BufRead *.ptl^I^I^Isetf python[J

line 1628: [J

line 1629: " Radiance[J

line 1630: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance[J

line 1631: [J

line 1632: " Ratpoison config/command files[J

line 1633: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison[J

line 1634: [J

line 1635: " RCS file[J

line 1636: au BufNewFile,BufRead *\,v^I^I^Isetf rcs[J

line 1637: [J

line 1638: " Readline[J

line 1639: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline[J

line 1640: [J

line 1641: " Registry for MS-Windows[J

line 1643: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif[J

line 1644: [J

line 1645: " Renderman Interface Bytestream[J

line 1646: au BufNewFile,BufRead *.rib^I^I^Isetf rib[J

line 1647: [J

line 1648: " Rexx[J

line 1649: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx[J

line 1650: [J

line 1651: " R (Splus)[J

line 1652: if has("fname_case")[J

line 1653:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r[J

line 1654: else[J

line 1655:   au BufNewFile,BufRead *.s^I^I^Isetf r[J

line 1656: endif[J

line 1657: [J

line 1658: " R Help file[J

line 1659: if has("fname_case")[J

line 1660:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp[J

line 1661: else[J

line 1662:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp[J

line 1663: endif[J

line 1664: [J

line 1665: " R noweb file[J

line 1666: if has("fname_case")[J

line 1667:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb[J

line 1668: else[J

line 1669:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb[J

line 1670: endif[J

line 1671: [J

line 1672: " R Markdown file[J

line 1673: if has("fname_case")[J

line 1674:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd[J

line 1675: else[J

line 1676:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd[J

line 1677: endif[J

line 1678: [J

line 1679: " R reStructuredText file[J

line 1680: if has("fname_case")[J

line 1681:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst[J

line 1682: else[J

line 1683:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst[J

line 1684: endif[J

line 1685: [J

line 1686: " Rexx, Rebol or R[J

line 1687: au BufNewFile,BufRead *.r,*.R^I^I^Icall s:FTr()[J

line 1688: [J

line 1689: func! s:FTr()[J

line 1721: [J

line 1722: " Remind[J

line 1723: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind[J

line 1724: [J

line 1725: " Resolv.conf[J

line 1726: au BufNewFile,BufRead resolv.conf^I^Isetf resolv[J

line 1727: [J

line 1728: " Relax NG Compact[J

line 1729: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc[J

line 1730: [J

line 1731: " Relax NG XML[J

line 1732: au BufNewFile,BufRead *.rng^I^I^Isetf rng[J

line 1733: [J

line 1734: " RPL/2[J

line 1735: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl[J

line 1736: [J

line 1737: " Robots.txt[J

line 1738: au BufNewFile,BufRead robots.txt^I^Isetf robots[J

line 1739: [J

line 1740: " Rpcgen[J

line 1741: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen[J

line 1742: [J

line 1743: " reStructuredText Documentation Format[J

line 1744: au BufNewFile,BufRead *.rst^I^I^Isetf rst[J

line 1745: [J

line 1746: " RTF[J

line 1747: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf[J

line 1748: [J

line 1749: " Interactive Ruby shell[J

line 1750: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby[J

line 1751: [J

line 1752: " Ruby[J

line 1753: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby[J

line 1754: [J

line 1755: " RubyGems[J

line 1756: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby[J

line 1757: [J

line 1758: " Rackup[J

line 1759: au BufNewFile,BufRead *.ru^I^I^Isetf ruby[J

line 1760: [J

line 1761: " Bundler[J

line 1762: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby[J

line 1763: [J

line 1764: " Ruby on Rails[J

line 1765: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby[J

line 1766: [J

line 1767: " Rantfile and Rakefile is like Ruby[J

line 1768: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby[J

line 1769: [J

line 1770: " S-lang (or shader language, or SmallLisp)[J

line 1771: au BufNewFile,BufRead *.sl^I^I^Isetf slang[J

line 1772: [J

line 1773: " Samba config[J

line 1774: au BufNewFile,BufRead smb.conf^I^I^Isetf samba[J

line 1775: [J

line 1776: " SAS script[J

line 1777: au BufNewFile,BufRead *.sas^I^I^Isetf sas[J

line 1778: [J

line 1779: " Sass[J

line 1780: au BufNewFile,BufRead *.sass^I^I^Isetf sass[J

line 1781: [J

line 1782: " Sather[J

line 1783: au BufNewFile,BufRead *.sa^I^I^Isetf sather[J

line 1784: [J

line 1785: " Scilab[J

line 1786: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab[J

line 1787: [J

line 1788: " SCSS[J

line 1789: au BufNewFile,BufRead *.scss^I^I^Isetf scss[J

line 1790: [J

line 1791: " SD: Streaming Descriptors[J

line 1792: au BufNewFile,BufRead *.sd^I^I^Isetf sd[J

line 1793: [J

line 1794: " SDL[J

line 1795: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl[J

line 1796: [J

line 1797: " sed[J

line 1798: au BufNewFile,BufRead *.sed^I^I^Isetf sed[J

line 1799: [J

line 1800: " Sieve (RFC 3028)[J

line 1801: au BufNewFile,BufRead *.siv^I^I^Isetf sieve[J

line 1802: [J

line 1803: " Sendmail[J

line 1804: au BufNewFile,BufRead sendmail.cf^I^Isetf sm[J

line 1805: [J

line 1806: " Sendmail .mc files are actually m4.  Could also be MS Message text file.[J

line 1807: au BufNewFile,BufRead *.mc^I^I^Icall s:McSetf()[J

line 1808: [J

line 1809: func! s:McSetf()[J

line 1824: [J

line 1825: " Services[J

line 1826: au BufNewFile,BufRead */etc/services^I^Isetf services[J

line 1827: [J

line 1828: " Service Location config[J

line 1829: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf[J

line 1830: [J

line 1831: " Service Location registration[J

line 1832: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg[J

line 1833: [J

line 1834: " Service Location SPI[J

line 1835: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi[J

line 1836: [J

line 1837: " Setserial config[J

line 1838: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial[J

line 1839: [J

line 1840: " SGML[J

line 1850: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif[J

line 1851: [J

line 1852: " SGMLDECL[J

line 1856: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif[J

line 1857: [J

line 1858: " SGML catalog file[J

line 1859: au BufNewFile,BufRead catalog^I^I^Isetf catalog[J

line 1860: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')[J

line 1861: [J

line 1862: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.[J

line 1863: " Gentoo ebuilds are actually bash scripts[J

line 1864: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass call SetFileTypeSH("bash")[J

line 1865: au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")[J

line 1866: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))[J

line 1867: [J

line 1868: " Also called from scripts.vim.[J

line 1869: func! SetFileTypeSH(name)[J

line 1912: [J

line 1913: " For shell-like file types, check for an "exec" command hidden in a comment,[J

line 1914: " as used for Tcl.[J

line 1915: " Also called from scripts.vim, thus can't be local to this script.[J

line 1916: func! SetFileTypeShell(name)[J

line 1935: [J

line 1936: " tcsh scripts[J

line 1937: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall SetFileTypeShell("tcsh")[J

line 1938: [J

line 1939: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)[J

line 1940: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()[J

line 1941: [J

line 1942: func! s:CSH()[J

line 1951: [J

line 1952: " Z-Shell script[J

line 1953: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh[J

line 1954: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')[J

line 1955: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh[J

line 1956: [J

line 1957: " Scheme[J

line 1958: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme[J

line 1959: [J

line 1960: " Screen RC[J

line 1961: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen[J

line 1962: [J

line 1963: " Simula[J

line 1964: au BufNewFile,BufRead *.sim^I^I^Isetf simula[J

line 1965: [J

line 1966: " SINDA[J

line 1967: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda[J

line 1968: [J

line 1969: " SiSU[J

line 1970: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu[J

line 1971: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu[J

line 1972: [J

line 1973: " SKILL[J

line 1974: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill[J

line 1975: [J

line 1976: " SLRN[J

line 1977: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc[J

line 1978: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc[J

line 1979: [J

line 1980: " Smalltalk (and TeX)[J

line 1981: au BufNewFile,BufRead *.st^I^I^Isetf st[J

line 1989: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif[J

line 1990: [J

line 1991: " Smarty templates[J

line 1992: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty[J

line 1993: [J

line 1994: " SMIL or XML[J

line 2000: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif[J

line 2001: [J

line 2002: " SMIL or SNMP MIB file[J

line 2008: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif[J

line 2009: [J

line 2010: " SMITH[J

line 2011: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith[J

line 2012: [J

line 2013: " Snobol4 and spitbol[J

line 2014: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4[J

line 2015: [J

line 2016: " SNMP MIB files[J

line 2017: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib[J

line 2018: [J

line 2019: " Snort Configuration[J

line 2020: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog[J

line 2021: au BufNewFile,BufRead *.rules^I^I^Icall s:FTRules()[J

line 2022: [J

line 2023: let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'[J

line 2024: func! s:FTRules()[J

line 2056: [J

line 2057: [J

line 2058: " Spec (Linux RPM)[J

line 2059: au BufNewFile,BufRead *.spec^I^I^Isetf spec[J

line 2060: [J

line 2061: " Speedup (AspenTech plant simulator)[J

line 2062: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup[J

line 2063: [J

line 2064: " Slice[J

line 2065: au BufNewFile,BufRead *.ice^I^I^Isetf slice[J

line 2066: [J

line 2067: " Spice[J

line 2068: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice[J

line 2069: [J

line 2070: " Spyce[J

line 2071: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce[J

line 2072: [J

line 2073: " Squid[J

line 2074: au BufNewFile,BufRead squid.conf^I^Isetf squid[J

line 2075: [J

line 2076: " SQL for Oracle Designer[J

line 2077: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql[J

line 2078: [J

line 2079: " SQL[J

line 2080: au BufNewFile,BufRead *.sql^I^I^Icall s:SQL()[J

line 2081: [J

line 2082: func! s:SQL()[J

line 2089: [J

line 2090: " SQLJ[J

line 2091: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj[J

line 2092: [J

line 2093: " SQR[J

line 2094: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr[J

line 2095: [J

line 2096: " OpenSSH configuration[J

line 2097: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig[J

line 2098: [J

line 2099: " OpenSSH server configuration[J

line 2100: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig[J

line 2101: [J

line 2102: " Stata[J

line 2103: au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata[J

line 2104: [J

line 2105: " SMCL[J

line 2106: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl[J

line 2107: [J

line 2108: " Stored Procedures[J

line 2109: au BufNewFile,BufRead *.stp^I^I^Isetf stp[J

line 2110: [J

line 2111: " Standard ML[J

line 2112: au BufNewFile,BufRead *.sml^I^I^Isetf sml[J

line 2113: [J

line 2114: " Sratus VOS command macro[J

line 2115: au BufNewFile,BufRead *.cm^I^I^Isetf voscm[J

line 2116: [J

line 2117: " Sysctl[J

line 2118: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl[J

line 2119: [J

line 2120: " Systemd unit files[J

line 2121: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd[J

line 2122: [J

line 2123: " Synopsys Design Constraints[J

line 2124: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc[J

line 2125: [J

line 2126: " Sudoers[J

line 2127: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers[J

line 2128: [J

line 2129: " SVG (Scalable Vector Graphics)[J

line 2130: au BufNewFile,BufRead *.svg^I^I^Isetf svg[J

line 2131: [J

line 2132: " If the file has an extension of 't' and is in a directory 't' or 'xt' then[J

line 2133: " it is almost certainly a Perl test file.[J

line 2134: " If the first line starts with '#' and contains 'perl' it's probably a Perl[J

line 2135: " file.[J

line 2136: " (Slow test) If a file contains a 'use' statement then it is almost certainly[J

line 2137: " a Perl file.[J

line 2138: func! s:FTperl()[J

line 2154: [J

line 2155: " Tads (or Nroff or Perl test file)[J

line 2157: au BufNewFile,BufRead *.t if !s:FTnroff() && !s:FTperl() | setf tads | endif[J

line 2158: [J

line 2159: " Tags[J

line 2160: au BufNewFile,BufRead tags^I^I^Isetf tags[J

line 2161: [J

line 2162: " TAK[J

line 2163: au BufNewFile,BufRead *.tak^I^I^Isetf tak[J

line 2164: [J

line 2165: " Task[J

line 2166: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata[J

line 2167: au BufRead,BufNewFile *.task^I^I^Isetf taskedit[J

line 2168: [J

line 2169: " Tcl (JACL too)[J

line 2170: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl[J

line 2171: [J

line 2172: " TealInfo[J

line 2173: au BufNewFile,BufRead *.tli^I^I^Isetf tli[J

line 2174: [J

line 2175: " Telix Salt[J

line 2176: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt[J

line 2177: [J

line 2178: " Tera Term Language[J

line 2179: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm[J

line 2180: [J

line 2181: " Terminfo[J

line 2182: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo[J

line 2183: [J

line 2184: " TeX[J

line 2185: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex[J

line 2186: au BufNewFile,BufRead *.tex^I^I^Icall s:FTtex()[J

line 2187: [J

line 2188: " Choose context, plaintex, or tex (LaTeX) based on these rules:[J

line 2189: " 1. Check the first line of the file for "%&<format>".[J

line 2190: " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.[J

line 2191: " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.[J

line 2192: func! s:FTtex()[J

line 2239: [J

line 2240: " ConTeXt[J

line 2241: au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context[J

line 2242: [J

line 2243: " Texinfo[J

line 2244: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo[J

line 2245: [J

line 2246: " TeX configuration[J

line 2247: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf[J

line 2248: [J

line 2249: " Tidy config[J

line 2250: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy[J

line 2251: [J

line 2252: " TF mud client[J

line 2253: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf[J

line 2254: [J

line 2255: " TPP - Text Presentation Program[J

line 2256: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp[J

line 2257: [J

line 2258: " Treetop[J

line 2259: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop[J

line 2260: [J

line 2261: " Trustees[J

line 2262: au BufNewFile,BufRead trustees.conf^I^Isetf trustees[J

line 2263: [J

line 2264: " TSS - Geometry[J

line 2265: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm[J

line 2266: [J

line 2267: " TSS - Optics[J

line 2268: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop[J

line 2269: [J

line 2270: " TSS - Command Line (temporary)[J

line 2271: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl[J

line 2272: [J

line 2273: " TWIG files[J

line 2274: au BufNewFile,BufReadPost *.twig^I^Isetf twig[J

line 2275: [J

line 2276: " Motif UIT/UIL files[J

line 2277: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil[J

line 2278: [J

line 2279: " Udev conf[J

line 2280: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf[J

line 2281: [J

line 2282: " Udev permissions[J

line 2283: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm[J

line 2284: "[J

line 2285: " Udev symlinks config[J

line 2286: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh[J

line 2287: [J

line 2288: " UnrealScript[J

line 2289: au BufNewFile,BufRead *.uc^I^I^Isetf uc[J

line 2290: [J

line 2291: " Updatedb[J

line 2292: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb[J

line 2293: [J

line 2294: " Upstart (init(8)) config files[J

line 2295: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart[J

line 2296: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart[J

line 2297: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart[J

line 2298: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart[J

line 2299: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart[J

line 2300: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart[J

line 2301: [J

line 2302: " Vera[J

line 2303: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera[J

line 2304: [J

line 2305: " Verilog HDL[J

line 2306: au BufNewFile,BufRead *.v^I^I^Isetf verilog[J

line 2307: [J

line 2308: " Verilog-AMS HDL[J

line 2309: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams[J

line 2310: [J

line 2311: " SystemVerilog[J

line 2312: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog[J

line 2313: [J

line 2314: " VHDL[J

line 2315: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl[J

line 2316: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')[J

line 2317: [J

line 2318: " Vim script[J

line 2319: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim[J

line 2320: [J

line 2321: " Viminfo file[J

line 2322: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo[J

line 2323: [J

line 2324: " Virata Config Script File or Drupal module[J

line 2330: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif[J

line 2331: [J

line 2332: " Visual Basic (also uses *.bas) or FORM[J

line 2333: au BufNewFile,BufRead *.frm^I^I^Icall s:FTVB("form")[J

line 2334: [J

line 2335: " SaxBasic is close to Visual Basic[J

line 2336: au BufNewFile,BufRead *.sba^I^I^Isetf vb[J

line 2337: [J

line 2338: " Vgrindefs file[J

line 2339: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs[J

line 2340: [J

line 2341: " VRML V1.0c[J

line 2342: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml[J

line 2343: [J

line 2344: " Vroom (vim testing and executable documentation)[J

line 2345: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom[J

line 2346: [J

line 2347: " Webmacro[J

line 2348: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro[J

line 2349: [J

line 2350: " Wget config[J

line 2351: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget[J

line 2352: [J

line 2353: " Website MetaLanguage[J

line 2354: au BufNewFile,BufRead *.wml^I^I^Isetf wml[J

line 2355: [J

line 2356: " Winbatch[J

line 2357: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch[J

line 2358: [J

line 2359: " WSML[J

line 2360: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml[J

line 2361: [J

line 2362: " WvDial[J

line 2363: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial[J

line 2364: [J

line 2365: " CVS RC file[J

line 2366: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc[J

line 2367: [J

line 2368: " CVS commit file[J

line 2369: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs[J

line 2370: [J

line 2371: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment[J

line 2372: " lines in a WEB file).[J

line 2378: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif[J

line 2379: [J

line 2380: " Windows Scripting Host and Windows Script Component[J

line 2381: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh[J

line 2382: [J

line 2383: " XHTML[J

line 2384: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml[J

line 2385: [J

line 2386: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)[J

line 2392: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif[J

line 2393: au BufEnter *.xpm2^I^I^I^Isetf xpm2[J

line 2394: [J

line 2395: " XFree86 config[J

line 2400: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf[J

line 2403: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf[J

line 2404: [J

line 2405: " Xorg config[J

line 2406: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf[J

line 2407: [J

line 2408: " Xinetd conf[J

line 2409: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd[J

line 2410: [J

line 2411: " XS Perl extension interface language[J

line 2412: au BufNewFile,BufRead *.xs^I^I^Isetf xs[J

line 2413: [J

line 2414: " X resources file[J

line 2415: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults[J

line 2416: [J

line 2417: " Xmath[J

line 2418: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath[J

line 2420: au BufNewFile,BufRead *.ms if !s:FTnroff() | setf xmath | endif[J

line 2421: [J

line 2422: " XML  specific variants: docbk and xbl[J

line 2423: au BufNewFile,BufRead *.xml^I^I^Icall s:FTxml()[J

line 2424: [J

line 2425: func! s:FTxml()[J

line 2450: [J

line 2451: " XMI (holding UML models) is also XML[J

line 2452: au BufNewFile,BufRead *.xmi^I^I^Isetf xml[J

line 2453: [J

line 2454: " CSPROJ files are Visual Studio.NET's XML-based project config files[J

line 2455: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml[J

line 2456: [J

line 2457: " Qt Linguist translation source and Qt User Interface Files are XML[J

line 2458: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml[J

line 2459: [J

line 2460: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)[J

line 2461: au BufNewFile,BufRead *.tpm^I^I^Isetf xml[J

line 2462: [J

line 2463: " Xdg menus[J

line 2464: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml[J

line 2465: [J

line 2466: " ATI graphics driver configuration[J

line 2467: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml[J

line 2468: [J

line 2469: " XLIFF (XML Localisation Interchange File Format) is also XML[J

line 2470: au BufNewFile,BufRead *.xlf^I^I^Isetf xml[J

line 2471: au BufNewFile,BufRead *.xliff^I^I^Isetf xml[J

line 2472: [J

line 2473: " XML User Interface Language[J

line 2474: au BufNewFile,BufRead *.xul^I^I^Isetf xml[J

line 2475: [J

line 2476: " X11 xmodmap (also see below)[J

line 2477: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap[J

line 2478: [J

line 2479: " Xquery[J

line 2480: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery[J

line 2481: [J

line 2482: " XSD[J

line 2483: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd[J

line 2484: [J

line 2485: " Xslt[J

line 2486: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt[J

line 2487: [J

line 2488: " Yacc[J

line 2489: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc[J

line 2490: [J

line 2491: " Yacc or racc[J

line 2492: au BufNewFile,BufRead *.y^I^I^Icall s:FTy()[J

line 2493: [J

line 2494: func! s:FTy()[J

line 2510: [J

line 2511: [J

line 2512: " Yaml[J

line 2513: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml[J

line 2514: [J

line 2515: " yum conf (close enough to dosini)[J

line 2516: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini[J

line 2517: [J

line 2518: " Zimbu[J

line 2519: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu[J

line 2520: " Zimbu Templates[J

line 2521: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl[J

line 2522: [J

line 2523: " Zope[J

line 2524: "   dtml (zope dynamic template markup language), pt (zope page template),[J

line 2525: "   cpt (zope form controller page template)[J

line 2526: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall s:FThtml()[J

line 2527: "   zsql (zope sql method)[J

line 2528: au BufNewFile,BufRead *.zsql^I^I^Icall s:SQL()[J

line 2529: [J

line 2530: " Z80 assembler asz80[J

line 2531: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a[J

line 2532: [J

line 2533: augroup END[J

line 2534: [J

line 2535: [J

line 2536: " Source the user-specified filetype file, for backwards compatibility with[J

line 2537: " Vim 5.x.[J

line 2538: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))[J

line 2539:   execute "source " . myfiletypefile[J

line 2540: endif[J

line 2541: [J

line 2542: [J

line 2543: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used[J

line 2544: " when there are no matching file name extensions.[J

line 2545: " Don't do this for compressed files.[J

line 2546: augroup filetypedetect[J

line 2549: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif[J

line 2550: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif[J

line 2551: [J

line 2552: [J

line 2553: " Extra checks for when no filetype has been detected now.  Mostly used for[J

line 2554: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim[J

line 2555: " script file.[J

line 2556: " Most of these should call s:StarSetf() to avoid names ending in .gz and the[J

line 2557: " like are used.[J

line 2558: [J

line 2559: " More Apache config files[J

line 2560: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')[J

line 2561: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')[J

line 2562: [J

line 2563: " Asterisk config file[J

line 2564: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')[J

line 2565: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')[J

line 2566: [J

line 2567: " Bazaar version control[J

line 2568: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr[J

line 2569: [J

line 2570: " BIND zone[J

line 2571: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')[J

line 2572: [J

line 2573: " Calendar[J

line 2576: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')[J

line 2577: [J

line 2578: " Changelog[J

line 2584: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif[J

line 2585: [J

line 2586: " Crontab[J

line 2587: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')[J

line 2588: [J

line 2589: " dnsmasq(8) configuration[J

line 2590: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')[J

line 2591: [J

line 2592: " Dracula[J

line 2593: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')[J

line 2594: [J

line 2595: " Fvwm[J

line 2596: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')[J

line 2598: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')[J

line 2604: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif[J

line 2605: [J

line 2606: " Gedcom[J

line 2607: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')[J

line 2608: [J

line 2609: " GTK RC[J

line 2610: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')[J

line 2611: [J

line 2612: " Jam[J

line 2613: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')[J

line 2614: [J

line 2615: " Jargon[J

line 2619: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif[J

line 2620: [J

line 2621: " Kconfig[J

line 2622: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')[J

line 2623: [J

line 2624: " Lilo: Linux loader[J

line 2625: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')[J

line 2626: [J

line 2627: " Logcheck[J

line 2628: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')[J

line 2629: [J

line 2630: " Makefile[J

line 2631: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')[J

line 2632: [J

line 2633: " Ruby Makefile[J

line 2634: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')[J

line 2635: [J

line 2636: " Mail (also matches muttrc.vim, so this is below the other checks)[J

line 2637: au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}^Isetf mail[J

line 2638: [J

line 2639: " Modconf[J

line 2643: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif[J

line 2644: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')[J

line 2645: [J

line 2646: " Mutt setup file[J

line 2647: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')[J

line 2648: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')[J

line 2649: [J

line 2650: " Nroff macros[J

line 2651: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')[J

line 2652: [J

line 2653: " Pam conf[J

line 2654: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')[J

line 2655: [J

line 2656: " Printcap and Termcap[J

line 2660: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif[J

line 2664: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif[J

line 2665: [J

line 2666: " ReDIF[J

line 2667: " Only used when the .rdf file was not detected to be XML.[J

line 2668: au BufRead,BufNewFile *.rdf^I^I^Icall s:Redif()[J

line 2669: func! s:Redif()[J

line 2679: [J

line 2680: " Remind[J

line 2681: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')[J

line 2682: [J

line 2683: " Vim script[J

line 2684: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')[J

line 2685: [J

line 2686: " Subversion commit file[J

line 2687: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn[J

line 2688: [J

line 2689: " X resources file[J

line 2690: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')[J

line 2691: [J

line 2692: " XFree86 config[J

line 2694: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')[J

line 2699: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')[J

line 2700: [J

line 2701: " X11 xmodmap[J

line 2702: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')[J

line 2703: [J

line 2704: " Xinetd conf[J

line 2705: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')[J

line 2706: [J

line 2707: " yum conf (close enough to dosini)[J

line 2708: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')[J

line 2709: [J

line 2710: " Z-Shell script[J

line 2711: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')[J

line 2712: [J

line 2713: [J

line 2714: " Plain text files, needs to be far down to not override others.  This avoids[J

line 2715: " the "conf" type being used if there is a line starting with '#'.[J

line 2716: au BufNewFile,BufRead *.txt,*.text,README^Isetf text[J

line 2717: [J

line 2718: [J

line 2719: " Use the filetype detect plugins.  They may overrule any of the previously[J

line 2720: " detected filetypes.[J

line 2721: runtime! ftdetect/*.vim[J

Searching for "ftdetect/*.vim" in "/Users/ygarrot/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vim74/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/after/ftdetect/*.vim"[J
not found in 'runtimepath': "ftdetect/*.vim"[J
line 2722: [J

line 2723: " NOTE: The above command could have ended the filetypedetect autocmd group[J

line 2724: " and started another one. Let's make sure it has ended to get to a consistent[J

line 2725: " state.[J

line 2726: augroup END[J

line 2727: [J

line 2728: " Generic configuration file (check this last, it's just guessing!)[J

line 2734: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf conf | endif[J

line 2735: [J

line 2736: [J

line 2737: " If the GUI is already running, may still need to install the Syntax menu.[J

line 2738: " Don't do it when the 'M' flag is included in 'guioptions'.[J

line 2740: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"[J

line 2741:   source <sfile>:p:h/menu.vim[J

line 2742: endif[J

line 2743: [J

line 2744: " Function called for testing all functions defined here.  These are[J

line 2745: " script-local, thus need to be executed here.[J

line 2746: " Returns a string with error messages (hopefully empty).[J

line 2747: func! TestFiletypeFuncs(testlist)[J

line 2758: [J

line 2759: " Restore 'cpoptions'[J

line 2760: let &cpo = s:cpo_save[J

line 2761: unlet s:cpo_save[J

finished sourcing /usr/share/vim/vim74/filetype.vim[J
continuing in /usr/share/vim/vimrc[J
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/after/filetype.vim"[J
Searching for "ftplugin.vim" in "/Users/ygarrot/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/ftplugin.vim"[J
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"[J
Searching for "/usr/share/vim/vim74/ftplugin.vim"[J
chdir(/usr/share/vim/vim74)[J
fchdir() to previous dir[J
line 18: sourcing "/usr/share/vim/vim74/ftplugin.vim"[J
line 1: " Vim support file to switch on loading plugins for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2006 Apr 30[J

line 5: [J

line 6: if exists("did_load_ftplugin")[J

line 7:   finish[J

line 8: endif[J

line 9: let did_load_ftplugin = 1[J

line 10: [J

line 11: augroup filetypeplugin[J

line 12:   au FileType * call s:LoadFTPlugin()[J

line 13: [J

line 14:   func! s:LoadFTPlugin()[J

line 35: augroup END[J

finished sourcing /usr/share/vim/vim74/ftplugin.vim[J
continuing in /usr/share/vim/vimrc[J
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/after/ftplugin.vim"[J
Searching for "indent.vim" in "/Users/ygarrot/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/indent.vim"[J
Searching for "/usr/share/vim/vimfiles/indent.vim"[J
Searching for "/usr/share/vim/vim74/indent.vim"[J
chdir(/usr/share/vim/vim74)[J
fchdir() to previous dir[J
line 18: sourcing "/usr/share/vim/vim74/indent.vim"[J
line 1: " Vim support file to switch on loading indent files for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2008 Feb 22[J

line 5: [J

line 6: if exists("did_indent_on")[J

line 7:   finish[J

line 8: endif[J

line 9: let did_indent_on = 1[J

line 10: [J

line 11: augroup filetypeindent[J

line 12:   au FileType * call s:LoadIndent()[J

line 13:   func! s:LoadIndent()[J

line 31: augroup END[J

finished sourcing /usr/share/vim/vim74/indent.vim[J
continuing in /usr/share/vim/vimrc[J
Searching for "/usr/share/vim/vimfiles/after/indent.vim"[J
Searching for "/Users/ygarrot/.vim/after/indent.vim"[J
line 19: set smartindent[J

line 20: [J

line 21: "Non-expanded, 4-wide tabulations[J

line 22: set tabstop=4[J

line 23: set shiftwidth=4[J

line 24: set noexpandtab[J

line 25: [J

line 26: "Disable vi-compatibility[J

line 27: set nocompatible[J

line 28: [J

line 29: "Real-world encoding[J

line 30: set encoding=utf-8[J

line 31: [J

line 32: "Interpret modelines in files[J

line 33: set modelines=1[J

line 34: [J

line 35: "Do not abandon buffers[J

line 36: set hidden[J

line 37: [J

line 38: "Don't bother throttling tty[J

line 39: set ttyfast[J

line 40: [J

line 41: "More useful backspace behavior[J

line 42: set backspace=indent,eol,start[J

line 43: [J

line 44: "Use statusbar on all windows[J

line 45: set laststatus=2[J

line 46: [J

line 47: "Better search[J

line 48: set ignorecase[J

line 49: set smartcase[J

line 50: set incsearch[J

line 51: set showmatch[J

line 52: set hlsearch[J

line 53: [J

line 54: "Prevent backups when editing system files[J

line 55: au BufWrite /private/tmp/crontab.* set nowritebackup[J

line 56: au BufWrite /private/etc/pw.* set nowritebackup[J

line 57: [J

line 58: "Source user configuration[J

line 59: if filereadable(expand("~/.myvimrc"))[J

line 60: ^Isource ~/.myvimrc[J

line 61: endif[J

finished sourcing $VIM/vimrc[J
chdir(/Users/ygarrot)[J
fchdir() to previous dir[J
sourcing "$HOME/.vimrc"[J
line 1: scriptencoding utf-8[J

line 2: set encoding=utf-8[J

line 3: [J

line 4: let mapleader =","[J

line 5: [J

line 6: call plug#begin('~/.vim/plugged')[J

Searching for "autoload/plug.vim" in "/Users/ygarrot/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/autoload/plug.vim"[J
chdir(/Users/ygarrot/.vim/autoload)[J
fchdir() to previous dir[J
line 6: sourcing "/Users/ygarrot/.vim/autoload/plug.vim"[J
line 1: " vim-plug: Vim plugin manager[J

line 2: " ============================[J

line 3: "[J

line 4: " Download plug.vim and put it in ~/.vim/autoload[J

line 5: "[J

line 6: "   curl -fLo ~/.vim/autoload/plug.vim --create-dirs \[J

line 7: "     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim[J

line 8: "[J

line 9: " Edit your .vimrc[J

line 10: "[J

line 11: "   call plug#begin('~/.vim/plugged')[J

line 12: "[J

line 13: "   " Make sure you use single quotes[J

line 14: "[J

line 15: "   " Shorthand notation; fetches https://github.com/junegunn/vim-easy-align[J

line 16: "   Plug 'junegunn/vim-easy-align'[J

line 17: "[J

line 18: "   " Any valid git URL is allowed[J

line 19: "   Plug 'https://github.com/junegunn/vim-github-dashboard.git'[J

line 20: "[J

line 21: "   " Multiple Plug commands can be written in a single line using | separators[J

line 22: "   Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'[J

line 23: "[J

line 24: "   " On-demand loading[J

line 25: "   Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeToggle' }[J

line 26: "   Plug 'tpope/vim-fireplace', { 'for': 'clojure' }[J

line 27: "[J

line 28: "   " Using a non-master branch[J

line 29: "   Plug 'rdnetto/YCM-Generator', { 'branch': 'stable' }[J

line 30: "[J

line 31: "   " Using a tagged release; wildcard allowed (requires git 1.9.2 or above)[J

line 32: "   Plug 'fatih/vim-go', { 'tag': '*' }[J

line 33: "[J

line 34: "   " Plugin options[J

line 35: "   Plug 'nsf/gocode', { 'tag': 'v.20150303', 'rtp': 'vim' }[J

line 36: "[J

line 37: "   " Plugin outside ~/.vim/plugged with post-update hook[J

line 38: "   Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }[J

line 39: "[J

line 40: "   " Unmanaged plugin (manually installed and updated)[J

line 41: "   Plug '~/my-prototype-plugin'[J

line 42: "[J

line 43: "   " Initialize plugin system[J

line 44: "   call plug#end()[J

line 45: "[J

line 46: " Then reload .vimrc and :PlugInstall to install plugins.[J

line 47: "[J

line 48: " Plug options:[J

line 49: "[J

line 50: "| Option                  | Description                                      |[J

line 51: "| ----------------------- | ------------------------------------------------ |[J

line 52: "| `branch`/`tag`/`commit` | Branch/tag/commit of the repository to use       |[J

line 53: "| `rtp`                   | Subdirectory that contains Vim plugin            |[J

line 54: "| `dir`                   | Custom directory for the plugin                  |[J

line 55: "| `as`                    | Use different name for the plugin                |[J

line 56: "| `do`                    | Post-update hook (string or funcref)             |[J

line 57: "| `on`                    | On-demand loading: Commands or `<Plug>`-mappings |[J

line 58: "| `for`                   | On-demand loading: File types                    |[J

line 59: "| `frozen`                | Do not update unless explicitly specified        |[J

line 60: "[J

line 61: " More information: https://github.com/junegunn/vim-plug[J

line 62: "[J

line 63: "[J

line 64: " Copyright (c) 2017 Junegunn Choi[J

line 65: "[J

line 66: " MIT License[J

line 67: "[J

line 68: " Permission is hereby granted, free of charge, to any person obtaining[J

line 69: " a copy of this software and associated documentation files (the[J

line 70: " "Software"), to deal in the Software without restriction, including[J

line 71: " without limitation the rights to use, copy, modify, merge, publish,[J

line 72: " distribute, sublicense, and/or sell copies of the Software, and to[J

line 73: " permit persons to whom the Software is furnished to do so, subject to[J

line 74: " the following conditions:[J

line 75: "[J

line 76: " The above copyright notice and this permission notice shall be[J

line 77: " included in all copies or substantial portions of the Software.[J

line 78: "[J

line 79: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,[J

line 80: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF[J

line 81: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND[J

line 82: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE[J

line 83: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION[J

line 84: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION[J

line 85: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.[J

line 86: [J

line 87: if exists('g:loaded_plug')[J

line 88:   finish[J

line 89: endif[J

line 90: let g:loaded_plug = 1[J

line 91: [J

line 92: let s:cpo_save = &cpo[J

line 93: set cpo&vim[J

line 94: [J

line 95: let s:plug_src = 'https://github.com/junegunn/vim-plug.git'[J

line 96: let s:plug_tab = get(s:, 'plug_tab', -1)[J

line 97: let s:plug_buf = get(s:, 'plug_buf', -1)[J

line 98: let s:mac_gui = has('gui_macvim') && has('gui_running')[J

line 99: let s:is_win = has('win32')[J

line 100: let s:nvim = has('nvim-0.2') || (has('nvim') && exists('*jobwait') && !s:is_win)[J

line 101: let s:vim8 = has('patch-8.0.0039') && exists('*job_start')[J

line 102: let s:me = resolve(expand('<sfile>:p'))[J

line 103: let s:base_spec = { 'branch': 'master', 'frozen': 0 }[J

line 109: let s:TYPE = {   'string':  type(''),   'list':    type([]),   'dict':    type({}),   'funcref': type(function('call')) }[J

line 110: let s:loaded = get(s:, 'loaded', {})[J

line 111: let s:triggers = get(s:, 'triggers', {})[J

line 112: [J

line 113: function! plug#begin(...)[J

line 136: [J

line 137: function! s:define_commands()[J

line 150: [J

line 151: function! s:to_a(v)[J

line 154: [J

line 155: function! s:to_s(v)[J

line 158: [J

line 159: function! s:glob(from, pattern)[J

line 162: [J

line 163: function! s:source(from, ...)[J

line 173: [J

line 174: function! s:assoc(dict, key, val)[J

line 177: [J

line 178: function! s:ask(message, ...)[J

line 187: [J

line 188: function! s:ask_no_interrupt(...)[J

line 195: [J

line 196: function! s:lazy(plug, opt)[J

line 203: [J

line 204: function! plug#end()[J

line 296: [J

line 297: function! s:loaded_names()[J

line 300: [J

line 301: function! s:load_plugin(spec)[J

line 304: [J

line 305: function! s:reload_plugins()[J

line 310: [J

line 311: function! s:trim(str)[J

line 314: [J

line 315: function! s:version_requirement(val, min)[J

line 324: [J

line 325: function! s:git_version_requirement(...)[J

line 331: [J

line 332: function! s:progress_opt(base)[J

line 336: [J

line 337: if s:is_win[J

line 338:   function! s:rtp(spec)[J

line 341: [J

line 342:   function! s:path(path)[J

line 345: [J

line 346:   function! s:dirpath(path)[J

line 349: [J

line 350:   function! s:is_local_plug(repo)[J

line 353: else[J

line 354:   function! s:rtp(spec)[J

line 357: [J

line 358:   function! s:path(path)[J

line 361: [J

line 362:   function! s:dirpath(path)[J

line 365: [J

line 366:   function! s:is_local_plug(repo)[J

line 369: endif[J

line 370: [J

line 371: function! s:err(msg)[J

line 376: [J

line 377: function! s:warn(cmd, msg)[J

line 382: [J

line 383: function! s:esc(path)[J

line 386: [J

line 387: function! s:escrtp(path)[J

line 390: [J

line 391: function! s:remove_rtp()[J

line 401: [J

line 402: function! s:reorg_rtp()[J

line 428: [J

line 429: function! s:doautocmd(...)[J

line 434: [J

line 435: function! s:dobufread(names)[J

line 448: [J

line 449: function! plug#load(...)[J

line 472: [J

line 473: function! s:remove_triggers(name)[J

line 486: [J

line 487: function! s:lod(names, types, ...)[J

line 508: [J

line 509: function! s:lod_ft(pat, names)[J

line 516: [J

line 517: function! s:lod_cmd(cmd, bang, l1, l2, args, names)[J

line 522: [J

line 523: function! s:lod_map(map, names, with_prefix, prefix)[J

line 548: [J

line 549: function! plug#(repo, ...)[J

line 568: [J

line 569: function! s:parse_options(arg)[J

line 584: [J

line 585: function! s:infer_properties(name, repo)[J

line 602: [J

line 603: function! s:install(force, names)[J

line 606: [J

line 607: function! s:update(force, names)[J

line 610: [J

line 611: function! plug#helptags()[J

line 623: [J

line 624: function! s:syntax()[J

line 675: [J

line 676: function! s:lpad(str, len)[J

line 679: [J

line 680: function! s:lines(msg)[J

line 683: [J

line 684: function! s:lastline(msg)[J

line 687: [J

line 688: function! s:new_window()[J

line 691: [J

line 692: function! s:plug_window_exists()[J

line 696: [J

line 697: function! s:switch_in()[J

line 715: [J

line 716: function! s:switch_out(...)[J

line 729: [J

line 730: function! s:finish_bindings()[J

line 739: [J

line 740: function! s:prepare(...)[J

line 782: [J

line 783: function! s:assign_name()[J

line 794: [J

line 795: function! s:chsh(swap)[J

line 804: [J

line 805: function! s:bang(cmd, ...)[J

line 827: [J

line 828: function! s:regress_bar()[J

line 832: [J

line 833: function! s:is_updated(dir)[J

line 836: [J

line 837: function! s:do(pull, force, todo)[J

line 890: [J

line 891: function! s:hash_match(a, b)[J

line 894: [J

line 895: function! s:checkout(spec)[J

line 904: [J

line 905: function! s:finish(pull)[J

line 928: [J

line 929: function! s:retry()[J

line 937: [J

line 938: function! s:is_managed(name)[J

line 941: [J

line 942: function! s:names(...)[J

line 945: [J

line 946: function! s:check_ruby()[J

line 956: [J

line 957: function! s:update_impl(pull, force, args) abort[J

line 1074: [J

line 1075: function! s:log4(name, msg)[J

line 1079: [J

line 1080: function! s:update_finish()[J

line 1141: [J

line 1142: function! s:job_abort()[J

line 1159: [J

line 1160: function! s:last_non_empty_line(lines)[J

line 1170: [J

line 1171: function! s:job_out_cb(self, data) abort[J

line 1184: [J

line 1185: function! s:job_exit_cb(self, data) abort[J

line 1191: [J

line 1192: function! s:job_cb(fn, job, ch, data)[J

line 1198: [J

line 1199: function! s:nvim_cb(job_id, data, event) dict abort[J

line 1204: [J

line 1205: function! s:spawn(name, cmd, opts)[J

line 1250: [J

line 1251: function! s:reap(name)[J

line 1270: [J

line 1271: function! s:bar()[J

line 1280: [J

line 1281: function! s:logpos(name)[J

line 1294: [J

line 1295: function! s:log(bullet, name, lines)[J

line 1312: [J

line 1313: function! s:update_vim()[J

line 1319: [J

line 1320: function! s:tick()[J

line 1369: [J

line 1370: function! s:update_python()[J

line 1758: [J

line 1759: function! s:update_ruby()[J

line 1984: [J

line 1985: function! s:shellesc_cmd(arg)[J

line 1992: [J

line 1993: function! s:shellesc(arg)[J

line 1999: [J

line 2000: function! s:glob_dir(path)[J

line 2003: [J

line 2004: function! s:progress_bar(line, bar, total)[J

line 2007: [J

line 2008: function! s:compare_git_uri(a, b)[J

line 2019: [J

line 2020: function! s:format_message(bullet, name, message)[J

line 2028: [J

line 2029: function! s:with_cd(cmd, dir)[J

line 2032: [J

line 2033: function! s:system(cmd, ...)[J

line 2050: [J

line 2051: function! s:system_chomp(...)[J

line 2055: [J

line 2056: function! s:git_validate(spec, check_branch)[J

line 2115: [J

line 2116: function! s:rm_rf(dir)[J

line 2121: [J

line 2122: function! s:clean(force)[J

line 2192: [J

line 2193: function! s:delete_op(type, ...)[J

line 2196: [J

line 2197: function! s:delete(range, force)[J

line 2219: [J

line 2220: function! s:upgrade()[J

line 2246: [J

line 2247: function! s:upgrade_specs()[J

line 2252: [J

line 2253: function! s:status()[J

line 2298: [J

line 2299: function! s:extract_name(str, prefix, suffix)[J

line 2302: [J

line 2303: function! s:status_load(lnum)[J

line 2313: [J

line 2314: function! s:status_update() range[J

line 2322: [J

line 2323: function! s:is_preview_window_open()[J

line 2330: [J

line 2331: function! s:find_name(lnum)[J

line 2344: [J

line 2345: function! s:preview_commit()[J

line 2387: [J

line 2388: function! s:section(flags)[J

line 2391: [J

line 2392: function! s:format_git_log(line)[J

line 2403: [J

line 2404: function! s:append_ul(lnum, text)[J

line 2407: [J

line 2408: function! s:diff()[J

line 2461: [J

line 2462: function! s:revert()[J

line 2479: [J

line 2480: function! s:snapshot(force, ...) abort[J

line 2511: [J

line 2512: function! s:split_rtp()[J

line 2515: [J

line 2516: let s:first_rtp = s:escrtp(get(s:split_rtp(), 0, ''))[J

calling function <SNR>7_split_rtp[J()

line 1:   return split(&rtp, '\\\@<!,')[J

function <SNR>7_split_rtp returning ['/Users/ygarrot/.vim', '/usr/share/v...les/after', '/Users/ygarrot/.vim/after'][J

continuing in /Users/ygarrot/.vim/autoload/plug.vim[J

calling function <SNR>7_escrtp[J('/Users/ygarrot/.vim')

line 1:   return escape(a:path, ' ,')[J

function <SNR>7_escrtp returning '/Users/ygarrot/.vim'[J

continuing in /Users/ygarrot/.vim/autoload/plug.vim[J

line 2517: let s:last_rtp  = s:escrtp(get(s:split_rtp(), -1, ''))[J

calling function <SNR>7_split_rtp[J()

line 1:   return split(&rtp, '\\\@<!,')[J

function <SNR>7_split_rtp returning ['/Users/ygarrot/.vim', '/usr/share/v...les/after', '/Users/ygarrot/.vim/after'][J

continuing in /Users/ygarrot/.vim/autoload/plug.vim[J

calling function <SNR>7_escrtp[J('/Users/ygarrot/.vim/after')

line 1:   return escape(a:path, ' ,')[J

function <SNR>7_escrtp returning '/Users/ygarrot/.vim/after'[J

continuing in /Users/ygarrot/.vim/autoload/plug.vim[J

line 2518: [J

line 2519: if exists('g:plugs')[J

line 2520:   let g:plugs_order = get(g:, 'plugs_order', keys(g:plugs))[J

line 2521:   call s:upgrade_specs()[J

line 2522:   call s:define_commands()[J

line 2523: endif[J

line 2524: [J

line 2525: let &cpo = s:cpo_save[J

line 2526: unlet s:cpo_save[J

finished sourcing /Users/ygarrot/.vim/autoload/plug.vim[J
continuing in /Users/ygarrot/.vimrc[J
calling function plug#begin[J('~/.vim/plugged')

line 1:   if a:0 > 0[J

line 2:     let s:plug_home_org = a:1[J

line 3:     let home = s:path(fnamemodify(expand(a:1), ':p'))[J

calling function plug#begin[3]..<SNR>7_path[J('/Users/ygarrot/.vim/plugged/')

line 1:     return s:trim(a:path)[J

calling function plug#begin[3]..<SNR>7_path[1]..<SNR>7_trim[J('/Users/ygarrot/.vim/plugged/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#begin[3]..<SNR>7_path[1]..<SNR>7_trim returning '/Users/ygarrot/.vim/plugged'[J

continuing in function plug#begin[3]..<SNR>7_path[J

function plug#begin[3]..<SNR>7_path returning '/Users/ygarrot/.vim/plugged'[J

continuing in function plug#begin[J

line 4:   elseif exists('g:plug_home')[J

line 5:     let home = s:path(g:plug_home)[J

line 6:   elseif !empty(&rtp)[J

line 7:     let home = s:path(split(&rtp, ',')[0]) . '/plugged'[J

line 8:   else[J

line 9:     return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')[J

line 10:   endif[J

line 11:   if fnamemodify(home, ':t') ==# 'plugin' && fnamemodify(home, ':h') ==# s:first_rtp[J

line 12:     return s:err('Invalid plug home. '.home.' is a standard Vim runtime path and is not allowed.')[J

line 13:   endif[J

line 14: [J

line 15:   let g:plug_home = home[J

line 16:   let g:plugs = {}[J

line 17:   let g:plugs_order = [][J

line 18:   let s:triggers = {}[J

line 19: [J

line 20:   call s:define_commands()[J

calling function plug#begin[20]..<SNR>7_define_commands[J()

line 1:   command! -nargs=+ -bar Plug call plug#(<args>)[J

line 2:   if !executable('git')[J

line 3:     return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')[J

line 4:   endif[J

line 5:   command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])[J

line 6:   command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])[J

line 7:   command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)[J

line 8:   command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif[J

line 9:   command! -nargs=0 -bar PlugStatus  call s:status()[J

line 10:   command! -nargs=0 -bar PlugDiff    call s:diff()[J

line 11:   command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)[J

function plug#begin[20]..<SNR>7_define_commands returning #0[J

continuing in function plug#begin[J

line 21:   return 1[J

function plug#begin returning #1[J

continuing in /Users/ygarrot/.vimrc[J

line 7: " Plug 'ycm-core/YouCompleteMe'[J

line 8: Plug 'justinmk/vim-dirvish'[J

line 8: call plug#('justinmk/vim-dirvish')[J

calling function plug#[J('justinmk/vim-dirvish')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('justinmk/vim-dirvish')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'justinmk/vim-dirvish'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('vim-dirvish', 'justinmk/vim-dirvish')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('justinmk/vim-dirvish')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-dirvish')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-dirvish/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/jus...sers/ygarrot/.vim/plugged/vim-dirvish/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 9: Plug 'liuchengxu/space-vim-dark'[J

line 9: call plug#('liuchengxu/space-vim-dark')[J

calling function plug#[J('liuchengxu/space-vim-dark')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('liuchengxu/space-vim-dark')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'liuchengxu/space-vim-dark'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('space-vim-dark', 'liuchengxu/space-vim-dark')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('liuchengxu/space-vim-dark')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/space-vim-dark')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/space-vim-dark/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/liu...s/ygarrot/.vim/plugged/space-vim-dark/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 10: Plug 'tpope/vim-surround'[J

line 10: call plug#('tpope/vim-surround')[J

calling function plug#[J('tpope/vim-surround')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('tpope/vim-surround')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'tpope/vim-surround'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('vim-surround', 'tpope/vim-surround')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('tpope/vim-surround')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-surround')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-surround/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/tpo...ers/ygarrot/.vim/plugged/vim-surround/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 11: Plug 'junegunn/goyo.vim'[J

line 11: call plug#('junegunn/goyo.vim')[J

calling function plug#[J('junegunn/goyo.vim')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('junegunn/goyo.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'junegunn/goyo.vim'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('goyo.vim', 'junegunn/goyo.vim')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('junegunn/goyo.vim')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/goyo.vim')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/goyo.vim/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/jun...'/Users/ygarrot/.vim/plugged/goyo.vim/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 12: Plug 'PotatoesMaster/i3-vim-syntax'[J

line 12: call plug#('PotatoesMaster/i3-vim-syntax')[J

calling function plug#[J('PotatoesMaster/i3-vim-syntax')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('PotatoesMaster/i3-vim-syntax')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'PotatoesMaster/i3-vim-syntax'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('i3-vim-syntax', 'PotatoesMaster/i3-vim-syntax')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('PotatoesMaster/i3-vim-syntax')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/i3-vim-syntax')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/i3-vim-syntax/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/Pot...rs/ygarrot/.vim/plugged/i3-vim-syntax/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 13: Plug 'jreybert/vimagit'[J

line 13: call plug#('jreybert/vimagit')[J

calling function plug#[J('jreybert/vimagit')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('jreybert/vimagit')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'jreybert/vimagit'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('vimagit', 'jreybert/vimagit')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('jreybert/vimagit')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vimagit')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vimagit/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/jre... '/Users/ygarrot/.vim/plugged/vimagit/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 14: Plug 'vimwiki/vimwiki'[J

line 14: call plug#('vimwiki/vimwiki')[J

calling function plug#[J('vimwiki/vimwiki')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('vimwiki/vimwiki')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'vimwiki/vimwiki'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('vimwiki', 'vimwiki/vimwiki')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('vimwiki/vimwiki')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vimwiki')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vimwiki/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/vim... '/Users/ygarrot/.vim/plugged/vimwiki/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 15: Plug 'bling/vim-airline'[J

line 15: call plug#('bling/vim-airline')[J

calling function plug#[J('bling/vim-airline')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('bling/vim-airline')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'bling/vim-airline'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('vim-airline', 'bling/vim-airline')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('bling/vim-airline')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-airline')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-airline/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/bli...sers/ygarrot/.vim/plugged/vim-airline/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 16: Plug 'tpope/vim-commentary'[J

line 16: call plug#('tpope/vim-commentary')[J

calling function plug#[J('tpope/vim-commentary')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('tpope/vim-commentary')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'tpope/vim-commentary'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('vim-commentary', 'tpope/vim-commentary')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('tpope/vim-commentary')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-commentary')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-commentary/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/tpo...s/ygarrot/.vim/plugged/vim-commentary/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 17: Plug 'mhinz/vim-startify'[J

line 17: call plug#('mhinz/vim-startify')[J

calling function plug#[J('mhinz/vim-startify')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('mhinz/vim-startify')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'mhinz/vim-startify'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('vim-startify', 'mhinz/vim-startify')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('mhinz/vim-startify')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-startify')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-startify/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/mhi...ers/ygarrot/.vim/plugged/vim-startify/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 18: Plug 'machakann/vim-highlightedyank'[J

line 18: call plug#('machakann/vim-highlightedyank')[J

calling function plug#[J('machakann/vim-highlightedyank')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('machakann/vim-highlightedyank')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'machakann/vim-highlightedyank'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('vim-highlightedyank', 'machakann/vim-highlightedyank')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('machakann/vim-highlightedyank')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-highlightedyank')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-highlightedyank/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/mac...rrot/.vim/plugged/vim-highlightedyank/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 19: Plug 'vim-syntastic/syntastic'[J

line 19: call plug#('vim-syntastic/syntastic')[J

calling function plug#[J('vim-syntastic/syntastic')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('vim-syntastic/syntastic')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'vim-syntastic/syntastic'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('syntastic', 'vim-syntastic/syntastic')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('vim-syntastic/syntastic')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/syntastic')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/syntastic/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/vim.../Users/ygarrot/.vim/plugged/syntastic/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 20: Plug 'tpope/vim-fugitive'[J

line 20: call plug#('tpope/vim-fugitive')[J

calling function plug#[J('tpope/vim-fugitive')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('tpope/vim-fugitive')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'tpope/vim-fugitive'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('vim-fugitive', 'tpope/vim-fugitive')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('tpope/vim-fugitive')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-fugitive')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-fugitive/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/tpo...ers/ygarrot/.vim/plugged/vim-fugitive/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 21: Plug 'MarcWeber/vim-addon-mw-utils'[J

line 21: call plug#('MarcWeber/vim-addon-mw-utils')[J

calling function plug#[J('MarcWeber/vim-addon-mw-utils')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('MarcWeber/vim-addon-mw-utils')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'MarcWeber/vim-addon-mw-utils'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('vim-addon-mw-utils', 'MarcWeber/vim-addon-mw-utils')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('MarcWeber/vim-addon-mw-utils')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-addon-mw-utils')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/Mar...arrot/.vim/plugged/vim-addon-mw-utils/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 22: Plug 'tomtom/tlib_vim'[J

line 22: call plug#('tomtom/tlib_vim')[J

calling function plug#[J('tomtom/tlib_vim')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('tomtom/tlib_vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'tomtom/tlib_vim'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('tlib_vim', 'tomtom/tlib_vim')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('tomtom/tlib_vim')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/tlib_vim')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/tlib_vim/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/tom...'/Users/ygarrot/.vim/plugged/tlib_vim/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 23: Plug 'garbas/vim-snipmate'[J

line 23: call plug#('garbas/vim-snipmate')[J

calling function plug#[J('garbas/vim-snipmate')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('garbas/vim-snipmate')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'garbas/vim-snipmate'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('vim-snipmate', 'garbas/vim-snipmate')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('garbas/vim-snipmate')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-snipmate')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-snipmate/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/gar...ers/ygarrot/.vim/plugged/vim-snipmate/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 24: Plug 'honza/vim-snippets'[J

line 24: call plug#('honza/vim-snippets')[J

calling function plug#[J('honza/vim-snippets')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('honza/vim-snippets')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'honza/vim-snippets'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('vim-snippets', 'honza/vim-snippets')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('honza/vim-snippets')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-snippets')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-snippets/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/hon...ers/ygarrot/.vim/plugged/vim-snippets/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 25: Plug 'morhetz/gruvbox'[J

line 25: call plug#('morhetz/gruvbox')[J

calling function plug#[J('morhetz/gruvbox')

line 1:   if a:0 > 1[J

line 2:     return s:err('Invalid number of arguments (1..2)')[J

line 3:   endif[J

line 4: [J

line 5:   try[J

line 6:     let repo = s:trim(a:repo)[J

calling function plug#[6]..<SNR>7_trim[J('morhetz/gruvbox')

line 1:   return substitute(a:str, '[\/]\+$', '', '')[J

function plug#[6]..<SNR>7_trim returning 'morhetz/gruvbox'[J

continuing in function plug#[J

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec[J

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))[J

line 9:     let spec = extend(s:infer_properties(name, repo), opts)[J

calling function plug#[9]..<SNR>7_infer_properties[J('gruvbox', 'morhetz/gruvbox')

line 1:   let repo = a:repo[J

line 2:   if s:is_local_plug(repo)[J

calling function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug[J('morhetz/gruvbox')

line 1:     return a:repo[0] =~ '[/$~]'[J

function plug#[9]..<SNR>7_infer_properties[2]..<SNR>7_is_local_plug returning #0[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

line 3:     return { 'dir': s:dirpath(expand(repo)) }[J

line 4:   else[J

line 5:     if repo =~ ':'[J

line 6:       let uri = repo[J

line 7:     else[J

line 8:       if repo !~ '/'[J

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)[J

line 10:       endif[J

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')[J

line 12:       let uri = printf(fmt, repo)[J

line 13:     endif[J

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }[J

calling function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/gruvbox')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#[9]..<SNR>7_infer_properties[14]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/gruvbox/'[J

continuing in function plug#[9]..<SNR>7_infer_properties[J

function plug#[9]..<SNR>7_infer_properties returning {'uri': 'https://git::@github.com/mor... '/Users/ygarrot/.vim/plugged/gruvbox/'}[J

continuing in function plug#[J

line 10:     if !has_key(g:plugs, name)[J

line 11:       call add(g:plugs_order, name)[J

line 12:     endif[J

line 13:     let g:plugs[name] = spec[J

line 14:     let s:loaded[name] = get(s:loaded, name, 0)[J

line 15:   catch[J

line 16:     return s:err(v:exception)[J

line 17:   endtry[J

function plug# returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 26: [J

line 27: call plug#end()[J

calling function plug#end[J()

line 1:   if !exists('g:plugs')[J

line 2:     return s:err('Call plug#begin() first')[J

line 3:   endif[J

line 4: [J

line 5:   if exists('#PlugLOD')[J

line 6:     augroup PlugLOD[J

line 7:       autocmd![J

line 8:     augroup END[J

line 9:     augroup! PlugLOD[J

line 10:   endif[J

line 11:   let lod = { 'ft': {}, 'map': {}, 'cmd': {} }[J

line 12: [J

line 13:   if exists('g:did_load_filetypes')[J

line 14:     filetype off[J

Searching for "ftoff.vim" in "/Users/ygarrot/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/ftoff.vim"[J
Searching for "/usr/share/vim/vimfiles/ftoff.vim"[J
Searching for "/usr/share/vim/vim74/ftoff.vim"[J
chdir(/usr/share/vim/vim74)[J
fchdir() to previous dir[J
line 14: sourcing "/usr/share/vim/vim74/ftoff.vim"[J
line 1: " Vim support file to switch off detection of file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2001 Jun 11[J

line 5: [J

line 6: if exists("did_load_filetypes")[J

line 7:   unlet did_load_filetypes[J

line 8: endif[J

line 9: [J

line 10: " Remove all autocommands in the filetypedetect group[J

line 11: silent! au! filetypedetect *[J

finished sourcing /usr/share/vim/vim74/ftoff.vim[J
continuing in function plug#end[J
Searching for "/usr/share/vim/vimfiles/after/ftoff.vim"[J
Searching for "/Users/ygarrot/.vim/after/ftoff.vim"[J
line 15:   endif[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/jus...vish/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/jus...vish/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/liu...dark/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/liu...dark/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/tpo...ound/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/tpo...ound/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/jun....vim/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/jun....vim/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/Pot...ntax/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/Pot...ntax/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/jre...agit/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/jre...agit/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/vim...wiki/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/vim...wiki/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/bli...line/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/bli...line/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/tpo...tary/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/tpo...tary/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/mhi...tify/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/mhi...tify/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/mac...yank/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/mac...yank/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/vim...stic/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/vim...stic/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/tpo...tive/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/tpo...tive/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/Mar...tils/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/Mar...tils/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/tom..._vim/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/tom..._vim/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/gar...mate/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/gar...mate/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/hon...pets/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/hon...pets/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/mor...vbox/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

calling function plug#end[21]..<SNR>7_lazy[J({'uri': 'https://git::@github.com/mor...vbox/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))[J

function plug#end[21]..<SNR>7_lazy returning #0[J

continuing in function plug#end[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 16:   for name in g:plugs_order[J

line 17:     if !has_key(g:plugs, name)[J

line 18:       continue[J

line 19:     endif[J

line 20:     let plug = g:plugs[name][J

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')[J

line 22:       let s:loaded[name] = 1[J

line 23:       continue[J

line 24:     endif[J

line 25: [J

line 26:     if has_key(plug, 'on')[J

line 27:       let s:triggers[name] = { 'map': [], 'cmd': [] }[J

line 28:       for cmd in s:to_a(plug.on)[J

line 29:         if cmd =~? '^<Plug>.\+'[J

line 30:           if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))[J

line 31:             call s:assoc(lod.map, cmd, name)[J

line 32:           endif[J

line 33:           call add(s:triggers[name].map, cmd)[J

line 34:         elseif cmd =~# '^[A-Z]'[J

line 35:           let cmd = substitute(cmd, '!*$', '', '')[J

line 36:           if exists(':'.cmd) != 2[J

line 37:             call s:assoc(lod.cmd, cmd, name)[J

line 38:           endif[J

line 39:           call add(s:triggers[name].cmd, cmd)[J

line 40:         else[J

line 41:           call s:err('Invalid `on` option: '.cmd. '. Should start with an uppercase letter or `<Plug>`.')[J

line 43:         endif[J

line 44:       endfor[J

line 45:     endif[J

line 46: [J

line 47:     if has_key(plug, 'for')[J

line 48:       let types = s:to_a(plug.for)[J

line 49:       if !empty(types)[J

line 50:         augroup filetypedetect[J

line 51:         call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')[J

line 52:         augroup END[J

line 53:       endif[J

line 54:       for type in types[J

line 55:         call s:assoc(lod.ft, type, name)[J

line 56:       endfor[J

line 57:     endif[J

line 58:   endfor[J

line 59: [J

line 60:   for [cmd, names] in items(lod.cmd)[J

line 61:     execute printf( 'command! -nargs=* -range -bang -complete=file %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)', cmd, string(cmd), string(names))[J

line 64:   endfor[J

line 65: [J

line 66:   for [map, names] in items(lod.map)[J

line 67:     for [mode, map_prefix, key_prefix] in [['i', '<C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']][J

line 69:       execute printf( '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, %s, "%s")<CR>', mode, map, map_prefix, string(map), string(names), mode != 'i', key_prefix)[J

line 72:     endfor[J

line 73:   endfor[J

line 74: [J

line 75:   for [ft, names] in items(lod.ft)[J

line 76:     augroup PlugLOD[J

line 77:       execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)', ft, string(ft), string(names))[J

line 79:     augroup END[J

line 80:   endfor[J

line 81: [J

line 82:   call s:reorg_rtp()[J

calling function plug#end[82]..<SNR>7_reorg_rtp[J()

line 1:   if !empty(s:first_rtp)[J

line 2:     execute 'set rtp-='.s:first_rtp[J

line 2: set rtp-=/Users/ygarrot/.vim[J

line 3:     execute 'set rtp-='.s:last_rtp[J

line 3: set rtp-=/Users/ygarrot/.vim/after[J

line 4:   endif[J

line 5: [J

line 6:   " &rtp is modified from outside[J

line 7:   if exists('s:prtp') && s:prtp !=# &rtp[J

line 8:     call s:remove_rtp()[J

line 9:     unlet! s:middle[J

line 10:   endif[J

line 11: [J

line 12:   let s:middle = get(s:, 'middle', &rtp)[J

line 13:   let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_loaded_names[J()

line 1:   return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_loaded_names returning ['vim-dirvish', 'space-vim-dark', 'vi...im-snipmate', 'vim-snippets', 'gruvbox'][J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/jus...vish/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-dirvish/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-dirvish/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/vim-dirvish/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/liu...dark/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/space-vim-dark/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/space-vim-dark/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/space-vim-dark/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/tpo...ound/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-surround/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-surround/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/vim-surround/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/jun....vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/goyo.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/goyo.vim/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/goyo.vim/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/Pot...ntax/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/i3-vim-syntax/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/i3-vim-syntax/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/i3-vim-syntax/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/jre...agit/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vimagit/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vimagit/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/vimagit/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/vim...wiki/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vimwiki/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vimwiki/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/vimwiki/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/bli...line/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-airline/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-airline/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/vim-airline/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/tpo...tary/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-commentary/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-commentary/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/vim-commentary/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/mhi...tify/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-startify/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-startify/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/vim-startify/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/mac...yank/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-highlightedyank/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-highlightedyank/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/vim-highlightedyank/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/vim...stic/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/syntastic/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/syntastic/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/syntastic/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/tpo...tive/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-fugitive/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-fugitive/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/vim-fugitive/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/Mar...tils/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/tom..._vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/tlib_vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/tlib_vim/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/tlib_vim/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/gar...mate/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-snipmate/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-snipmate/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/vim-snipmate/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/hon...pets/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/vim-snippets/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/vim-snippets/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/vim-snippets/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J({'uri': 'https://git::@github.com/mor...vbox/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))[J

calling function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath[J('/Users/ygarrot/.vim/plugged/gruvbox/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[1]..<SNR>7_dirpath returning '/Users/ygarrot/.vim/plugged/gruvbox/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp[J

function plug#end[82]..<SNR>7_reorg_rtp[13]..<SNR>7_rtp returning '/Users/ygarrot/.vim/plugged/gruvbox/'[J

continuing in function plug#end[82]..<SNR>7_reorg_rtp[J

line 14:   let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')[J

line 15:   let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',') . ','.s:middle.',' . join(map(afters, 'escape(v:val, ",")'), ',')[J

line 18:   let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')[J

line 19:   let s:prtp   = &rtp[J

line 20: [J

line 21:   if !empty(s:first_rtp)[J

line 22:     execute 'set rtp^='.s:first_rtp[J

line 22: set rtp^=/Users/ygarrot/.vim[J

line 23:     execute 'set rtp+='.s:last_rtp[J

line 23: set rtp+=/Users/ygarrot/.vim/after[J

line 24:   endif[J

function plug#end[82]..<SNR>7_reorg_rtp returning #0[J

continuing in function plug#end[J

line 83:   filetype plugin indent on[J

Searching for "filetype.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/filetype.vim"[J
Searching for "/usr/share/vim/vimfiles/filetype.vim"[J
Searching for "/usr/share/vim/vim74/filetype.vim"[J
chdir(/usr/share/vim/vim74)[J
fchdir() to previous dir[J
line 83: sourcing "/usr/share/vim/vim74/filetype.vim"[J
line 1: " Vim support file to detect file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2015 Oct 13[J

line 5: [J

line 6: " Listen very carefully, I will say this only once[J

line 7: if exists("did_load_filetypes")[J

line 8:   finish[J

line 9: endif[J

line 10: let did_load_filetypes = 1[J

line 11: [J

line 12: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 13: let s:cpo_save = &cpo[J

line 14: set cpo&vim[J

line 15: [J

line 16: augroup filetypedetect[J

line 17: [J

line 18: " Ignored extensions[J

line 19: if exists("*fnameescape")[J

line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))[J

line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short[J

line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif[J

line 33: elseif &verbose > 0[J

line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"[J

line 35: endif[J

line 36: [J

line 37: " Pattern used to match file names which should not be inspected.[J

line 38: " Currently finds compressed files.[J

line 39: if !exists("g:ft_ignore_pat")[J

line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'[J

line 41: endif[J

line 42: [J

line 43: " Function used for patterns that end in a star: don't set the filetype if the[J

line 44: " file name matches ft_ignore_pat.[J

line 45: func! s:StarSetf(ft)[J

line 50: [J

line 51: " Abaqus or Trasys[J

line 52: au BufNewFile,BufRead *.inp^I^I^Icall s:Check_inp()[J

line 53: [J

line 54: func! s:Check_inp()[J

line 73: [J

line 74: " A-A-P recipe[J

line 75: au BufNewFile,BufRead *.aap^I^I^Isetf aap[J

line 76: [J

line 77: " A2ps printing utility[J

line 78: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps[J

line 79: [J

line 80: " ABAB/4[J

line 81: au BufNewFile,BufRead *.abap^I^I^Isetf abap[J

line 82: [J

line 83: " ABC music notation[J

line 84: au BufNewFile,BufRead *.abc^I^I^Isetf abc[J

line 85: [J

line 86: " ABEL[J

line 87: au BufNewFile,BufRead *.abl^I^I^Isetf abel[J

line 88: [J

line 89: " AceDB[J

line 90: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb[J

line 91: [J

line 92: " Ada (83, 9X, 95)[J

line 93: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada[J

line 94: if has("vms")[J

line 95:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada[J

line 96: else[J

line 97:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada[J

line 98: endif[J

line 99: [J

line 100: " AHDL[J

line 101: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl[J

line 102: [J

line 103: " AMPL[J

line 104: au BufNewFile,BufRead *.run^I^I^Isetf ampl[J

line 105: [J

line 106: " Ant[J

line 107: au BufNewFile,BufRead build.xml^I^I^Isetf ant[J

line 108: [J

line 109: " Arduino[J

line 110: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino[J

line 111: [J

line 112: " Apache style config file[J

line 113: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')[J

line 114: [J

line 115: " Apache config file[J

line 116: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache[J

line 117: [J

line 118: " XA65 MOS6510 cross assembler[J

line 119: au BufNewFile,BufRead *.a65^I^I^Isetf a65[J

line 120: [J

line 121: " Applescript[J

line 122: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript[J

line 123: [J

line 124: " Applix ELF[J

line 126: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif[J

line 127: [J

line 128: " ALSA configuration[J

line 129: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf[J

line 130: [J

line 131: " Arc Macro Language[J

line 132: au BufNewFile,BufRead *.aml^I^I^Isetf aml[J

line 133: [J

line 134: " APT config file[J

line 135: au BufNewFile,BufRead apt.conf^I^I       setf aptconf[J

line 136: au BufNewFile,BufRead */.aptitude/config       setf aptconf[J

line 137: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf[J

line 138: [J

line 139: " Arch Inventory file[J

line 140: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch[J

line 141: [J

line 142: " ART*Enterprise (formerly ART-IM)[J

line 143: au BufNewFile,BufRead *.art^I^I^Isetf art[J

line 144: [J

line 145: " AsciiDoc[J

line 146: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc[J

line 147: [J

line 148: " ASN.1[J

line 149: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn[J

line 150: [J

line 151: " Active Server Pages (with Visual Basic Script)[J

line 157: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif[J

line 158: [J

line 159: " Active Server Pages (with Perl or Visual Basic Script)[J

line 167: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif[J

line 168: [J

line 169: " Grub (must be before catch *.lst)[J

line 170: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub[J

line 171: [J

line 172: " Assembly (all kinds)[J

line 173: " *.lst is not pure assembly, it has two extra columns (address, byte codes)[J

line 174: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall s:FTasm()[J

line 175: [J

line 176: " This function checks for the kind of assembly that is wanted by the user, or[J

line 177: " can be detected from the first five lines of the file.[J

line 178: func! s:FTasm()[J

line 199: [J

line 200: func! s:FTasmsyntax()[J

line 212: [J

line 213: " Macro (VAX)[J

line 214: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm[J

line 215: [J

line 216: " Atlas[J

line 217: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas[J

line 218: [J

line 219: " Autoit v3[J

line 220: au BufNewFile,BufRead *.au3^I^I^Isetf autoit[J

line 221: [J

line 222: " Autohotkey[J

line 223: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey[J

line 224: [J

line 225: " Automake[J

line 226: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake[J

line 227: [J

line 228: " Autotest .at files are actually m4[J

line 229: au BufNewFile,BufRead *.at^I^I^Isetf m4[J

line 230: [J

line 231: " Avenue[J

line 232: au BufNewFile,BufRead *.ave^I^I^Isetf ave[J

line 233: [J

line 234: " Awk[J

line 235: au BufNewFile,BufRead *.awk^I^I^Isetf awk[J

line 236: [J

line 237: " B[J

line 238: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b[J

line 239: [J

line 240: " BASIC or Visual Basic[J

line 241: au BufNewFile,BufRead *.bas^I^I^Icall s:FTVB("basic")[J

line 242: [J

line 243: " Check if one of the first five lines contains "VB_Name".  In that case it is[J

line 244: " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.[J

line 245: func! s:FTVB(alt)[J

line 252: [J

line 253: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET[J

line 254: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb[J

line 255: [J

line 256: " IBasic file (similar to QBasic)[J

line 257: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic[J

line 258: [J

line 259: " FreeBasic file (similar to QBasic)[J

line 260: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic[J

line 261: [J

line 262: " Batch file for MSDOS.[J

line 263: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch[J

line 264: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.[J

line 266: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif[J

line 267: [J

line 268: " Batch file for 4DOS[J

line 269: au BufNewFile,BufRead *.btm^I^I^Icall s:FTbtm()[J

line 270: func! s:FTbtm()[J

line 277: [J

line 278: " BC calculator[J

line 279: au BufNewFile,BufRead *.bc^I^I^Isetf bc[J

line 280: [J

line 281: " BDF font[J

line 282: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf[J

line 283: [J

line 284: " BibTeX bibliography database file[J

line 285: au BufNewFile,BufRead *.bib^I^I^Isetf bib[J

line 286: [J

line 287: " BibTeX Bibliography Style[J

line 288: au BufNewFile,BufRead *.bst^I^I^Isetf bst[J

line 289: [J

line 290: " BIND configuration[J

line 291: au BufNewFile,BufRead named.conf,rndc.conf^Isetf named[J

line 292: [J

line 293: " BIND zone[J

line 294: au BufNewFile,BufRead named.root^I^Isetf bindzone[J

line 295: au BufNewFile,BufRead *.db^I^I^Icall s:BindzoneCheck('')[J

line 296: [J

line 297: func! s:BindzoneCheck(default)[J

line 304: [J

line 305: " Blank[J

line 306: au BufNewFile,BufRead *.bl^I^I^Isetf blank[J

line 307: [J

line 308: " Blkid cache file[J

line 309: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml[J

line 310: [J

line 311: " Bazel (http://bazel.io)[J

line 312: autocmd BufRead,BufNewFile *.bzl,BUILD,WORKSPACE setfiletype bzl[J

line 313: [J

line 314: " C or lpc[J

line 315: au BufNewFile,BufRead *.c^I^I^Icall s:FTlpc()[J

line 316: [J

line 317: func! s:FTlpc()[J

line 330: [J

line 331: " Calendar[J

line 332: au BufNewFile,BufRead calendar^I^I^Isetf calendar[J

line 333: [J

line 334: " C#[J

line 335: au BufNewFile,BufRead *.cs^I^I^Isetf cs[J

line 336: [J

line 337: " CSDL[J

line 338: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl[J

line 339: [J

line 340: " Cabal[J

line 341: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal[J

line 342: [J

line 343: " Cdrdao TOC[J

line 344: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc[J

line 345: [J

line 346: " Cdrdao config[J

line 347: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf[J

line 348: [J

line 349: " Cfengine[J

line 350: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine[J

line 351: [J

line 352: " ChaiScript[J

line 353: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript[J

line 354: [J

line 355: " Comshare Dimension Definition Language[J

line 356: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl[J

line 357: [J

line 358: " Conary Recipe[J

line 359: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe[J

line 360: [J

line 361: " Controllable Regex Mutilator[J

line 362: au BufNewFile,BufRead *.crm^I^I^Isetf crm[J

line 363: [J

line 364: " Cyn++[J

line 365: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp[J

line 366: [J

line 367: " Cynlib[J

line 368: " .cc and .cpp files can be C++ or Cynlib.[J

line 370: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif[J

line 372: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif[J

line 373: [J

line 374: " C++[J

line 375: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp[J

line 376: if has("fname_case")[J

line 377:   au BufNewFile,BufRead *.C,*.H setf cpp[J

line 378: endif[J

line 379: [J

line 380: " .h files can be C, Ch C++, ObjC or ObjC++.[J

line 381: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is[J

line 382: " detected automatically.[J

line 383: au BufNewFile,BufRead *.h^I^I^Icall s:FTheader()[J

line 384: [J

line 385: func! s:FTheader()[J

line 400: [J

line 401: " Ch (CHscript)[J

line 402: au BufNewFile,BufRead *.chf^I^I^Isetf ch[J

line 403: [J

line 404: " TLH files are C++ headers generated by Visual C++'s #import from typelibs[J

line 405: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp[J

line 406: [J

line 407: " Cascading Style Sheets[J

line 408: au BufNewFile,BufRead *.css^I^I^Isetf css[J

line 409: [J

line 410: " Century Term Command Scripts (*.cmd too)[J

line 411: au BufNewFile,BufRead *.con^I^I^Isetf cterm[J

line 412: [J

line 413: " Changelog[J

line 415: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog[J

line 416: [J

line 422: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif[J

line 423: [J

line 427: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif[J

line 428: [J

line 429: " CHILL[J

line 430: au BufNewFile,BufRead *..ch^I^I^Isetf chill[J

line 431: [J

line 432: " Changes for WEB and CWEB or CHILL[J

line 433: au BufNewFile,BufRead *.ch^I^I^Icall s:FTchange()[J

line 434: [J

line 435: " This function checks if one of the first ten lines start with a '@'.  In[J

line 436: " that case it is probably a change file.[J

line 437: " If the first line starts with # or ! it's probably a ch file.[J

line 438: " If a line has "main", "include", "//" ir "/*" it's probably ch.[J

line 439: " Otherwise CHILL is assumed.[J

line 440: func! s:FTchange()[J

line 463: [J

line 464: " ChordPro[J

line 465: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro[J

line 466: [J

line 467: " Clean[J

line 468: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean[J

line 469: [J

line 470: " Clever[J

line 471: au BufNewFile,BufRead *.eni^I^I^Isetf cl[J

line 472: [J

line 473: " Clever or dtd[J

line 474: au BufNewFile,BufRead *.ent^I^I^Icall s:FTent()[J

line 475: [J

line 476: func! s:FTent()[J

line 495: [J

line 496: " Clipper (or FoxPro; could also be eviews)[J

line 502: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif[J

line 503: [J

line 504: " Clojure[J

line 505: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure[J

line 506: [J

line 507: " Cmake[J

line 508: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake[J

line 509: [J

line 510: " Cmusrc[J

line 511: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc[J

line 512: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc[J

line 513: [J

line 514: " Cobol[J

line 515: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol[J

line 516: "   cobol or zope form controller python script? (heuristic)[J

line 522: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif[J

line 523: [J

line 524: " Coco/R[J

line 525: au BufNewFile,BufRead *.atg^I^I^Isetf coco[J

line 526: [J

line 527: " Cold Fusion[J

line 528: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf[J

line 529: [J

line 530: " Configure scripts[J

line 531: au BufNewFile,BufRead configure.in,configure.ac setf config[J

line 532: [J

line 533: " CUDA  Cumpute Unified Device Architecture[J

line 534: au BufNewFile,BufRead *.cu^I^I^Isetf cuda[J

line 535: [J

line 536: " Dockerfile[J

line 537: au BufNewFile,BufRead Dockerfile^I^Isetf dockerfile[J

line 538: [J

line 539: " WildPackets EtherPeek Decoder[J

line 540: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd[J

line 541: [J

line 542: " Enlightenment configuration files[J

line 543: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c[J

line 544: [J

line 545: " Eterm[J

line 546: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm[J

line 547: [J

line 548: " Euphoria 3 or 4[J

line 549: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()[J

line 550: if has("fname_case")[J

line 551:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()[J

line 552: endif[J

line 553: [J

line 554: func! s:EuphoriaCheck()[J

line 561: [J

line 562: " Lynx config files[J

line 563: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx[J

line 564: [J

line 565: " Quake[J

line 566: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake[J

line 567: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake[J

line 568: [J

line 569: " Quake C[J

line 570: au BufNewFile,BufRead *.qc^I^I^Isetf c[J

line 571: [J

line 572: " Configure files[J

line 573: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg[J

line 574: [J

line 575: " Cucumber[J

line 576: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber[J

line 577: [J

line 578: " Communicating Sequential Processes[J

line 579: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp[J

line 580: [J

line 581: " CUPL logic description and simulation[J

line 582: au BufNewFile,BufRead *.pld^I^I^Isetf cupl[J

line 583: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim[J

line 584: [J

line 585: " Debian Control[J

line 586: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol[J

line 590: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif[J

line 591: [J

line 592: " Debian Sources.list[J

line 593: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources[J

line 594: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources[J

line 595: [J

line 596: " Deny hosts[J

line 597: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts[J

line 598: [J

line 599: " dnsmasq(8) configuration files[J

line 600: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq[J

line 601: [J

line 602: " ROCKLinux package description[J

line 603: au BufNewFile,BufRead *.desc^I^I^Isetf desc[J

line 604: [J

line 605: " the D language or dtrace[J

line 606: au BufNewFile,BufRead *.d^I^I^Icall s:DtraceCheck()[J

line 607: [J

line 608: func! s:DtraceCheck()[J

line 619: [J

line 620: " Desktop files[J

line 621: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop[J

line 622: [J

line 623: " Dict config[J

line 624: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf[J

line 625: [J

line 626: " Dictd config[J

line 627: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf[J

line 628: [J

line 629: " Diff files[J

line 630: au BufNewFile,BufRead *.diff,*.rej,*.patch^Isetf diff[J

line 631: [J

line 632: " Dircolors[J

line 633: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors[J

line 634: [J

line 635: " Diva (with Skill) or InstallShield[J

line 641: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif[J

line 642: [J

line 643: " DCL (Digital Command Language - vms) or DNS zone file[J

line 644: au BufNewFile,BufRead *.com^I^I^Icall s:BindzoneCheck('dcl')[J

line 645: [J

line 646: " DOT[J

line 647: au BufNewFile,BufRead *.dot^I^I^Isetf dot[J

line 648: [J

line 649: " Dylan - lid files[J

line 650: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid[J

line 651: [J

line 652: " Dylan - intr files (melange)[J

line 653: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr[J

line 654: [J

line 655: " Dylan[J

line 656: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan[J

line 657: [J

line 658: " Microsoft Module Definition[J

line 659: au BufNewFile,BufRead *.def^I^I^Isetf def[J

line 660: [J

line 661: " Dracula[J

line 662: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula[J

line 663: [J

line 664: " Datascript[J

line 665: au BufNewFile,BufRead *.ds^I^I^Isetf datascript[J

line 666: [J

line 667: " dsl[J

line 668: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl[J

line 669: [J

line 670: " DTD (Document Type Definition for XML)[J

line 671: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd[J

line 672: [J

line 673: " DTS/DSTI (device tree files)[J

line 674: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts[J

line 675: [J

line 676: " EDIF (*.edf,*.edif,*.edn,*.edo)[J

line 677: au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)^Isetf edif[J

line 678: [J

line 679: " Embedix Component Description[J

line 680: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd[J

line 681: [J

line 682: " Eiffel or Specman or Euphoria[J

line 683: au BufNewFile,BufRead *.e,*.E^I^I^Icall s:FTe()[J

line 684: [J

line 685: " Elinks configuration[J

line 686: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks[J

line 687: [J

line 688: func! s:FTe()[J

line 703: [J

line 704: " ERicsson LANGuage; Yaws is erlang too[J

line 705: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang[J

line 706: [J

line 707: " Elm Filter Rules file[J

line 708: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt[J

line 709: [J

line 710: " ESMTP rc file[J

line 711: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc[J

line 712: [J

line 713: " ESQL-C[J

line 714: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc[J

line 715: [J

line 716: " Esterel[J

line 717: au BufNewFile,BufRead *.strl^I^I^Isetf esterel[J

line 718: [J

line 719: " Essbase script[J

line 720: au BufNewFile,BufRead *.csc^I^I^Isetf csc[J

line 721: [J

line 722: " Exim[J

line 723: au BufNewFile,BufRead exim.conf^I^I^Isetf exim[J

line 724: [J

line 725: " Expect[J

line 726: au BufNewFile,BufRead *.exp^I^I^Isetf expect[J

line 727: [J

line 728: " Exports[J

line 729: au BufNewFile,BufRead exports^I^I^Isetf exports[J

line 730: [J

line 731: " Falcon[J

line 732: au BufNewFile,BufRead *.fal^I^I^Isetf falcon[J

line 733: [J

line 734: " Fantom[J

line 735: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan[J

line 736: [J

line 737: " Factor[J

line 738: au BufNewFile,BufRead *.factor^I^I^Isetf factor[J

line 739: [J

line 740: " Fetchmail RC file[J

line 741: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail[J

line 742: [J

line 743: " FlexWiki - disabled, because it has side effects when a .wiki file[J

line 744: " is not actually FlexWiki[J

line 745: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki[J

line 746: [J

line 747: " Focus Executable[J

line 748: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec[J

line 749: [J

line 750: " Focus Master file (but not for auto.master)[J

line 751: au BufNewFile,BufRead auto.master^I^Isetf conf[J

line 752: au BufNewFile,BufRead *.mas,*.master^I^Isetf master[J

line 753: [J

line 754: " Forth[J

line 755: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth[J

line 756: [J

line 757: " Reva Forth[J

line 758: au BufNewFile,BufRead *.frt^I^I^Isetf reva[J

line 759: [J

line 760: " Fortran[J

line 761: if has("fname_case")[J

line 762:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran[J

line 763: endif[J

line 764: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran[J

line 765: [J

line 766: " Framescript[J

line 767: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript[J

line 768: [J

line 769: " FStab[J

line 770: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab[J

line 771: [J

line 772: " GDB command files[J

line 773: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb[J

line 774: [J

line 775: " GDMO[J

line 776: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo[J

line 777: [J

line 778: " Gedcom[J

line 779: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom[J

line 780: [J

line 781: " Git[J

line 782: au BufNewFile,BufRead COMMIT_EDITMSG^I^Isetf gitcommit[J

line 783: au BufNewFile,BufRead MERGE_MSG^I^I^Isetf gitcommit[J

line 784: au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig[J

line 785: au BufNewFile,BufRead *.git/modules/*/config^Isetf gitconfig[J

line 786: au BufNewFile,BufRead */.config/git/config^Isetf gitconfig[J

line 787: if !empty($XDG_CONFIG_HOME)[J

line 788:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^Isetf gitconfig[J

line 789: endif[J

line 790: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase[J

line 794: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif[J

line 798: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif[J

line 799: [J

line 800: " Gkrellmrc[J

line 801: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc[J

line 802: [J

line 803: " GP scripts (2.0 and onward)[J

line 804: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp[J

line 805: [J

line 806: " GPG[J

line 807: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg[J

line 808: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg[J

line 809: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg[J

line 810: [J

line 811: " gnash(1) configuration files[J

line 812: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash[J

line 813: [J

line 814: " Gitolite[J

line 815: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite[J

line 816: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')[J

line 817: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl[J

line 818: [J

line 819: " Gnuplot scripts[J

line 820: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot[J

line 821: [J

line 822: " Go (Google)[J

line 823: au BufNewFile,BufRead *.go^I^I^Isetf go[J

line 824: [J

line 825: " GrADS scripts[J

line 826: au BufNewFile,BufRead *.gs^I^I^Isetf grads[J

line 827: [J

line 828: " Gretl[J

line 829: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl[J

line 830: [J

line 831: " Groovy[J

line 832: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy[J

line 833: [J

line 834: " GNU Server Pages[J

line 835: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp[J

line 836: [J

line 837: " Group file[J

line 838: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group[J

line 839: [J

line 840: " GTK RC[J

line 841: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc[J

line 842: [J

line 843: " Haml[J

line 844: au BufNewFile,BufRead *.haml^I^I^Isetf haml[J

line 845: [J

line 846: " Hamster Classic | Playground files[J

line 847: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster[J

line 848: [J

line 849: " Haskell[J

line 850: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell[J

line 851: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell[J

line 852: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell[J

line 853: [J

line 854: " Haste[J

line 855: au BufNewFile,BufRead *.ht^I^I^Isetf haste[J

line 856: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc[J

line 857: [J

line 858: " Hercules[J

line 859: au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum^Isetf hercules[J

line 860: [J

line 861: " HEX (Intel)[J

line 862: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex[J

line 863: [J

line 864: " Tilde (must be before HTML)[J

line 865: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde[J

line 866: [J

line 867: " HTML (.shtml and .stm for server side)[J

line 868: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()[J

line 869: [J

line 870: " Distinguish between HTML, XHTML and Django[J

line 871: func! s:FThtml()[J

line 886: [J

line 887: " HTML with Ruby - eRuby[J

line 888: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby[J

line 889: [J

line 890: " HTML with M4[J

line 891: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4[J

line 892: [J

line 893: " HTML Cheetah template[J

line 894: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah[J

line 895: [J

line 896: " Host config[J

line 897: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf[J

line 898: [J

line 899: " Hosts access[J

line 900: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess[J

line 901: [J

line 902: " Hyper Builder[J

line 903: au BufNewFile,BufRead *.hb^I^I^Isetf hb[J

line 904: [J

line 905: " Httest[J

line 906: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest[J

line 907: [J

line 908: " Icon[J

line 909: au BufNewFile,BufRead *.icn^I^I^Isetf icon[J

line 910: [J

line 911: " IDL (Interface Description Language)[J

line 912: au BufNewFile,BufRead *.idl^I^I^Icall s:FTidl()[J

line 913: [J

line 914: " Distinguish between standard IDL and MS-IDL[J

line 915: func! s:FTidl()[J

line 926: [J

line 927: " Microsoft IDL (Interface Description Language)  Also *.idl[J

line 928: " MOF = WMI (Windows Management Instrumentation) Managed Object Format[J

line 929: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl[J

line 930: [J

line 931: " Icewm menu[J

line 932: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu[J

line 933: [J

line 934: " Indent profile (must come before IDL *.pro!)[J

line 935: au BufNewFile,BufRead .indent.pro^I^Isetf indent[J

line 936: au BufNewFile,BufRead indent.pro^I^Icall s:ProtoCheck('indent')[J

line 937: [J

line 938: " IDL (Interactive Data Language)[J

line 939: au BufNewFile,BufRead *.pro^I^I^Icall s:ProtoCheck('idlang')[J

line 940: [J

line 941: " Distinguish between "default" and Cproto prototype file. */[J

line 942: func! s:ProtoCheck(default)[J

line 954: [J

line 955: [J

line 956: " Indent RC[J

line 957: au BufNewFile,BufRead indentrc^I^I^Isetf indent[J

line 958: [J

line 959: " Inform[J

line 960: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform[J

line 961: [J

line 962: " Initng[J

line 963: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng[J

line 964: [J

line 965: " Innovation Data Processing[J

line 966: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat[J

line 967: au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c ^Isetf upstreamlog[J

line 968: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog[J

line 969: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog[J

line 970: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog[J

line 971: [J

line 972: " Ipfilter[J

line 973: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter[J

line 974: [J

line 975: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)[J

line 976: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl[J

line 977: [J

line 978: " .INI file for MSDOS[J

line 979: au BufNewFile,BufRead *.ini^I^I^Isetf dosini[J

line 980: [J

line 981: " SysV Inittab[J

line 982: au BufNewFile,BufRead inittab^I^I^Isetf inittab[J

line 983: [J

line 984: " Inno Setup[J

line 985: au BufNewFile,BufRead *.iss^I^I^Isetf iss[J

line 986: [J

line 987: " J[J

line 988: au BufNewFile,BufRead *.ijs^I^I^Isetf j[J

line 989: [J

line 990: " JAL[J

line 991: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal[J

line 992: [J

line 993: " Jam[J

line 994: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam[J

line 995: [J

line 996: " Java[J

line 997: au BufNewFile,BufRead *.java,*.jav^I^Isetf java[J

line 998: [J

line 999: " JavaCC[J

line 1000: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc[J

line 1001: [J

line 1002: " JavaScript, ECMAScript[J

line 1003: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx   setf javascript[J

line 1004: [J

line 1005: " Java Server Pages[J

line 1006: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp[J

line 1007: [J

line 1008: " Java Properties resource file (note: doesn't catch font.properties.pl)[J

line 1009: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties[J

line 1010: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')[J

line 1011: [J

line 1012: " Jess[J

line 1013: au BufNewFile,BufRead *.clp^I^I^Isetf jess[J

line 1014: [J

line 1015: " Jgraph[J

line 1016: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph[J

line 1017: [J

line 1018: " Jovial[J

line 1019: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial[J

line 1020: [J

line 1021: " JSON[J

line 1022: au BufNewFile,BufRead *.json,*.jsonp^I^Isetf json[J

line 1023: [J

line 1024: " Kixtart[J

line 1025: au BufNewFile,BufRead *.kix^I^I^Isetf kix[J

line 1026: [J

line 1027: " Kimwitu[++][J

line 1028: au BufNewFile,BufRead *.k^I^I^Isetf kwt[J

line 1029: [J

line 1030: " Kivy[J

line 1031: au BufNewFile,BufRead *.kv^I^I^Isetf kivy[J

line 1032: [J

line 1033: " KDE script[J

line 1034: au BufNewFile,BufRead *.ks^I^I^Isetf kscript[J

line 1035: [J

line 1036: " Kconfig[J

line 1037: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig[J

line 1038: [J

line 1039: " Lace (ISE)[J

line 1040: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace[J

line 1041: [J

line 1042: " Latte[J

line 1043: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte[J

line 1044: [J

line 1045: " Limits[J

line 1046: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits[J

line 1047: [J

line 1048: " LambdaProlog (*.mod too, see Modsim)[J

line 1049: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog[J

line 1050: [J

line 1051: " LDAP LDIF[J

line 1052: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif[J

line 1053: [J

line 1054: " Ld loader[J

line 1055: au BufNewFile,BufRead *.ld^I^I^Isetf ld[J

line 1056: [J

line 1057: " Less[J

line 1058: au BufNewFile,BufRead *.less^I^I^Isetf less[J

line 1059: [J

line 1060: " Lex[J

line 1061: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex[J

line 1062: [J

line 1063: " Libao[J

line 1064: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao[J

line 1065: [J

line 1066: " Libsensors[J

line 1067: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors[J

line 1068: [J

line 1069: " LFTP[J

line 1070: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp[J

line 1071: [J

line 1072: " Lifelines (or Lex for C++!)[J

line 1073: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines[J

line 1074: [J

line 1075: " Lilo: Linux loader[J

line 1076: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo[J

line 1077: [J

line 1078: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)[J

line 1079: if has("fname_case")[J

line 1080:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp[J

line 1081: else[J

line 1082:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp[J

line 1083: endif[J

line 1084: [J

line 1085: " SBCL implementation of Common Lisp[J

line 1086: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp[J

line 1087: [J

line 1088: " Liquid[J

line 1089: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid[J

line 1090: [J

line 1091: " Lite[J

line 1092: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite[J

line 1093: [J

line 1094: " LiteStep RC files[J

line 1095: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep[J

line 1096: [J

line 1097: " Login access[J

line 1098: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess[J

line 1099: [J

line 1100: " Login defs[J

line 1101: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs[J

line 1102: [J

line 1103: " Logtalk[J

line 1104: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk[J

line 1105: [J

line 1106: " LOTOS[J

line 1107: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos[J

line 1108: [J

line 1109: " Lout (also: *.lt)[J

line 1110: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout[J

line 1111: [J

line 1112: " Lua[J

line 1113: au BufNewFile,BufRead *.lua^I^I^Isetf lua[J

line 1114: [J

line 1115: " Luarocks[J

line 1116: au BufNewFile,BufRead *.rockspec^I^Isetf lua[J

line 1117: [J

line 1118: " Linden Scripting Language (Second Life)[J

line 1119: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl[J

line 1120: [J

line 1121: " Lynx style file (or LotusScript!)[J

line 1122: au BufNewFile,BufRead *.lss^I^I^Isetf lss[J

line 1123: [J

line 1124: " M4[J

line 1126: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif[J

line 1127: [J

line 1128: " MaGic Point[J

line 1129: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp[J

line 1130: [J

line 1131: " Mail (for Elm, trn, mutt, muttng, rn, slrn)[J

line 1132: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail[J

line 1133: [J

line 1134: " Mail aliases[J

line 1135: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases[J

line 1136: [J

line 1137: " Mailcap configuration file[J

line 1138: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap[J

line 1139: [J

line 1140: " Makefile[J

line 1141: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make[J

line 1142: [J

line 1143: " MakeIndex[J

line 1144: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist[J

line 1145: [J

line 1146: " Mallard[J

line 1147: au BufNewFile,BufRead *.page^I^I^Isetf mallard[J

line 1148: [J

line 1149: " Manpage[J

line 1150: au BufNewFile,BufRead *.man^I^I^Isetf man[J

line 1151: [J

line 1152: " Man config[J

line 1153: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf[J

line 1154: [J

line 1155: " Maple V[J

line 1156: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple[J

line 1157: [J

line 1158: " Map (UMN mapserver config file)[J

line 1159: au BufNewFile,BufRead *.map^I^I^Isetf map[J

line 1160: [J

line 1161: " Markdown[J

line 1162: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown[J

line 1163: [J

line 1164: " Mason[J

line 1165: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason[J

line 1166: [J

line 1167: " Matlab or Objective C[J

line 1168: au BufNewFile,BufRead *.m^I^I^Icall s:FTm()[J

line 1169: [J

line 1170: func! s:FTm()[J

line 1194: [J

line 1195: " Mathematica notebook[J

line 1196: au BufNewFile,BufRead *.nb^I^I^Isetf mma[J

line 1197: [J

line 1198: " Maya Extension Language[J

line 1199: au BufNewFile,BufRead *.mel^I^I^Isetf mel[J

line 1200: [J

line 1201: " Mercurial (hg) commit file[J

line 1202: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit[J

line 1203: [J

line 1204: " Mercurial config (looks like generic config file)[J

line 1205: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg[J

line 1206: [J

line 1207: " Messages (logs mostly)[J

line 1208: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages[J

line 1209: [J

line 1210: " Metafont[J

line 1211: au BufNewFile,BufRead *.mf^I^I^Isetf mf[J

line 1212: [J

line 1213: " MetaPost[J

line 1214: au BufNewFile,BufRead *.mp^I^I^Isetf mp[J

line 1215: [J

line 1216: " MGL[J

line 1217: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl[J

line 1218: [J

line 1219: " MIX - Knuth assembly[J

line 1220: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix[J

line 1221: [J

line 1222: " MMIX or VMS makefile[J

line 1223: au BufNewFile,BufRead *.mms^I^I^Icall s:FTmms()[J

line 1224: [J

line 1225: " Symbian meta-makefile definition (MMP)[J

line 1226: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp[J

line 1227: [J

line 1228: func! s:FTmms()[J

line 1244: [J

line 1245: [J

line 1246: " Modsim III (or LambdaProlog)[J

line 1252: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif[J

line 1253: [J

line 1254: " Modula 2  (.md removed in favor of Markdown)[J

line 1255: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2[J

line 1256: [J

line 1257: " Modula 3 (.m3, .i3, .mg, .ig)[J

line 1258: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3[J

line 1259: [J

line 1260: " Monk[J

line 1261: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk[J

line 1262: [J

line 1263: " MOO[J

line 1264: au BufNewFile,BufRead *.moo^I^I^Isetf moo[J

line 1265: [J

line 1266: " Modconf[J

line 1267: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf[J

line 1268: [J

line 1269: " Mplayer config[J

line 1270: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf[J

line 1271: [J

line 1272: " Motorola S record[J

line 1273: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec[J

line 1274: [J

line 1275: " Mrxvtrc[J

line 1276: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc[J

line 1277: [J

line 1278: " Msql[J

line 1279: au BufNewFile,BufRead *.msql^I^I^Isetf msql[J

line 1280: [J

line 1281: " Mysql[J

line 1282: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql[J

line 1283: [J

line 1284: " Mutt setup files (must be before catch *.rc)[J

line 1285: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')[J

line 1286: [J

line 1287: " M$ Resource files[J

line 1288: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc[J

line 1289: [J

line 1290: " MuPAD source[J

line 1291: au BufRead,BufNewFile *.mu^I^I^Isetf mupad[J

line 1292: [J

line 1293: " Mush[J

line 1294: au BufNewFile,BufRead *.mush^I^I^Isetf mush[J

line 1295: [J

line 1296: " Mutt setup file (also for Muttng)[J

line 1297: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc[J

line 1298: [J

line 1299: " Nano[J

line 1300: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc[J

line 1301: [J

line 1302: " Nastran input/DMAP[J

line 1303: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran[J

line 1304: [J

line 1305: " Natural[J

line 1306: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural[J

line 1307: [J

line 1308: " Netrc[J

line 1309: au BufNewFile,BufRead .netrc^I^I^Isetf netrc[J

line 1310: [J

line 1311: " Ninja file[J

line 1312: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja[J

line 1313: [J

line 1314: " Novell netware batch files[J

line 1315: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf[J

line 1316: [J

line 1317: " Nroff/Troff (*.ms and *.t are checked below)[J

line 1321: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif[J

line 1322: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff[J

line 1323: au BufNewFile,BufRead *.[1-9]^I^I^Icall s:FTnroff()[J

line 1324: [J

line 1325: " This function checks if one of the first five lines start with a dot.  In[J

line 1326: " that case it is probably an nroff file: 'filetype' is set and 1 is returned.[J

line 1327: func! s:FTnroff()[J

line 1334: [J

line 1335: " Nroff or Objective C++[J

line 1336: au BufNewFile,BufRead *.mm^I^I^Icall s:FTmm()[J

line 1337: [J

line 1338: func! s:FTmm()[J

line 1350: [J

line 1351: " Not Quite C[J

line 1352: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc[J

line 1353: [J

line 1354: " NSIS[J

line 1355: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis[J

line 1356: [J

line 1357: " OCAML[J

line 1358: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml[J

line 1359: [J

line 1360: " Occam[J

line 1361: au BufNewFile,BufRead *.occ^I^I^Isetf occam[J

line 1362: [J

line 1363: " Omnimark[J

line 1364: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark[J

line 1365: [J

line 1366: " OpenROAD[J

line 1367: au BufNewFile,BufRead *.or^I^I^Isetf openroad[J

line 1368: [J

line 1369: " OPL[J

line 1370: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl[J

line 1371: [J

line 1372: " Oracle config file[J

line 1373: au BufNewFile,BufRead *.ora^I^I^Isetf ora[J

line 1374: [J

line 1375: " Packet filter conf[J

line 1376: au BufNewFile,BufRead pf.conf^I^I^Isetf pf[J

line 1377: [J

line 1378: " Pam conf[J

line 1379: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf[J

line 1380: [J

line 1381: " PApp[J

line 1382: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp[J

line 1383: [J

line 1384: " Password file[J

line 1385: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd[J

line 1386: [J

line 1387: " Pascal (also *.p)[J

line 1388: au BufNewFile,BufRead *.pas^I^I^Isetf pascal[J

line 1389: [J

line 1390: " Delphi project file[J

line 1391: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal[J

line 1392: [J

line 1393: " PDF[J

line 1394: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf[J

line 1395: [J

line 1396: " Perl[J

line 1397: if has("fname_case")[J

line 1398:   au BufNewFile,BufRead *.pl,*.PL^I^Icall s:FTpl()[J

line 1399: else[J

line 1400:   au BufNewFile,BufRead *.pl^I^I^Icall s:FTpl()[J

line 1401: endif[J

line 1402: au BufNewFile,BufRead *.plx,*.al^I^Isetf perl[J

line 1403: au BufNewFile,BufRead *.p6,*.pm6^I^Isetf perl6[J

line 1404: [J

line 1405: func! s:FTpl()[J

line 1419: [J

line 1420: " Perl, XPM or XPM2[J

line 1428: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif[J

line 1429: [J

line 1430: " Perl POD[J

line 1431: au BufNewFile,BufRead *.pod^I^I^Isetf pod[J

line 1432: [J

line 1433: " Php, php3, php4, etc.[J

line 1434: " Also Phtml (was used for PHP 2 in the past)[J

line 1435: " Also .ctp for Cake template file[J

line 1436: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php[J

line 1437: [J

line 1438: " Pike[J

line 1439: au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike[J

line 1440: [J

line 1441: " Pinfo config[J

line 1442: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo[J

line 1443: [J

line 1444: " Palm Resource compiler[J

line 1445: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc[J

line 1446: [J

line 1447: " Pine config[J

line 1448: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine[J

line 1449: [J

line 1450: " PL/1, PL/I[J

line 1451: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli[J

line 1452: [J

line 1453: " PL/M (also: *.inp)[J

line 1454: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm[J

line 1455: [J

line 1456: " PL/SQL[J

line 1457: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql[J

line 1458: [J

line 1459: " PLP[J

line 1460: au BufNewFile,BufRead *.plp^I^I^Isetf plp[J

line 1461: [J

line 1462: " PO and PO template (GNU gettext)[J

line 1463: au BufNewFile,BufRead *.po,*.pot^I^Isetf po[J

line 1464: [J

line 1465: " Postfix main config[J

line 1466: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain[J

line 1467: [J

line 1468: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)[J

line 1469: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr[J

line 1470: [J

line 1471: " PostScript Printer Description[J

line 1472: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd[J

line 1473: [J

line 1474: " Povray[J

line 1475: au BufNewFile,BufRead *.pov^I^I^Isetf pov[J

line 1476: [J

line 1477: " Povray configuration[J

line 1478: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini[J

line 1479: [J

line 1480: " Povray, PHP or assembly[J

line 1481: au BufNewFile,BufRead *.inc^I^I^Icall s:FTinc()[J

line 1482: [J

line 1483: func! s:FTinc()[J

line 1504: [J

line 1505: " Printcap and Termcap[J

line 1507: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap[J

line 1509: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap[J

line 1510: [J

line 1511: " PCCTS / ANTRL[J

line 1512: "au BufNewFile,BufRead *.g^I^I^Isetf antrl[J

line 1513: au BufNewFile,BufRead *.g^I^I^Isetf pccts[J

line 1514: [J

line 1515: " PPWizard[J

line 1516: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz[J

line 1517: [J

line 1518: " Obj 3D file format[J

line 1519: " TODO: is there a way to avoid MS-Windows Object files?[J

line 1520: au BufNewFile,BufRead *.obj^I^I^Isetf obj[J

line 1521: [J

line 1522: " Oracle Pro*C/C++[J

line 1523: au BufNewFile,BufRead *.pc^I^I^Isetf proc[J

line 1524: [J

line 1525: " Privoxy actions file[J

line 1526: au BufNewFile,BufRead *.action^I^I^Isetf privoxy[J

line 1527: [J

line 1528: " Procmail[J

line 1529: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail[J

line 1530: [J

line 1531: " Progress or CWEB[J

line 1532: au BufNewFile,BufRead *.w^I^I^Icall s:FTprogress_cweb()[J

line 1533: [J

line 1534: func! s:FTprogress_cweb()[J

line 1545: [J

line 1546: " Progress or assembly[J

line 1547: au BufNewFile,BufRead *.i^I^I^Icall s:FTprogress_asm()[J

line 1548: [J

line 1549: func! s:FTprogress_asm()[J

line 1571: [J

line 1572: " Progress or Pascal[J

line 1573: au BufNewFile,BufRead *.p^I^I^Icall s:FTprogress_pascal()[J

line 1574: [J

line 1575: func! s:FTprogress_pascal()[J

line 1599: [J

line 1600: [J

line 1601: " Software Distributor Product Specification File (POSIX 1387.2-1995)[J

line 1602: au BufNewFile,BufRead *.psf^I^I^Isetf psf[J

line 1606: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif[J

line 1607: [J

line 1608: " Prolog[J

line 1609: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog[J

line 1610: [J

line 1611: " Promela[J

line 1612: au BufNewFile,BufRead *.pml^I^I^Isetf promela[J

line 1613: [J

line 1614: " Google protocol buffers[J

line 1615: au BufNewFile,BufRead *.proto^I^I^Isetf proto[J

line 1616: [J

line 1617: " Protocols[J

line 1618: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols[J

line 1619: [J

line 1620: " Pyrex[J

line 1621: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex[J

line 1622: [J

line 1623: " Python[J

line 1624: au BufNewFile,BufRead *.py,*.pyw^I^Isetf python[J

line 1625: [J

line 1626: " Quixote (Python-based web framework)[J

line 1627: au BufNewFile,BufRead *.ptl^I^I^Isetf python[J

line 1628: [J

line 1629: " Radiance[J

line 1630: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance[J

line 1631: [J

line 1632: " Ratpoison config/command files[J

line 1633: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison[J

line 1634: [J

line 1635: " RCS file[J

line 1636: au BufNewFile,BufRead *\,v^I^I^Isetf rcs[J

line 1637: [J

line 1638: " Readline[J

line 1639: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline[J

line 1640: [J

line 1641: " Registry for MS-Windows[J

line 1643: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif[J

line 1644: [J

line 1645: " Renderman Interface Bytestream[J

line 1646: au BufNewFile,BufRead *.rib^I^I^Isetf rib[J

line 1647: [J

line 1648: " Rexx[J

line 1649: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx[J

line 1650: [J

line 1651: " R (Splus)[J

line 1652: if has("fname_case")[J

line 1653:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r[J

line 1654: else[J

line 1655:   au BufNewFile,BufRead *.s^I^I^Isetf r[J

line 1656: endif[J

line 1657: [J

line 1658: " R Help file[J

line 1659: if has("fname_case")[J

line 1660:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp[J

line 1661: else[J

line 1662:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp[J

line 1663: endif[J

line 1664: [J

line 1665: " R noweb file[J

line 1666: if has("fname_case")[J

line 1667:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb[J

line 1668: else[J

line 1669:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb[J

line 1670: endif[J

line 1671: [J

line 1672: " R Markdown file[J

line 1673: if has("fname_case")[J

line 1674:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd[J

line 1675: else[J

line 1676:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd[J

line 1677: endif[J

line 1678: [J

line 1679: " R reStructuredText file[J

line 1680: if has("fname_case")[J

line 1681:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst[J

line 1682: else[J

line 1683:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst[J

line 1684: endif[J

line 1685: [J

line 1686: " Rexx, Rebol or R[J

line 1687: au BufNewFile,BufRead *.r,*.R^I^I^Icall s:FTr()[J

line 1688: [J

line 1689: func! s:FTr()[J

line 1721: [J

line 1722: " Remind[J

line 1723: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind[J

line 1724: [J

line 1725: " Resolv.conf[J

line 1726: au BufNewFile,BufRead resolv.conf^I^Isetf resolv[J

line 1727: [J

line 1728: " Relax NG Compact[J

line 1729: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc[J

line 1730: [J

line 1731: " Relax NG XML[J

line 1732: au BufNewFile,BufRead *.rng^I^I^Isetf rng[J

line 1733: [J

line 1734: " RPL/2[J

line 1735: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl[J

line 1736: [J

line 1737: " Robots.txt[J

line 1738: au BufNewFile,BufRead robots.txt^I^Isetf robots[J

line 1739: [J

line 1740: " Rpcgen[J

line 1741: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen[J

line 1742: [J

line 1743: " reStructuredText Documentation Format[J

line 1744: au BufNewFile,BufRead *.rst^I^I^Isetf rst[J

line 1745: [J

line 1746: " RTF[J

line 1747: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf[J

line 1748: [J

line 1749: " Interactive Ruby shell[J

line 1750: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby[J

line 1751: [J

line 1752: " Ruby[J

line 1753: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby[J

line 1754: [J

line 1755: " RubyGems[J

line 1756: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby[J

line 1757: [J

line 1758: " Rackup[J

line 1759: au BufNewFile,BufRead *.ru^I^I^Isetf ruby[J

line 1760: [J

line 1761: " Bundler[J

line 1762: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby[J

line 1763: [J

line 1764: " Ruby on Rails[J

line 1765: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby[J

line 1766: [J

line 1767: " Rantfile and Rakefile is like Ruby[J

line 1768: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby[J

line 1769: [J

line 1770: " S-lang (or shader language, or SmallLisp)[J

line 1771: au BufNewFile,BufRead *.sl^I^I^Isetf slang[J

line 1772: [J

line 1773: " Samba config[J

line 1774: au BufNewFile,BufRead smb.conf^I^I^Isetf samba[J

line 1775: [J

line 1776: " SAS script[J

line 1777: au BufNewFile,BufRead *.sas^I^I^Isetf sas[J

line 1778: [J

line 1779: " Sass[J

line 1780: au BufNewFile,BufRead *.sass^I^I^Isetf sass[J

line 1781: [J

line 1782: " Sather[J

line 1783: au BufNewFile,BufRead *.sa^I^I^Isetf sather[J

line 1784: [J

line 1785: " Scilab[J

line 1786: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab[J

line 1787: [J

line 1788: " SCSS[J

line 1789: au BufNewFile,BufRead *.scss^I^I^Isetf scss[J

line 1790: [J

line 1791: " SD: Streaming Descriptors[J

line 1792: au BufNewFile,BufRead *.sd^I^I^Isetf sd[J

line 1793: [J

line 1794: " SDL[J

line 1795: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl[J

line 1796: [J

line 1797: " sed[J

line 1798: au BufNewFile,BufRead *.sed^I^I^Isetf sed[J

line 1799: [J

line 1800: " Sieve (RFC 3028)[J

line 1801: au BufNewFile,BufRead *.siv^I^I^Isetf sieve[J

line 1802: [J

line 1803: " Sendmail[J

line 1804: au BufNewFile,BufRead sendmail.cf^I^Isetf sm[J

line 1805: [J

line 1806: " Sendmail .mc files are actually m4.  Could also be MS Message text file.[J

line 1807: au BufNewFile,BufRead *.mc^I^I^Icall s:McSetf()[J

line 1808: [J

line 1809: func! s:McSetf()[J

line 1824: [J

line 1825: " Services[J

line 1826: au BufNewFile,BufRead */etc/services^I^Isetf services[J

line 1827: [J

line 1828: " Service Location config[J

line 1829: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf[J

line 1830: [J

line 1831: " Service Location registration[J

line 1832: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg[J

line 1833: [J

line 1834: " Service Location SPI[J

line 1835: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi[J

line 1836: [J

line 1837: " Setserial config[J

line 1838: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial[J

line 1839: [J

line 1840: " SGML[J

line 1850: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif[J

line 1851: [J

line 1852: " SGMLDECL[J

line 1856: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif[J

line 1857: [J

line 1858: " SGML catalog file[J

line 1859: au BufNewFile,BufRead catalog^I^I^Isetf catalog[J

line 1860: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')[J

line 1861: [J

line 1862: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.[J

line 1863: " Gentoo ebuilds are actually bash scripts[J

line 1864: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass call SetFileTypeSH("bash")[J

line 1865: au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")[J

line 1866: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))[J

line 1867: [J

line 1868: " Also called from scripts.vim.[J

line 1869: func! SetFileTypeSH(name)[J

line 1912: [J

line 1913: " For shell-like file types, check for an "exec" command hidden in a comment,[J

line 1914: " as used for Tcl.[J

line 1915: " Also called from scripts.vim, thus can't be local to this script.[J

line 1916: func! SetFileTypeShell(name)[J

line 1935: [J

line 1936: " tcsh scripts[J

line 1937: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall SetFileTypeShell("tcsh")[J

line 1938: [J

line 1939: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)[J

line 1940: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()[J

line 1941: [J

line 1942: func! s:CSH()[J

line 1951: [J

line 1952: " Z-Shell script[J

line 1953: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh[J

line 1954: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')[J

line 1955: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh[J

line 1956: [J

line 1957: " Scheme[J

line 1958: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme[J

line 1959: [J

line 1960: " Screen RC[J

line 1961: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen[J

line 1962: [J

line 1963: " Simula[J

line 1964: au BufNewFile,BufRead *.sim^I^I^Isetf simula[J

line 1965: [J

line 1966: " SINDA[J

line 1967: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda[J

line 1968: [J

line 1969: " SiSU[J

line 1970: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu[J

line 1971: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu[J

line 1972: [J

line 1973: " SKILL[J

line 1974: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill[J

line 1975: [J

line 1976: " SLRN[J

line 1977: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc[J

line 1978: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc[J

line 1979: [J

line 1980: " Smalltalk (and TeX)[J

line 1981: au BufNewFile,BufRead *.st^I^I^Isetf st[J

line 1989: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif[J

line 1990: [J

line 1991: " Smarty templates[J

line 1992: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty[J

line 1993: [J

line 1994: " SMIL or XML[J

line 2000: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif[J

line 2001: [J

line 2002: " SMIL or SNMP MIB file[J

line 2008: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif[J

line 2009: [J

line 2010: " SMITH[J

line 2011: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith[J

line 2012: [J

line 2013: " Snobol4 and spitbol[J

line 2014: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4[J

line 2015: [J

line 2016: " SNMP MIB files[J

line 2017: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib[J

line 2018: [J

line 2019: " Snort Configuration[J

line 2020: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog[J

line 2021: au BufNewFile,BufRead *.rules^I^I^Icall s:FTRules()[J

line 2022: [J

line 2023: let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'[J

line 2024: func! s:FTRules()[J

line 2056: [J

line 2057: [J

line 2058: " Spec (Linux RPM)[J

line 2059: au BufNewFile,BufRead *.spec^I^I^Isetf spec[J

line 2060: [J

line 2061: " Speedup (AspenTech plant simulator)[J

line 2062: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup[J

line 2063: [J

line 2064: " Slice[J

line 2065: au BufNewFile,BufRead *.ice^I^I^Isetf slice[J

line 2066: [J

line 2067: " Spice[J

line 2068: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice[J

line 2069: [J

line 2070: " Spyce[J

line 2071: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce[J

line 2072: [J

line 2073: " Squid[J

line 2074: au BufNewFile,BufRead squid.conf^I^Isetf squid[J

line 2075: [J

line 2076: " SQL for Oracle Designer[J

line 2077: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql[J

line 2078: [J

line 2079: " SQL[J

line 2080: au BufNewFile,BufRead *.sql^I^I^Icall s:SQL()[J

line 2081: [J

line 2082: func! s:SQL()[J

line 2089: [J

line 2090: " SQLJ[J

line 2091: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj[J

line 2092: [J

line 2093: " SQR[J

line 2094: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr[J

line 2095: [J

line 2096: " OpenSSH configuration[J

line 2097: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig[J

line 2098: [J

line 2099: " OpenSSH server configuration[J

line 2100: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig[J

line 2101: [J

line 2102: " Stata[J

line 2103: au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata[J

line 2104: [J

line 2105: " SMCL[J

line 2106: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl[J

line 2107: [J

line 2108: " Stored Procedures[J

line 2109: au BufNewFile,BufRead *.stp^I^I^Isetf stp[J

line 2110: [J

line 2111: " Standard ML[J

line 2112: au BufNewFile,BufRead *.sml^I^I^Isetf sml[J

line 2113: [J

line 2114: " Sratus VOS command macro[J

line 2115: au BufNewFile,BufRead *.cm^I^I^Isetf voscm[J

line 2116: [J

line 2117: " Sysctl[J

line 2118: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl[J

line 2119: [J

line 2120: " Systemd unit files[J

line 2121: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd[J

line 2122: [J

line 2123: " Synopsys Design Constraints[J

line 2124: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc[J

line 2125: [J

line 2126: " Sudoers[J

line 2127: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers[J

line 2128: [J

line 2129: " SVG (Scalable Vector Graphics)[J

line 2130: au BufNewFile,BufRead *.svg^I^I^Isetf svg[J

line 2131: [J

line 2132: " If the file has an extension of 't' and is in a directory 't' or 'xt' then[J

line 2133: " it is almost certainly a Perl test file.[J

line 2134: " If the first line starts with '#' and contains 'perl' it's probably a Perl[J

line 2135: " file.[J

line 2136: " (Slow test) If a file contains a 'use' statement then it is almost certainly[J

line 2137: " a Perl file.[J

line 2138: func! s:FTperl()[J

line 2154: [J

line 2155: " Tads (or Nroff or Perl test file)[J

line 2157: au BufNewFile,BufRead *.t if !s:FTnroff() && !s:FTperl() | setf tads | endif[J

line 2158: [J

line 2159: " Tags[J

line 2160: au BufNewFile,BufRead tags^I^I^Isetf tags[J

line 2161: [J

line 2162: " TAK[J

line 2163: au BufNewFile,BufRead *.tak^I^I^Isetf tak[J

line 2164: [J

line 2165: " Task[J

line 2166: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata[J

line 2167: au BufRead,BufNewFile *.task^I^I^Isetf taskedit[J

line 2168: [J

line 2169: " Tcl (JACL too)[J

line 2170: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl[J

line 2171: [J

line 2172: " TealInfo[J

line 2173: au BufNewFile,BufRead *.tli^I^I^Isetf tli[J

line 2174: [J

line 2175: " Telix Salt[J

line 2176: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt[J

line 2177: [J

line 2178: " Tera Term Language[J

line 2179: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm[J

line 2180: [J

line 2181: " Terminfo[J

line 2182: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo[J

line 2183: [J

line 2184: " TeX[J

line 2185: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex[J

line 2186: au BufNewFile,BufRead *.tex^I^I^Icall s:FTtex()[J

line 2187: [J

line 2188: " Choose context, plaintex, or tex (LaTeX) based on these rules:[J

line 2189: " 1. Check the first line of the file for "%&<format>".[J

line 2190: " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.[J

line 2191: " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.[J

line 2192: func! s:FTtex()[J

line 2239: [J

line 2240: " ConTeXt[J

line 2241: au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context[J

line 2242: [J

line 2243: " Texinfo[J

line 2244: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo[J

line 2245: [J

line 2246: " TeX configuration[J

line 2247: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf[J

line 2248: [J

line 2249: " Tidy config[J

line 2250: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy[J

line 2251: [J

line 2252: " TF mud client[J

line 2253: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf[J

line 2254: [J

line 2255: " TPP - Text Presentation Program[J

line 2256: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp[J

line 2257: [J

line 2258: " Treetop[J

line 2259: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop[J

line 2260: [J

line 2261: " Trustees[J

line 2262: au BufNewFile,BufRead trustees.conf^I^Isetf trustees[J

line 2263: [J

line 2264: " TSS - Geometry[J

line 2265: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm[J

line 2266: [J

line 2267: " TSS - Optics[J

line 2268: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop[J

line 2269: [J

line 2270: " TSS - Command Line (temporary)[J

line 2271: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl[J

line 2272: [J

line 2273: " TWIG files[J

line 2274: au BufNewFile,BufReadPost *.twig^I^Isetf twig[J

line 2275: [J

line 2276: " Motif UIT/UIL files[J

line 2277: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil[J

line 2278: [J

line 2279: " Udev conf[J

line 2280: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf[J

line 2281: [J

line 2282: " Udev permissions[J

line 2283: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm[J

line 2284: "[J

line 2285: " Udev symlinks config[J

line 2286: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh[J

line 2287: [J

line 2288: " UnrealScript[J

line 2289: au BufNewFile,BufRead *.uc^I^I^Isetf uc[J

line 2290: [J

line 2291: " Updatedb[J

line 2292: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb[J

line 2293: [J

line 2294: " Upstart (init(8)) config files[J

line 2295: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart[J

line 2296: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart[J

line 2297: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart[J

line 2298: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart[J

line 2299: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart[J

line 2300: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart[J

line 2301: [J

line 2302: " Vera[J

line 2303: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera[J

line 2304: [J

line 2305: " Verilog HDL[J

line 2306: au BufNewFile,BufRead *.v^I^I^Isetf verilog[J

line 2307: [J

line 2308: " Verilog-AMS HDL[J

line 2309: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams[J

line 2310: [J

line 2311: " SystemVerilog[J

line 2312: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog[J

line 2313: [J

line 2314: " VHDL[J

line 2315: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl[J

line 2316: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')[J

line 2317: [J

line 2318: " Vim script[J

line 2319: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim[J

line 2320: [J

line 2321: " Viminfo file[J

line 2322: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo[J

line 2323: [J

line 2324: " Virata Config Script File or Drupal module[J

line 2330: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif[J

line 2331: [J

line 2332: " Visual Basic (also uses *.bas) or FORM[J

line 2333: au BufNewFile,BufRead *.frm^I^I^Icall s:FTVB("form")[J

line 2334: [J

line 2335: " SaxBasic is close to Visual Basic[J

line 2336: au BufNewFile,BufRead *.sba^I^I^Isetf vb[J

line 2337: [J

line 2338: " Vgrindefs file[J

line 2339: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs[J

line 2340: [J

line 2341: " VRML V1.0c[J

line 2342: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml[J

line 2343: [J

line 2344: " Vroom (vim testing and executable documentation)[J

line 2345: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom[J

line 2346: [J

line 2347: " Webmacro[J

line 2348: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro[J

line 2349: [J

line 2350: " Wget config[J

line 2351: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget[J

line 2352: [J

line 2353: " Website MetaLanguage[J

line 2354: au BufNewFile,BufRead *.wml^I^I^Isetf wml[J

line 2355: [J

line 2356: " Winbatch[J

line 2357: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch[J

line 2358: [J

line 2359: " WSML[J

line 2360: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml[J

line 2361: [J

line 2362: " WvDial[J

line 2363: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial[J

line 2364: [J

line 2365: " CVS RC file[J

line 2366: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc[J

line 2367: [J

line 2368: " CVS commit file[J

line 2369: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs[J

line 2370: [J

line 2371: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment[J

line 2372: " lines in a WEB file).[J

line 2378: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif[J

line 2379: [J

line 2380: " Windows Scripting Host and Windows Script Component[J

line 2381: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh[J

line 2382: [J

line 2383: " XHTML[J

line 2384: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml[J

line 2385: [J

line 2386: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)[J

line 2392: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif[J

line 2393: au BufEnter *.xpm2^I^I^I^Isetf xpm2[J

line 2394: [J

line 2395: " XFree86 config[J

line 2400: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf[J

line 2403: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf[J

line 2404: [J

line 2405: " Xorg config[J

line 2406: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf[J

line 2407: [J

line 2408: " Xinetd conf[J

line 2409: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd[J

line 2410: [J

line 2411: " XS Perl extension interface language[J

line 2412: au BufNewFile,BufRead *.xs^I^I^Isetf xs[J

line 2413: [J

line 2414: " X resources file[J

line 2415: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults[J

line 2416: [J

line 2417: " Xmath[J

line 2418: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath[J

line 2420: au BufNewFile,BufRead *.ms if !s:FTnroff() | setf xmath | endif[J

line 2421: [J

line 2422: " XML  specific variants: docbk and xbl[J

line 2423: au BufNewFile,BufRead *.xml^I^I^Icall s:FTxml()[J

line 2424: [J

line 2425: func! s:FTxml()[J

line 2450: [J

line 2451: " XMI (holding UML models) is also XML[J

line 2452: au BufNewFile,BufRead *.xmi^I^I^Isetf xml[J

line 2453: [J

line 2454: " CSPROJ files are Visual Studio.NET's XML-based project config files[J

line 2455: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml[J

line 2456: [J

line 2457: " Qt Linguist translation source and Qt User Interface Files are XML[J

line 2458: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml[J

line 2459: [J

line 2460: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)[J

line 2461: au BufNewFile,BufRead *.tpm^I^I^Isetf xml[J

line 2462: [J

line 2463: " Xdg menus[J

line 2464: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml[J

line 2465: [J

line 2466: " ATI graphics driver configuration[J

line 2467: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml[J

line 2468: [J

line 2469: " XLIFF (XML Localisation Interchange File Format) is also XML[J

line 2470: au BufNewFile,BufRead *.xlf^I^I^Isetf xml[J

line 2471: au BufNewFile,BufRead *.xliff^I^I^Isetf xml[J

line 2472: [J

line 2473: " XML User Interface Language[J

line 2474: au BufNewFile,BufRead *.xul^I^I^Isetf xml[J

line 2475: [J

line 2476: " X11 xmodmap (also see below)[J

line 2477: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap[J

line 2478: [J

line 2479: " Xquery[J

line 2480: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery[J

line 2481: [J

line 2482: " XSD[J

line 2483: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd[J

line 2484: [J

line 2485: " Xslt[J

line 2486: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt[J

line 2487: [J

line 2488: " Yacc[J

line 2489: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc[J

line 2490: [J

line 2491: " Yacc or racc[J

line 2492: au BufNewFile,BufRead *.y^I^I^Icall s:FTy()[J

line 2493: [J

line 2494: func! s:FTy()[J

line 2510: [J

line 2511: [J

line 2512: " Yaml[J

line 2513: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml[J

line 2514: [J

line 2515: " yum conf (close enough to dosini)[J

line 2516: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini[J

line 2517: [J

line 2518: " Zimbu[J

line 2519: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu[J

line 2520: " Zimbu Templates[J

line 2521: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl[J

line 2522: [J

line 2523: " Zope[J

line 2524: "   dtml (zope dynamic template markup language), pt (zope page template),[J

line 2525: "   cpt (zope form controller page template)[J

line 2526: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall s:FThtml()[J

line 2527: "   zsql (zope sql method)[J

line 2528: au BufNewFile,BufRead *.zsql^I^I^Icall s:SQL()[J

line 2529: [J

line 2530: " Z80 assembler asz80[J

line 2531: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a[J

line 2532: [J

line 2533: augroup END[J

line 2534: [J

line 2535: [J

line 2536: " Source the user-specified filetype file, for backwards compatibility with[J

line 2537: " Vim 5.x.[J

line 2538: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))[J

line 2539:   execute "source " . myfiletypefile[J

line 2540: endif[J

line 2541: [J

line 2542: [J

line 2543: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used[J

line 2544: " when there are no matching file name extensions.[J

line 2545: " Don't do this for compressed files.[J

line 2546: augroup filetypedetect[J

line 2549: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif[J

line 2550: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif[J

line 2551: [J

line 2552: [J

line 2553: " Extra checks for when no filetype has been detected now.  Mostly used for[J

line 2554: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim[J

line 2555: " script file.[J

line 2556: " Most of these should call s:StarSetf() to avoid names ending in .gz and the[J

line 2557: " like are used.[J

line 2558: [J

line 2559: " More Apache config files[J

line 2560: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')[J

line 2561: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')[J

line 2562: [J

line 2563: " Asterisk config file[J

line 2564: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')[J

line 2565: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')[J

line 2566: [J

line 2567: " Bazaar version control[J

line 2568: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr[J

line 2569: [J

line 2570: " BIND zone[J

line 2571: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')[J

line 2572: [J

line 2573: " Calendar[J

line 2576: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')[J

line 2577: [J

line 2578: " Changelog[J

line 2584: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif[J

line 2585: [J

line 2586: " Crontab[J

line 2587: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')[J

line 2588: [J

line 2589: " dnsmasq(8) configuration[J

line 2590: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')[J

line 2591: [J

line 2592: " Dracula[J

line 2593: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')[J

line 2594: [J

line 2595: " Fvwm[J

line 2596: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')[J

line 2598: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')[J

line 2604: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif[J

line 2605: [J

line 2606: " Gedcom[J

line 2607: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')[J

line 2608: [J

line 2609: " GTK RC[J

line 2610: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')[J

line 2611: [J

line 2612: " Jam[J

line 2613: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')[J

line 2614: [J

line 2615: " Jargon[J

line 2619: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif[J

line 2620: [J

line 2621: " Kconfig[J

line 2622: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')[J

line 2623: [J

line 2624: " Lilo: Linux loader[J

line 2625: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')[J

line 2626: [J

line 2627: " Logcheck[J

line 2628: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')[J

line 2629: [J

line 2630: " Makefile[J

line 2631: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')[J

line 2632: [J

line 2633: " Ruby Makefile[J

line 2634: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')[J

line 2635: [J

line 2636: " Mail (also matches muttrc.vim, so this is below the other checks)[J

line 2637: au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}^Isetf mail[J

line 2638: [J

line 2639: " Modconf[J

line 2643: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif[J

line 2644: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')[J

line 2645: [J

line 2646: " Mutt setup file[J

line 2647: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')[J

line 2648: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')[J

line 2649: [J

line 2650: " Nroff macros[J

line 2651: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')[J

line 2652: [J

line 2653: " Pam conf[J

line 2654: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')[J

line 2655: [J

line 2656: " Printcap and Termcap[J

line 2660: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif[J

line 2664: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif[J

line 2665: [J

line 2666: " ReDIF[J

line 2667: " Only used when the .rdf file was not detected to be XML.[J

line 2668: au BufRead,BufNewFile *.rdf^I^I^Icall s:Redif()[J

line 2669: func! s:Redif()[J

line 2679: [J

line 2680: " Remind[J

line 2681: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')[J

line 2682: [J

line 2683: " Vim script[J

line 2684: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')[J

line 2685: [J

line 2686: " Subversion commit file[J

line 2687: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn[J

line 2688: [J

line 2689: " X resources file[J

line 2690: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')[J

line 2691: [J

line 2692: " XFree86 config[J

line 2694: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')[J

line 2699: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')[J

line 2700: [J

line 2701: " X11 xmodmap[J

line 2702: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')[J

line 2703: [J

line 2704: " Xinetd conf[J

line 2705: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')[J

line 2706: [J

line 2707: " yum conf (close enough to dosini)[J

line 2708: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')[J

line 2709: [J

line 2710: " Z-Shell script[J

line 2711: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')[J

line 2712: [J

line 2713: [J

line 2714: " Plain text files, needs to be far down to not override others.  This avoids[J

line 2715: " the "conf" type being used if there is a line starting with '#'.[J

line 2716: au BufNewFile,BufRead *.txt,*.text,README^Isetf text[J

line 2717: [J

line 2718: [J

line 2719: " Use the filetype detect plugins.  They may overrule any of the previously[J

line 2720: " detected filetypes.[J

line 2721: runtime! ftdetect/*.vim[J

Searching for "ftdetect/*.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/ftdetect/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/i3-vim-syntax/ftdetect)[J
fchdir() to previous dir[J
line 2721: sourcing "/Users/ygarrot/.vim/plugged/i3-vim-syntax/ftdetect/i3.vim"[J
line 1: augroup i3_ftdetect[J

line 2:   au![J

line 3:   au BufRead,BufNewFile *i3/config,*sway/config set ft=i3[J

line 4: augroup END[J

finished sourcing /Users/ygarrot/.vim/plugged/i3-vim-syntax/ftdetect/i3.vim[J
continuing in /usr/share/vim/vim74/filetype.vim[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/ftdetect/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-fugitive/ftdetect)[J
fchdir() to previous dir[J
line 2721: sourcing "/Users/ygarrot/.vim/plugged/vim-fugitive/ftdetect/fugitive.vim"[J
line 1: autocmd BufReadPost *.fugitiveblame setfiletype fugitiveblame[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-fugitive/ftdetect/fugitive.vim[J
continuing in /usr/share/vim/vim74/filetype.vim[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vim74/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/ftdetect/*.vim"[J
Searching for "/Users/ygarrot/.vim/after/ftdetect/*.vim"[J
line 2722: [J

line 2723: " NOTE: The above command could have ended the filetypedetect autocmd group[J

line 2724: " and started another one. Let's make sure it has ended to get to a consistent[J

line 2725: " state.[J

line 2726: augroup END[J

line 2727: [J

line 2728: " Generic configuration file (check this last, it's just guessing!)[J

line 2734: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf conf | endif[J

line 2735: [J

line 2736: [J

line 2737: " If the GUI is already running, may still need to install the Syntax menu.[J

line 2738: " Don't do it when the 'M' flag is included in 'guioptions'.[J

line 2740: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"[J

line 2741:   source <sfile>:p:h/menu.vim[J

line 2742: endif[J

line 2743: [J

line 2744: " Function called for testing all functions defined here.  These are[J

line 2745: " script-local, thus need to be executed here.[J

line 2746: " Returns a string with error messages (hopefully empty).[J

line 2747: func! TestFiletypeFuncs(testlist)[J

line 2758: [J

line 2759: " Restore 'cpoptions'[J

line 2760: let &cpo = s:cpo_save[J

line 2761: unlet s:cpo_save[J

finished sourcing /usr/share/vim/vim74/filetype.vim[J
continuing in function plug#end[J
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/after/filetype.vim"[J
Searching for "ftplugin.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/ftplugin.vim"[J
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"[J
Searching for "/usr/share/vim/vim74/ftplugin.vim"[J
chdir(/usr/share/vim/vim74)[J
fchdir() to previous dir[J
line 83: sourcing "/usr/share/vim/vim74/ftplugin.vim"[J
line 1: " Vim support file to switch on loading plugins for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2006 Apr 30[J

line 5: [J

line 6: if exists("did_load_ftplugin")[J

line 7:   finish[J

finished sourcing /usr/share/vim/vim74/ftplugin.vim[J
continuing in function plug#end[J
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/after/ftplugin.vim"[J
Searching for "indent.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/indent.vim"[J
Searching for "/usr/share/vim/vimfiles/indent.vim"[J
Searching for "/usr/share/vim/vim74/indent.vim"[J
chdir(/usr/share/vim/vim74)[J
fchdir() to previous dir[J
line 83: sourcing "/usr/share/vim/vim74/indent.vim"[J
line 1: " Vim support file to switch on loading indent files for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2008 Feb 22[J

line 5: [J

line 6: if exists("did_indent_on")[J

line 7:   finish[J

finished sourcing /usr/share/vim/vim74/indent.vim[J
continuing in function plug#end[J
Searching for "/usr/share/vim/vimfiles/after/indent.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/indent.vim"[J
Searching for "/Users/ygarrot/.vim/after/indent.vim"[J
line 84:   if has('vim_starting')[J

line 85:     if has('syntax') && !exists('g:syntax_on')[J

line 86:       syntax enable[J

line 86: so $VIMRUNTIME/syntax/syntax.vim[J

chdir(/usr/share/vim/vim74/syntax)[J
fchdir() to previous dir[J
line 86: sourcing "/usr/share/vim/vim74/syntax/syntax.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 04[J

line 4: [J

line 5: " This file is used for ":syntax on".[J

line 6: " It installs the autocommands and starts highlighting for all buffers.[J

line 7: [J

line 8: if !has("syntax")[J

line 9:   finish[J

line 10: endif[J

line 11: [J

line 12: " If Syntax highlighting appears to be on already, turn it off first, so that[J

line 13: " any leftovers are cleared.[J

line 14: if exists("syntax_on") || exists("syntax_manual")[J

line 15:   so <sfile>:p:h/nosyntax.vim[J

line 16: endif[J

line 17: [J

line 18: " Load the Syntax autocommands and set the default methods for highlighting.[J

line 19: runtime syntax/synload.vim[J

Searching for "syntax/synload.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/syntax/synload.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"[J
Searching for "/usr/share/vim/vim74/syntax/synload.vim"[J
chdir(/usr/share/vim/vim74/syntax)[J
fchdir() to previous dir[J
line 19: sourcing "/usr/share/vim/vim74/syntax/synload.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2012 Sep 25[J

line 4: [J

line 5: " This file sets up for syntax highlighting.[J

line 6: " It is loaded from "syntax.vim" and "manual.vim".[J

line 7: " 1. Set the default highlight groups.[J

line 8: " 2. Install Syntax autocommands for all the available syntax files.[J

line 9: [J

line 10: if !has("syntax")[J

line 11:   finish[J

line 12: endif[J

line 13: [J

line 14: " let others know that syntax has been switched on[J

line 15: let syntax_on = 1[J

line 16: [J

line 17: " Set the default highlighting colors.  Use a color scheme if specified.[J

line 18: if exists("colors_name")[J

line 19:   exe "colors " . colors_name[J

line 20: else[J

line 21:   runtime! syntax/syncolor.vim[J

Searching for "syntax/syncolor.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim74/syntax)[J
fchdir() to previous dir[J
line 21: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim[J
continuing in /usr/share/vim/vim74/syntax/synload.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/after/syntax/syncolor.vim"[J
line 22: endif[J

line 23: [J

line 24: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 25: let s:cpo_save = &cpo[J

line 26: set cpo&vim[J

line 27: [J

line 28: " First remove all old syntax autocommands.[J

line 29: au! Syntax[J

line 30: [J

line 31: au Syntax *^I^Icall s:SynSet()[J

line 32: [J

line 33: fun! s:SynSet()[J

line 61: [J

line 62: [J

line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)[J

line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif[J

line 69: [J

line 70: [J

line 71: " Source the user-specified syntax highlighting file[J

line 72: if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))[J

line 73:   execute "source " . mysyntaxfile[J

line 74: endif[J

line 75: [J

line 76: " Restore 'cpoptions'[J

line 77: let &cpo = s:cpo_save[J

line 78: unlet s:cpo_save[J

finished sourcing /usr/share/vim/vim74/syntax/synload.vim[J
continuing in /usr/share/vim/vim74/syntax/syntax.vim[J
line 20: [J

line 21: " Load the FileType autocommands if not done yet.[J

line 22: if exists("did_load_filetypes")[J

line 23:   let s:did_ft = 1[J

line 24: else[J

line 25:   filetype on[J

line 26:   let s:did_ft = 0[J

line 27: endif[J

line 28: [J

line 29: " Set up the connection between FileType and Syntax autocommands.[J

line 30: " This makes the syntax automatically set when the file type is detected.[J

line 31: augroup syntaxset[J

line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")[J

line 33: augroup END[J

line 34: [J

line 35: [J

line 36: " Execute the syntax autocommands for the each buffer.[J

line 37: " If the filetype wasn't detected yet, do that now.[J

line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'[J

line 39: " already was set manually (e.g., help buffers).[J

line 40: doautoall syntaxset FileType[J

line 41: if !s:did_ft[J

line 42:   doautoall filetypedetect BufRead[J

line 43: endif[J

finished sourcing /usr/share/vim/vim74/syntax/syntax.vim[J
continuing in function plug#end[J
line 87:     end[J

line 88:   else[J

line 89:     call s:reload_plugins()[J

line 90:   endif[J

function plug#end returning #0[J

continuing in /Users/ygarrot/.vimrc[J

line 28: [J

line 29: [J

line 30: autocmd VimResized * wincmd =[J

line 31: map <C-\> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>[J

line 32: map <C-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>[J

line 33: map <C-f> :exec("tag ".expand("<cword>"))<CR>[J

line 34: [J

line 35: let mapleader=","[J

line 36: set bg=light[J

Searching for "syntax/syncolor.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim74/syntax)[J
fchdir() to previous dir[J
line 36: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim[J
continuing in /Users/ygarrot/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/after/syntax/syncolor.vim"[J
line 37: set mouse=a[J

line 38: set nohlsearch[J

line 39: set tags=./tags;/[J

line 40: [J

line 41: command! W w[J

line 42: [J

line 43: "for comment[J

line 44: map <leader>"         csW"[J

line 45: map <leader>'         csW'[J

line 46: map <leader>''        cs''[J

line 47: map <leader>'"        cs'"[J

line 48: " nmap <leader>c        Vgc[J

line 49: [J

line 50: "show space[J

line 51: set list[J

line 52: set listchars=tab:▸·,trail:·,nbsp:⎵[J

line 53: [J

line 54: "record[J

line 55: nnoremap <leader>q    @q[J

line 56: [J

line 57: set hlsearch[J

line 58: colorscheme gruvbox[J

Searching for "colors/gruvbox.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim"[J
chdir(/Users/ygarrot/.vim/plugged/gruvbox/colors)[J
fchdir() to previous dir[J
line 58: sourcing "/Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim"[J
line 1: " -----------------------------------------------------------------------------[J

line 2: " File: gruvbox.vim[J

line 3: " Description: Retro groove color scheme for Vim[J

line 4: " Author: morhetz <morhetz@gmail.com>[J

line 5: " Source: https://github.com/morhetz/gruvbox[J

line 6: " Last Modified: 12 Aug 2017[J

line 7: " -----------------------------------------------------------------------------[J

line 8: [J

line 9: " Supporting code -------------------------------------------------------------[J

line 10: " Initialisation: {{{[J

line 11: [J

line 12: if version > 580[J

line 13:   hi clear[J

Searching for "syntax/syncolor.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim74/syntax)[J
fchdir() to previous dir[J
line 13: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim[J
continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/after/syntax/syncolor.vim"[J
line 14:   if exists("syntax_on")[J

line 15:     syntax reset[J

line 15: runtime! syntax/syncolor.vim[J

Searching for "syntax/syncolor.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim74/syntax)[J
fchdir() to previous dir[J
line 15: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi! link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi! link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi! link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi! link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi! link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi! link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi! link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi! link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi! link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi! link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi! link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi! link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi! link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi! link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi! link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi! link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi! link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi! link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi! link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi! link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi! link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi! link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi! link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi! link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim[J
continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/after/syntax/syncolor.vim"[J
line 16:   endif[J

line 17: endif[J

line 18: [J

line 19: let g:colors_name='gruvbox'[J

line 20: [J

line 21: if !(has('termguicolors') && &termguicolors) && !has('gui_running') && &t_Co != 256[J

line 22:   finish[J

line 23: endif[J

line 24: [J

line 25: " }}}[J

line 26: " Global Settings: {{{[J

line 27: [J

line 28: if !exists('g:gruvbox_bold')[J

line 29:   let g:gruvbox_bold=1[J

line 30: endif[J

line 31: if !exists('g:gruvbox_italic')[J

line 32:   if has('gui_running') || $TERM_ITALICS == 'true'[J

line 33:     let g:gruvbox_italic=1[J

line 34:   else[J

line 35:     let g:gruvbox_italic=0[J

line 36:   endif[J

line 37: endif[J

line 38: if !exists('g:gruvbox_undercurl')[J

line 39:   let g:gruvbox_undercurl=1[J

line 40: endif[J

line 41: if !exists('g:gruvbox_underline')[J

line 42:   let g:gruvbox_underline=1[J

line 43: endif[J

line 44: if !exists('g:gruvbox_inverse')[J

line 45:   let g:gruvbox_inverse=1[J

line 46: endif[J

line 47: [J

line 48: if !exists('g:gruvbox_guisp_fallback') || index(['fg', 'bg'], g:gruvbox_guisp_fallback) == -1[J

line 49:   let g:gruvbox_guisp_fallback='NONE'[J

line 50: endif[J

line 51: [J

line 52: if !exists('g:gruvbox_improved_strings')[J

line 53:   let g:gruvbox_improved_strings=0[J

line 54: endif[J

line 55: [J

line 56: if !exists('g:gruvbox_improved_warnings')[J

line 57:   let g:gruvbox_improved_warnings=0[J

line 58: endif[J

line 59: [J

line 60: if !exists('g:gruvbox_termcolors')[J

line 61:   let g:gruvbox_termcolors=256[J

line 62: endif[J

line 63: [J

line 64: if !exists('g:gruvbox_invert_indent_guides')[J

line 65:   let g:gruvbox_invert_indent_guides=0[J

line 66: endif[J

line 67: [J

line 68: if exists('g:gruvbox_contrast')[J

line 69:   echo 'g:gruvbox_contrast is deprecated; use g:gruvbox_contrast_light and g:gruvbox_contrast_dark instead'[J

line 70: endif[J

line 71: [J

line 72: if !exists('g:gruvbox_contrast_dark')[J

line 73:   let g:gruvbox_contrast_dark='medium'[J

line 74: endif[J

line 75: [J

line 76: if !exists('g:gruvbox_contrast_light')[J

line 77:   let g:gruvbox_contrast_light='medium'[J

line 78: endif[J

line 79: [J

line 80: let s:is_dark=(&background == 'dark')[J

line 81: [J

line 82: " }}}[J

line 83: " Palette: {{{[J

line 84: [J

line 85: " setup palette dictionary[J

line 86: let s:gb = {}[J

line 87: [J

line 88: " fill it with absolute colors[J

line 89: let s:gb.dark0_hard  = ['#1d2021', 234]     " 29-32-33[J

line 90: let s:gb.dark0       = ['#282828', 235]     " 40-40-40[J

line 91: let s:gb.dark0_soft  = ['#32302f', 236]     " 50-48-47[J

line 92: let s:gb.dark1       = ['#3c3836', 237]     " 60-56-54[J

line 93: let s:gb.dark2       = ['#504945', 239]     " 80-73-69[J

line 94: let s:gb.dark3       = ['#665c54', 241]     " 102-92-84[J

line 95: let s:gb.dark4       = ['#7c6f64', 243]     " 124-111-100[J

line 96: let s:gb.dark4_256   = ['#7c6f64', 243]     " 124-111-100[J

line 97: [J

line 98: let s:gb.gray_245    = ['#928374', 245]     " 146-131-116[J

line 99: let s:gb.gray_244    = ['#928374', 244]     " 146-131-116[J

line 100: [J

line 101: let s:gb.light0_hard = ['#f9f5d7', 230]     " 249-245-215[J

line 102: let s:gb.light0      = ['#fbf1c7', 229]     " 253-244-193[J

line 103: let s:gb.light0_soft = ['#f2e5bc', 228]     " 242-229-188[J

line 104: let s:gb.light1      = ['#ebdbb2', 223]     " 235-219-178[J

line 105: let s:gb.light2      = ['#d5c4a1', 250]     " 213-196-161[J

line 106: let s:gb.light3      = ['#bdae93', 248]     " 189-174-147[J

line 107: let s:gb.light4      = ['#a89984', 246]     " 168-153-132[J

line 108: let s:gb.light4_256  = ['#a89984', 246]     " 168-153-132[J

line 109: [J

line 110: let s:gb.bright_red     = ['#fb4934', 167]     " 251-73-52[J

line 111: let s:gb.bright_green   = ['#b8bb26', 142]     " 184-187-38[J

line 112: let s:gb.bright_yellow  = ['#fabd2f', 214]     " 250-189-47[J

line 113: let s:gb.bright_blue    = ['#83a598', 109]     " 131-165-152[J

line 114: let s:gb.bright_purple  = ['#d3869b', 175]     " 211-134-155[J

line 115: let s:gb.bright_aqua    = ['#8ec07c', 108]     " 142-192-124[J

line 116: let s:gb.bright_orange  = ['#fe8019', 208]     " 254-128-25[J

line 117: [J

line 118: let s:gb.neutral_red    = ['#cc241d', 124]     " 204-36-29[J

line 119: let s:gb.neutral_green  = ['#98971a', 106]     " 152-151-26[J

line 120: let s:gb.neutral_yellow = ['#d79921', 172]     " 215-153-33[J

line 121: let s:gb.neutral_blue   = ['#458588', 66]      " 69-133-136[J

line 122: let s:gb.neutral_purple = ['#b16286', 132]     " 177-98-134[J

line 123: let s:gb.neutral_aqua   = ['#689d6a', 72]      " 104-157-106[J

line 124: let s:gb.neutral_orange = ['#d65d0e', 166]     " 214-93-14[J

line 125: [J

line 126: let s:gb.faded_red      = ['#9d0006', 88]      " 157-0-6[J

line 127: let s:gb.faded_green    = ['#79740e', 100]     " 121-116-14[J

line 128: let s:gb.faded_yellow   = ['#b57614', 136]     " 181-118-20[J

line 129: let s:gb.faded_blue     = ['#076678', 24]      " 7-102-120[J

line 130: let s:gb.faded_purple   = ['#8f3f71', 96]      " 143-63-113[J

line 131: let s:gb.faded_aqua     = ['#427b58', 66]      " 66-123-88[J

line 132: let s:gb.faded_orange   = ['#af3a03', 130]     " 175-58-3[J

line 133: [J

line 134: " }}}[J

line 135: " Setup Emphasis: {{{[J

line 136: [J

line 137: let s:bold = 'bold,'[J

line 138: if g:gruvbox_bold == 0[J

line 139:   let s:bold = ''[J

line 140: endif[J

line 141: [J

line 142: let s:italic = 'italic,'[J

line 143: if g:gruvbox_italic == 0[J

line 144:   let s:italic = ''[J

line 145: endif[J

line 146: [J

line 147: let s:underline = 'underline,'[J

line 148: if g:gruvbox_underline == 0[J

line 149:   let s:underline = ''[J

line 150: endif[J

line 151: [J

line 152: let s:undercurl = 'undercurl,'[J

line 153: if g:gruvbox_undercurl == 0[J

line 154:   let s:undercurl = ''[J

line 155: endif[J

line 156: [J

line 157: let s:inverse = 'inverse,'[J

line 158: if g:gruvbox_inverse == 0[J

line 159:   let s:inverse = ''[J

line 160: endif[J

line 161: [J

line 162: " }}}[J

line 163: " Setup Colors: {{{[J

line 164: [J

line 165: let s:vim_bg = ['bg', 'bg'][J

line 166: let s:vim_fg = ['fg', 'fg'][J

line 167: let s:none = ['NONE', 'NONE'][J

line 168: [J

line 169: " determine relative colors[J

line 170: if s:is_dark[J

line 171:   let s:bg0  = s:gb.dark0[J

line 172:   if g:gruvbox_contrast_dark == 'soft'[J

line 173:     let s:bg0  = s:gb.dark0_soft[J

line 174:   elseif g:gruvbox_contrast_dark == 'hard'[J

line 175:     let s:bg0  = s:gb.dark0_hard[J

line 176:   endif[J

line 177: [J

line 178:   let s:bg1  = s:gb.dark1[J

line 179:   let s:bg2  = s:gb.dark2[J

line 180:   let s:bg3  = s:gb.dark3[J

line 181:   let s:bg4  = s:gb.dark4[J

line 182: [J

line 183:   let s:gray = s:gb.gray_245[J

line 184: [J

line 185:   let s:fg0 = s:gb.light0[J

line 186:   let s:fg1 = s:gb.light1[J

line 187:   let s:fg2 = s:gb.light2[J

line 188:   let s:fg3 = s:gb.light3[J

line 189:   let s:fg4 = s:gb.light4[J

line 190: [J

line 191:   let s:fg4_256 = s:gb.light4_256[J

line 192: [J

line 193:   let s:red    = s:gb.bright_red[J

line 194:   let s:green  = s:gb.bright_green[J

line 195:   let s:yellow = s:gb.bright_yellow[J

line 196:   let s:blue   = s:gb.bright_blue[J

line 197:   let s:purple = s:gb.bright_purple[J

line 198:   let s:aqua   = s:gb.bright_aqua[J

line 199:   let s:orange = s:gb.bright_orange[J

line 200: else[J

line 201:   let s:bg0  = s:gb.light0[J

line 202:   if g:gruvbox_contrast_light == 'soft'[J

line 203:     let s:bg0  = s:gb.light0_soft[J

line 204:   elseif g:gruvbox_contrast_light == 'hard'[J

line 205:     let s:bg0  = s:gb.light0_hard[J

line 206:   endif[J

line 207: [J

line 208:   let s:bg1  = s:gb.light1[J

line 209:   let s:bg2  = s:gb.light2[J

line 210:   let s:bg3  = s:gb.light3[J

line 211:   let s:bg4  = s:gb.light4[J

line 212: [J

line 213:   let s:gray = s:gb.gray_244[J

line 214: [J

line 215:   let s:fg0 = s:gb.dark0[J

line 216:   let s:fg1 = s:gb.dark1[J

line 217:   let s:fg2 = s:gb.dark2[J

line 218:   let s:fg3 = s:gb.dark3[J

line 219:   let s:fg4 = s:gb.dark4[J

line 220: [J

line 221:   let s:fg4_256 = s:gb.dark4_256[J

line 222: [J

line 223:   let s:red    = s:gb.faded_red[J

line 224:   let s:green  = s:gb.faded_green[J

line 225:   let s:yellow = s:gb.faded_yellow[J

line 226:   let s:blue   = s:gb.faded_blue[J

line 227:   let s:purple = s:gb.faded_purple[J

line 228:   let s:aqua   = s:gb.faded_aqua[J

line 229:   let s:orange = s:gb.faded_orange[J

line 230: endif[J

line 231: [J

line 232: " reset to 16 colors fallback[J

line 233: if g:gruvbox_termcolors == 16[J

line 234:   let s:bg0[1]    = 0[J

line 235:   let s:fg4[1]    = 7[J

line 236:   let s:gray[1]   = 8[J

line 237:   let s:red[1]    = 9[J

line 238:   let s:green[1]  = 10[J

line 239:   let s:yellow[1] = 11[J

line 240:   let s:blue[1]   = 12[J

line 241:   let s:purple[1] = 13[J

line 242:   let s:aqua[1]   = 14[J

line 243:   let s:fg1[1]    = 15[J

line 244: endif[J

line 245: [J

line 246: " save current relative colors back to palette dictionary[J

line 247: let s:gb.bg0 = s:bg0[J

line 248: let s:gb.bg1 = s:bg1[J

line 249: let s:gb.bg2 = s:bg2[J

line 250: let s:gb.bg3 = s:bg3[J

line 251: let s:gb.bg4 = s:bg4[J

line 252: [J

line 253: let s:gb.gray = s:gray[J

line 254: [J

line 255: let s:gb.fg0 = s:fg0[J

line 256: let s:gb.fg1 = s:fg1[J

line 257: let s:gb.fg2 = s:fg2[J

line 258: let s:gb.fg3 = s:fg3[J

line 259: let s:gb.fg4 = s:fg4[J

line 260: [J

line 261: let s:gb.fg4_256 = s:fg4_256[J

line 262: [J

line 263: let s:gb.red    = s:red[J

line 264: let s:gb.green  = s:green[J

line 265: let s:gb.yellow = s:yellow[J

line 266: let s:gb.blue   = s:blue[J

line 267: let s:gb.purple = s:purple[J

line 268: let s:gb.aqua   = s:aqua[J

line 269: let s:gb.orange = s:orange[J

line 270: [J

line 271: " }}}[J

line 272: " Setup Terminal Colors For Neovim: {{{[J

line 273: [J

line 274: if has('nvim')[J

line 275:   let g:terminal_color_0 = s:bg0[0][J

line 276:   let g:terminal_color_8 = s:gray[0][J

line 277: [J

line 278:   let g:terminal_color_1 = s:gb.neutral_red[0][J

line 279:   let g:terminal_color_9 = s:red[0][J

line 280: [J

line 281:   let g:terminal_color_2 = s:gb.neutral_green[0][J

line 282:   let g:terminal_color_10 = s:green[0][J

line 283: [J

line 284:   let g:terminal_color_3 = s:gb.neutral_yellow[0][J

line 285:   let g:terminal_color_11 = s:yellow[0][J

line 286: [J

line 287:   let g:terminal_color_4 = s:gb.neutral_blue[0][J

line 288:   let g:terminal_color_12 = s:blue[0][J

line 289: [J

line 290:   let g:terminal_color_5 = s:gb.neutral_purple[0][J

line 291:   let g:terminal_color_13 = s:purple[0][J

line 292: [J

line 293:   let g:terminal_color_6 = s:gb.neutral_aqua[0][J

line 294:   let g:terminal_color_14 = s:aqua[0][J

line 295: [J

line 296:   let g:terminal_color_7 = s:fg4[0][J

line 297:   let g:terminal_color_15 = s:fg1[0][J

line 298: endif[J

line 299: [J

line 300: " }}}[J

line 301: " Overload Setting: {{{[J

line 302: [J

line 303: let s:hls_cursor = s:orange[J

line 304: if exists('g:gruvbox_hls_cursor')[J

line 305:   let s:hls_cursor = get(s:gb, g:gruvbox_hls_cursor)[J

line 306: endif[J

line 307: [J

line 308: let s:number_column = s:none[J

line 309: if exists('g:gruvbox_number_column')[J

line 310:   let s:number_column = get(s:gb, g:gruvbox_number_column)[J

line 311: endif[J

line 312: [J

line 313: let s:sign_column = s:bg1[J

line 314: [J

line 316: if exists('g:gitgutter_override_sign_column_highlight') && g:gitgutter_override_sign_column_highlight == 1[J

line 317:   let s:sign_column = s:number_column[J

line 318: else[J

line 319:   let g:gitgutter_override_sign_column_highlight = 0[J

line 320: [J

line 321:   if exists('g:gruvbox_sign_column')[J

line 322:     let s:sign_column = get(s:gb, g:gruvbox_sign_column)[J

line 323:   endif[J

line 324: endif[J

line 325: [J

line 326: let s:color_column = s:bg1[J

line 327: if exists('g:gruvbox_color_column')[J

line 328:   let s:color_column = get(s:gb, g:gruvbox_color_column)[J

line 329: endif[J

line 330: [J

line 331: let s:vert_split = s:bg0[J

line 332: if exists('g:gruvbox_vert_split')[J

line 333:   let s:vert_split = get(s:gb, g:gruvbox_vert_split)[J

line 334: endif[J

line 335: [J

line 336: let s:invert_signs = ''[J

line 337: if exists('g:gruvbox_invert_signs')[J

line 338:   if g:gruvbox_invert_signs == 1[J

line 339:     let s:invert_signs = s:inverse[J

line 340:   endif[J

line 341: endif[J

line 342: [J

line 343: let s:invert_selection = s:inverse[J

line 344: if exists('g:gruvbox_invert_selection')[J

line 345:   if g:gruvbox_invert_selection == 0[J

line 346:     let s:invert_selection = ''[J

line 347:   endif[J

line 348: endif[J

line 349: [J

line 350: let s:invert_tabline = ''[J

line 351: if exists('g:gruvbox_invert_tabline')[J

line 352:   if g:gruvbox_invert_tabline == 1[J

line 353:     let s:invert_tabline = s:inverse[J

line 354:   endif[J

line 355: endif[J

line 356: [J

line 357: let s:italicize_comments = s:italic[J

line 358: if exists('g:gruvbox_italicize_comments')[J

line 359:   if g:gruvbox_italicize_comments == 0[J

line 360:     let s:italicize_comments = ''[J

line 361:   endif[J

line 362: endif[J

line 363: [J

line 364: let s:italicize_strings = ''[J

line 365: if exists('g:gruvbox_italicize_strings')[J

line 366:   if g:gruvbox_italicize_strings == 1[J

line 367:     let s:italicize_strings = s:italic[J

line 368:   endif[J

line 369: endif[J

line 370: [J

line 371: " }}}[J

line 372: " Highlighting Function: {{{[J

line 373: [J

line 374: function! s:HL(group, fg, ...)[J

line 419: [J

line 420: " }}}[J

line 421: " Gruvbox Hi Groups: {{{[J

line 422: [J

line 423: " memoize common hi groups[J

line 424: call s:HL('GruvboxFg0', s:fg0)[J

calling function <SNR>13_HL[J('GruvboxFg0', ['#282828', 235])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg0 guifg=#282828 ctermfg=235 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 425: call s:HL('GruvboxFg1', s:fg1)[J

calling function <SNR>13_HL[J('GruvboxFg1', ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg1 guifg=#3c3836 ctermfg=237 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 426: call s:HL('GruvboxFg2', s:fg2)[J

calling function <SNR>13_HL[J('GruvboxFg2', ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg2 guifg=#504945 ctermfg=239 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 427: call s:HL('GruvboxFg3', s:fg3)[J

calling function <SNR>13_HL[J('GruvboxFg3', ['#665c54', 241])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg3 guifg=#665c54 ctermfg=241 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 428: call s:HL('GruvboxFg4', s:fg4)[J

calling function <SNR>13_HL[J('GruvboxFg4', ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg4 guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 429: call s:HL('GruvboxGray', s:gray)[J

calling function <SNR>13_HL[J('GruvboxGray', ['#928374', 244])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxGray guifg=#928374 ctermfg=244 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 430: call s:HL('GruvboxBg0', s:bg0)[J

calling function <SNR>13_HL[J('GruvboxBg0', ['#fbf1c7', 229])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg0 guifg=#fbf1c7 ctermfg=229 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 431: call s:HL('GruvboxBg1', s:bg1)[J

calling function <SNR>13_HL[J('GruvboxBg1', ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg1 guifg=#ebdbb2 ctermfg=223 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 432: call s:HL('GruvboxBg2', s:bg2)[J

calling function <SNR>13_HL[J('GruvboxBg2', ['#d5c4a1', 250])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg2 guifg=#d5c4a1 ctermfg=250 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 433: call s:HL('GruvboxBg3', s:bg3)[J

calling function <SNR>13_HL[J('GruvboxBg3', ['#bdae93', 248])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg3 guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 434: call s:HL('GruvboxBg4', s:bg4)[J

calling function <SNR>13_HL[J('GruvboxBg4', ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg4 guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 435: [J

line 436: call s:HL('GruvboxRed', s:red)[J

calling function <SNR>13_HL[J('GruvboxRed', ['#9d0006', 88])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxRed guifg=#9d0006 ctermfg=88 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 437: call s:HL('GruvboxRedBold', s:red, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxRedBold', ['#9d0006', 88], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxRedBold guifg=#9d0006 ctermfg=88 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 438: call s:HL('GruvboxGreen', s:green)[J

calling function <SNR>13_HL[J('GruvboxGreen', ['#79740e', 100])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxGreen guifg=#79740e ctermfg=100 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 439: call s:HL('GruvboxGreenBold', s:green, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxGreenBold', ['#79740e', 100], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxGreenBold guifg=#79740e ctermfg=100 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 440: call s:HL('GruvboxYellow', s:yellow)[J

calling function <SNR>13_HL[J('GruvboxYellow', ['#b57614', 136])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxYellow guifg=#b57614 ctermfg=136 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 441: call s:HL('GruvboxYellowBold', s:yellow, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxYellowBold', ['#b57614', 136], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxYellowBold guifg=#b57614 ctermfg=136 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 442: call s:HL('GruvboxBlue', s:blue)[J

calling function <SNR>13_HL[J('GruvboxBlue', ['#076678', 24])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBlue guifg=#076678 ctermfg=24 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 443: call s:HL('GruvboxBlueBold', s:blue, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxBlueBold', ['#076678', 24], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBlueBold guifg=#076678 ctermfg=24 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 444: call s:HL('GruvboxPurple', s:purple)[J

calling function <SNR>13_HL[J('GruvboxPurple', ['#8f3f71', 96])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxPurple guifg=#8f3f71 ctermfg=96 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 445: call s:HL('GruvboxPurpleBold', s:purple, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxPurpleBold', ['#8f3f71', 96], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxPurpleBold guifg=#8f3f71 ctermfg=96 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 446: call s:HL('GruvboxAqua', s:aqua)[J

calling function <SNR>13_HL[J('GruvboxAqua', ['#427b58', 66])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxAqua guifg=#427b58 ctermfg=66 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 447: call s:HL('GruvboxAquaBold', s:aqua, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxAquaBold', ['#427b58', 66], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxAquaBold guifg=#427b58 ctermfg=66 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 448: call s:HL('GruvboxOrange', s:orange)[J

calling function <SNR>13_HL[J('GruvboxOrange', ['#af3a03', 130])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxOrange guifg=#af3a03 ctermfg=130 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 449: call s:HL('GruvboxOrangeBold', s:orange, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxOrangeBold', ['#af3a03', 130], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxOrangeBold guifg=#af3a03 ctermfg=130 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 450: [J

line 451: call s:HL('GruvboxRedSign', s:red, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxRedSign', ['#9d0006', 88], ['#ebdbb2', 223], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxRedSign guifg=#9d0006 ctermfg=88 guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 452: call s:HL('GruvboxGreenSign', s:green, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxGreenSign', ['#79740e', 100], ['#ebdbb2', 223], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxGreenSign guifg=#79740e ctermfg=100 guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 453: call s:HL('GruvboxYellowSign', s:yellow, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxYellowSign', ['#b57614', 136], ['#ebdbb2', 223], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxYellowSign guifg=#b57614 ctermfg=136 guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 454: call s:HL('GruvboxBlueSign', s:blue, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxBlueSign', ['#076678', 24], ['#ebdbb2', 223], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBlueSign guifg=#076678 ctermfg=24 guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 455: call s:HL('GruvboxPurpleSign', s:purple, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxPurpleSign', ['#8f3f71', 96], ['#ebdbb2', 223], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxPurpleSign guifg=#8f3f71 ctermfg=96 guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 456: call s:HL('GruvboxAquaSign', s:aqua, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxAquaSign', ['#427b58', 66], ['#ebdbb2', 223], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxAquaSign guifg=#427b58 ctermfg=66 guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 457: [J

line 458: " }}}[J

line 459: [J

line 460: " Vanilla colorscheme ---------------------------------------------------------[J

line 461: " General UI: {{{[J

line 462: [J

line 463: " Normal text[J

line 464: call s:HL('Normal', s:fg1, s:bg0)[J

calling function <SNR>13_HL[J('Normal', ['#3c3836', 237], ['#fbf1c7', 229])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Normal guifg=#3c3836 ctermfg=237 guibg=#fbf1c7 ctermbg=229 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 465: [J

line 466: " Correct background (see issue #7):[J

line 467: " --- Problem with changing between dark and light on 256 color terminal[J

line 468: " --- https://github.com/morhetz/gruvbox/issues/7[J

line 469: if s:is_dark[J

line 470:   set background=dark[J

line 471: else[J

line 472:   set background=light[J

line 473: endif[J

line 474: [J

line 475: if version >= 700[J

line 476:   " Screen line that the cursor is[J

line 477:   call s:HL('CursorLine',   s:none, s:bg1)[J

calling function <SNR>13_HL[J('CursorLine', ['NONE', 'NONE'], ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CursorLine guifg=NONE ctermfg=NONE guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 478:   " Screen column that the cursor is[J

line 479:   hi! link CursorColumn CursorLine[J

line 480: [J

line 481:   " Tab pages line filler[J

line 482:   call s:HL('TabLineFill', s:bg4, s:bg1, s:invert_tabline)[J

calling function <SNR>13_HL[J('TabLineFill', ['#a89984', 246], ['#ebdbb2', 223], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi TabLineFill guifg=#a89984 ctermfg=246 guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 483:   " Active tab page label[J

line 484:   call s:HL('TabLineSel', s:green, s:bg1, s:invert_tabline)[J

calling function <SNR>13_HL[J('TabLineSel', ['#79740e', 100], ['#ebdbb2', 223], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi TabLineSel guifg=#79740e ctermfg=100 guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 485:   " Not active tab page label[J

line 486:   hi! link TabLine TabLineFill[J

line 487: [J

line 488:   " Match paired bracket under the cursor[J

line 489:   call s:HL('MatchParen', s:none, s:bg3, s:bold)[J

calling function <SNR>13_HL[J('MatchParen', ['NONE', 'NONE'], ['#bdae93', 248], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi MatchParen guifg=NONE ctermfg=NONE guibg=#bdae93 ctermbg=248 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 490: endif[J

line 491: [J

line 492: if version >= 703[J

line 493:   " Highlighted screen columns[J

line 494:   call s:HL('ColorColumn',  s:none, s:color_column)[J

calling function <SNR>13_HL[J('ColorColumn', ['NONE', 'NONE'], ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ColorColumn guifg=NONE ctermfg=NONE guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 495: [J

line 496:   " Concealed element: \lambda → λ[J

line 497:   call s:HL('Conceal', s:blue, s:none)[J

calling function <SNR>13_HL[J('Conceal', ['#076678', 24], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Conceal guifg=#076678 ctermfg=24 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 498: [J

line 499:   " Line number of CursorLine[J

line 500:   call s:HL('CursorLineNr', s:yellow, s:bg1)[J

calling function <SNR>13_HL[J('CursorLineNr', ['#b57614', 136], ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CursorLineNr guifg=#b57614 ctermfg=136 guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 501: endif[J

line 502: [J

line 503: hi! link NonText GruvboxBg2[J

line 504: hi! link SpecialKey GruvboxBg2[J

line 505: [J

line 506: call s:HL('Visual',    s:none,  s:bg3, s:invert_selection)[J

calling function <SNR>13_HL[J('Visual', ['NONE', 'NONE'], ['#bdae93', 248], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Visual guifg=NONE ctermfg=NONE guibg=#bdae93 ctermbg=248 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 507: hi! link VisualNOS Visual[J

line 508: [J

line 509: call s:HL('Search',    s:yellow, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('Search', ['#b57614', 136], ['#fbf1c7', 229], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Search guifg=#b57614 ctermfg=136 guibg=#fbf1c7 ctermbg=229 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 510: call s:HL('IncSearch', s:hls_cursor, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('IncSearch', ['#af3a03', 130], ['#fbf1c7', 229], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi IncSearch guifg=#af3a03 ctermfg=130 guibg=#fbf1c7 ctermbg=229 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 511: [J

line 512: call s:HL('Underlined', s:blue, s:none, s:underline)[J

calling function <SNR>13_HL[J('Underlined', ['#076678', 24], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Underlined guifg=#076678 ctermfg=24 guibg=NONE ctermbg=NONE gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 513: [J

line 514: call s:HL('StatusLine',   s:bg2, s:fg1, s:inverse)[J

calling function <SNR>13_HL[J('StatusLine', ['#d5c4a1', 250], ['#3c3836', 237], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi StatusLine guifg=#d5c4a1 ctermfg=250 guibg=#3c3836 ctermbg=237 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 515: call s:HL('StatusLineNC', s:bg1, s:fg4, s:inverse)[J

calling function <SNR>13_HL[J('StatusLineNC', ['#ebdbb2', 223], ['#7c6f64', 243], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi StatusLineNC guifg=#ebdbb2 ctermfg=223 guibg=#7c6f64 ctermbg=243 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 516: [J

line 517: " The column separating vertically split windows[J

line 518: call s:HL('VertSplit', s:bg3, s:vert_split)[J

calling function <SNR>13_HL[J('VertSplit', ['#bdae93', 248], ['#fbf1c7', 229])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi VertSplit guifg=#bdae93 ctermfg=248 guibg=#fbf1c7 ctermbg=229 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 519: [J

line 520: " Current match in wildmenu completion[J

line 521: call s:HL('WildMenu', s:blue, s:bg2, s:bold)[J

calling function <SNR>13_HL[J('WildMenu', ['#076678', 24], ['#d5c4a1', 250], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi WildMenu guifg=#076678 ctermfg=24 guibg=#d5c4a1 ctermbg=250 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 522: [J

line 523: " Directory names, special names in listing[J

line 524: hi! link Directory GruvboxGreenBold[J

line 525: [J

line 526: " Titles for output from :set all, :autocmd, etc.[J

line 527: hi! link Title GruvboxGreenBold[J

line 528: [J

line 529: " Error messages on the command line[J

line 530: call s:HL('ErrorMsg',   s:bg0, s:red, s:bold)[J

calling function <SNR>13_HL[J('ErrorMsg', ['#fbf1c7', 229], ['#9d0006', 88], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ErrorMsg guifg=#fbf1c7 ctermfg=229 guibg=#9d0006 ctermbg=88 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 531: " More prompt: -- More --[J

line 532: hi! link MoreMsg GruvboxYellowBold[J

line 533: " Current mode message: -- INSERT --[J

line 534: hi! link ModeMsg GruvboxYellowBold[J

line 535: " 'Press enter' prompt and yes/no questions[J

line 536: hi! link Question GruvboxOrangeBold[J

line 537: " Warning messages[J

line 538: hi! link WarningMsg GruvboxRedBold[J

line 539: [J

line 540: " }}}[J

line 541: " Gutter: {{{[J

line 542: [J

line 543: " Line number for :number and :# commands[J

line 544: call s:HL('LineNr', s:bg4, s:number_column)[J

calling function <SNR>13_HL[J('LineNr', ['#a89984', 246], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi LineNr guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 545: [J

line 546: " Column where signs are displayed[J

line 547: call s:HL('SignColumn', s:none, s:sign_column)[J

calling function <SNR>13_HL[J('SignColumn', ['NONE', 'NONE'], ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SignColumn guifg=NONE ctermfg=NONE guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 548: [J

line 549: " Line used for closed folds[J

line 550: call s:HL('Folded', s:gray, s:bg1, s:italic)[J

calling function <SNR>13_HL[J('Folded', ['#928374', 244], ['#ebdbb2', 223], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Folded guifg=#928374 ctermfg=244 guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 551: " Column where folds are displayed[J

line 552: call s:HL('FoldColumn', s:gray, s:bg1)[J

calling function <SNR>13_HL[J('FoldColumn', ['#928374', 244], ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi FoldColumn guifg=#928374 ctermfg=244 guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 553: [J

line 554: " }}}[J

line 555: " Cursor: {{{[J

line 556: [J

line 557: " Character under cursor[J

line 558: call s:HL('Cursor', s:none, s:none, s:inverse)[J

calling function <SNR>13_HL[J('Cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 559: " Visual mode cursor, selection[J

line 560: hi! link vCursor Cursor[J

line 561: " Input moder cursor[J

line 562: hi! link iCursor Cursor[J

line 563: " Language mapping cursor[J

line 564: hi! link lCursor Cursor[J

line 565: [J

line 566: " }}}[J

line 567: " Syntax Highlighting: {{{[J

line 568: [J

line 569: if g:gruvbox_improved_strings == 0[J

line 570:   hi! link Special GruvboxOrange[J

line 571: else[J

line 572:   call s:HL('Special', s:orange, s:bg1, s:italicize_strings)[J

line 573: endif[J

line 574: [J

line 575: call s:HL('Comment', s:gray, s:none, s:italicize_comments)[J

calling function <SNR>13_HL[J('Comment', ['#928374', 244], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Comment guifg=#928374 ctermfg=244 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 576: call s:HL('Todo', s:vim_fg, s:vim_bg, s:bold . s:italic)[J

calling function <SNR>13_HL[J('Todo', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Todo guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 577: call s:HL('Error', s:red, s:vim_bg, s:bold . s:inverse)[J

calling function <SNR>13_HL[J('Error', ['#9d0006', 88], ['bg', 'bg'], 'bold,inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Error guifg=#9d0006 ctermfg=88 guibg=bg ctermbg=bg gui=bold,inverse cterm=bold,inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 578: [J

line 579: " Generic statement[J

line 580: hi! link Statement GruvboxRed[J

line 581: " if, then, else, endif, swicth, etc.[J

line 582: hi! link Conditional GruvboxRed[J

line 583: " for, do, while, etc.[J

line 584: hi! link Repeat GruvboxRed[J

line 585: " case, default, etc.[J

line 586: hi! link Label GruvboxRed[J

line 587: " try, catch, throw[J

line 588: hi! link Exception GruvboxRed[J

line 589: " sizeof, "+", "*", etc.[J

line 590: hi! link Operator Normal[J

line 591: " Any other keyword[J

line 592: hi! link Keyword GruvboxRed[J

line 593: [J

line 594: " Variable name[J

line 595: hi! link Identifier GruvboxBlue[J

line 596: " Function name[J

line 597: hi! link Function GruvboxGreenBold[J

line 598: [J

line 599: " Generic preprocessor[J

line 600: hi! link PreProc GruvboxAqua[J

line 601: " Preprocessor #include[J

line 602: hi! link Include GruvboxAqua[J

line 603: " Preprocessor #define[J

line 604: hi! link Define GruvboxAqua[J

line 605: " Same as Define[J

line 606: hi! link Macro GruvboxAqua[J

line 607: " Preprocessor #if, #else, #endif, etc.[J

line 608: hi! link PreCondit GruvboxAqua[J

line 609: [J

line 610: " Generic constant[J

line 611: hi! link Constant GruvboxPurple[J

line 612: " Character constant: 'c', '/n'[J

line 613: hi! link Character GruvboxPurple[J

line 614: " String constant: "this is a string"[J

line 615: if g:gruvbox_improved_strings == 0[J

line 616:   call s:HL('String',  s:green, s:none, s:italicize_strings)[J

calling function <SNR>13_HL[J('String', ['#79740e', 100], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi String guifg=#79740e ctermfg=100 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 617: else[J

line 618:   call s:HL('String',  s:fg1, s:bg1, s:italicize_strings)[J

line 619: endif[J

line 620: " Boolean constant: TRUE, false[J

line 621: hi! link Boolean GruvboxPurple[J

line 622: " Number constant: 234, 0xff[J

line 623: hi! link Number GruvboxPurple[J

line 624: " Floating point constant: 2.3e10[J

line 625: hi! link Float GruvboxPurple[J

line 626: [J

line 627: " Generic type[J

line 628: hi! link Type GruvboxYellow[J

line 629: " static, register, volatile, etc[J

line 630: hi! link StorageClass GruvboxOrange[J

line 631: " struct, union, enum, etc.[J

line 632: hi! link Structure GruvboxAqua[J

line 633: " typedef[J

line 634: hi! link Typedef GruvboxYellow[J

line 635: [J

line 636: " }}}[J

line 637: " Completion Menu: {{{[J

line 638: [J

line 639: if version >= 700[J

line 640:   " Popup menu: normal item[J

line 641:   call s:HL('Pmenu', s:fg1, s:bg2)[J

calling function <SNR>13_HL[J('Pmenu', ['#3c3836', 237], ['#d5c4a1', 250])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Pmenu guifg=#3c3836 ctermfg=237 guibg=#d5c4a1 ctermbg=250 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 642:   " Popup menu: selected item[J

line 643:   call s:HL('PmenuSel', s:bg2, s:blue, s:bold)[J

calling function <SNR>13_HL[J('PmenuSel', ['#d5c4a1', 250], ['#076678', 24], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi PmenuSel guifg=#d5c4a1 ctermfg=250 guibg=#076678 ctermbg=24 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 644:   " Popup menu: scrollbar[J

line 645:   call s:HL('PmenuSbar', s:none, s:bg2)[J

calling function <SNR>13_HL[J('PmenuSbar', ['NONE', 'NONE'], ['#d5c4a1', 250])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi PmenuSbar guifg=NONE ctermfg=NONE guibg=#d5c4a1 ctermbg=250 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 646:   " Popup menu: scrollbar thumb[J

line 647:   call s:HL('PmenuThumb', s:none, s:bg4)[J

calling function <SNR>13_HL[J('PmenuThumb', ['NONE', 'NONE'], ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi PmenuThumb guifg=NONE ctermfg=NONE guibg=#a89984 ctermbg=246 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 648: endif[J

line 649: [J

line 650: " }}}[J

line 651: " Diffs: {{{[J

line 652: [J

line 653: call s:HL('DiffDelete', s:red, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('DiffDelete', ['#9d0006', 88], ['#fbf1c7', 229], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi DiffDelete guifg=#9d0006 ctermfg=88 guibg=#fbf1c7 ctermbg=229 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 654: call s:HL('DiffAdd',    s:green, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('DiffAdd', ['#79740e', 100], ['#fbf1c7', 229], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi DiffAdd guifg=#79740e ctermfg=100 guibg=#fbf1c7 ctermbg=229 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 655: "call s:HL('DiffChange', s:bg0, s:blue)[J

line 656: "call s:HL('DiffText',   s:bg0, s:yellow)[J

line 657: [J

line 658: " Alternative setting[J

line 659: call s:HL('DiffChange', s:aqua, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('DiffChange', ['#427b58', 66], ['#fbf1c7', 229], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi DiffChange guifg=#427b58 ctermfg=66 guibg=#fbf1c7 ctermbg=229 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 660: call s:HL('DiffText',   s:yellow, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('DiffText', ['#b57614', 136], ['#fbf1c7', 229], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi DiffText guifg=#b57614 ctermfg=136 guibg=#fbf1c7 ctermbg=229 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 661: [J

line 662: " }}}[J

line 663: " Spelling: {{{[J

line 664: [J

line 665: if has("spell")[J

line 666:   " Not capitalised word, or compile warnings[J

line 667:   if g:gruvbox_improved_warnings == 0[J

line 668:     call s:HL('SpellCap',   s:none, s:none, s:undercurl, s:red)[J

calling function <SNR>13_HL[J('SpellCap', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#9d0006', 88])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SpellCap guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#9d0006[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 669:   else[J

line 670:     call s:HL('SpellCap',   s:green, s:none, s:bold . s:italic)[J

line 671:   endif[J

line 672:   " Not recognized word[J

line 673:   call s:HL('SpellBad',   s:none, s:none, s:undercurl, s:blue)[J

calling function <SNR>13_HL[J('SpellBad', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#076678', 24])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SpellBad guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#076678[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 674:   " Wrong spelling for selected region[J

line 675:   call s:HL('SpellLocal', s:none, s:none, s:undercurl, s:aqua)[J

calling function <SNR>13_HL[J('SpellLocal', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#427b58', 66])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SpellLocal guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#427b58[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 676:   " Rare word[J

line 677:   call s:HL('SpellRare',  s:none, s:none, s:undercurl, s:purple)[J

calling function <SNR>13_HL[J('SpellRare', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#8f3f71', 96])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SpellRare guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#8f3f71[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 678: endif[J

line 679: [J

line 680: " }}}[J

line 681: [J

line 682: " Plugin specific -------------------------------------------------------------[J

line 683: " EasyMotion: {{{[J

line 684: [J

line 685: hi! link EasyMotionTarget Search[J

line 686: hi! link EasyMotionShade Comment[J

line 687: [J

line 688: " }}}[J

line 689: " Sneak: {{{[J

line 690: [J

line 691: hi! link Sneak Search[J

line 692: hi! link SneakLabel Search[J

line 693: [J

line 694: " }}}[J

line 695: " Indent Guides: {{{[J

line 696: [J

line 697: if !exists('g:indent_guides_auto_colors')[J

line 698:   let g:indent_guides_auto_colors = 0[J

line 699: endif[J

line 700: [J

line 701: if g:indent_guides_auto_colors == 0[J

line 702:   if g:gruvbox_invert_indent_guides == 0[J

line 703:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2)[J

calling function <SNR>13_HL[J('IndentGuidesOdd', ['bg', 'bg'], ['#d5c4a1', 250])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi IndentGuidesOdd guifg=bg ctermfg=bg guibg=#d5c4a1 ctermbg=250 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 704:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg1)[J

calling function <SNR>13_HL[J('IndentGuidesEven', ['bg', 'bg'], ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi IndentGuidesEven guifg=bg ctermfg=bg guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 705:   else[J

line 706:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2, s:inverse)[J

line 707:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg3, s:inverse)[J

line 708:   endif[J

line 709: endif[J

line 710: [J

line 711: " }}}[J

line 712: " IndentLine: {{{[J

line 713: [J

line 714: if !exists('g:indentLine_color_term')[J

line 715:   let g:indentLine_color_term = s:bg2[1][J

line 716: endif[J

line 717: if !exists('g:indentLine_color_gui')[J

line 718:   let g:indentLine_color_gui = s:bg2[0][J

line 719: endif[J

line 720: [J

line 721: " }}}[J

line 722: " Rainbow Parentheses: {{{[J

line 723: [J

line 724: if !exists('g:rbpt_colorpairs')[J

line 729:   let g:rbpt_colorpairs = [ ['blue', '#458588'], ['magenta', '#b16286'], ['red',  '#cc241d'], ['166',     '#d65d0e'] ][J

line 730: endif[J

line 731: [J

line 732: let g:rainbow_guifgs = [ '#d65d0e', '#cc241d', '#b16286', '#458588' ][J

line 733: let g:rainbow_ctermfgs = [ '166', 'red', 'magenta', 'blue' ][J

line 734: [J

line 735: if !exists('g:rainbow_conf')[J

line 736:    let g:rainbow_conf = {}[J

line 737: endif[J

line 738: if !has_key(g:rainbow_conf, 'guifgs')[J

line 739:    let g:rainbow_conf['guifgs'] = g:rainbow_guifgs[J

line 740: endif[J

line 741: if !has_key(g:rainbow_conf, 'ctermfgs')[J

line 742:    let g:rainbow_conf['ctermfgs'] = g:rainbow_ctermfgs[J

line 743: endif[J

line 744: [J

line 745: let g:niji_dark_colours = g:rbpt_colorpairs[J

line 746: let g:niji_light_colours = g:rbpt_colorpairs[J

line 747: [J

line 748: "}}}[J

line 749: " GitGutter: {{{[J

line 750: [J

line 751: hi! link GitGutterAdd GruvboxGreenSign[J

line 752: hi! link GitGutterChange GruvboxAquaSign[J

line 753: hi! link GitGutterDelete GruvboxRedSign[J

line 754: hi! link GitGutterChangeDelete GruvboxAquaSign[J

line 755: [J

line 756: " }}}[J

line 757: " GitCommit: "{{{[J

line 758: [J

line 759: hi! link gitcommitSelectedFile GruvboxGreen[J

line 760: hi! link gitcommitDiscardedFile GruvboxRed[J

line 761: [J

line 762: " }}}[J

line 763: " Signify: {{{[J

line 764: [J

line 765: hi! link SignifySignAdd GruvboxGreenSign[J

line 766: hi! link SignifySignChange GruvboxAquaSign[J

line 767: hi! link SignifySignDelete GruvboxRedSign[J

line 768: [J

line 769: " }}}[J

line 770: " Syntastic: {{{[J

line 771: [J

line 772: call s:HL('SyntasticError', s:none, s:none, s:undercurl, s:red)[J

calling function <SNR>13_HL[J('SyntasticError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#9d0006', 88])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SyntasticError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#9d0006[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 773: call s:HL('SyntasticWarning', s:none, s:none, s:undercurl, s:yellow)[J

calling function <SNR>13_HL[J('SyntasticWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#b57614', 136])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SyntasticWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#b57614[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 774: [J

line 775: hi! link SyntasticErrorSign GruvboxRedSign[J

line 776: hi! link SyntasticWarningSign GruvboxYellowSign[J

line 777: [J

line 778: " }}}[J

line 779: " Signature: {{{[J

line 780: hi! link SignatureMarkText   GruvboxBlueSign[J

line 781: hi! link SignatureMarkerText GruvboxPurpleSign[J

line 782: [J

line 783: " }}}[J

line 784: " ShowMarks: {{{[J

line 785: [J

line 786: hi! link ShowMarksHLl GruvboxBlueSign[J

line 787: hi! link ShowMarksHLu GruvboxBlueSign[J

line 788: hi! link ShowMarksHLo GruvboxBlueSign[J

line 789: hi! link ShowMarksHLm GruvboxBlueSign[J

line 790: [J

line 791: " }}}[J

line 792: " CtrlP: {{{[J

line 793: [J

line 794: hi! link CtrlPMatch GruvboxYellow[J

line 795: hi! link CtrlPNoEntries GruvboxRed[J

line 796: hi! link CtrlPPrtBase GruvboxBg2[J

line 797: hi! link CtrlPPrtCursor GruvboxBlue[J

line 798: hi! link CtrlPLinePre GruvboxBg2[J

line 799: [J

line 800: call s:HL('CtrlPMode1', s:blue, s:bg2, s:bold)[J

calling function <SNR>13_HL[J('CtrlPMode1', ['#076678', 24], ['#d5c4a1', 250], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CtrlPMode1 guifg=#076678 ctermfg=24 guibg=#d5c4a1 ctermbg=250 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 801: call s:HL('CtrlPMode2', s:bg0, s:blue, s:bold)[J

calling function <SNR>13_HL[J('CtrlPMode2', ['#fbf1c7', 229], ['#076678', 24], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CtrlPMode2 guifg=#fbf1c7 ctermfg=229 guibg=#076678 ctermbg=24 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 802: call s:HL('CtrlPStats', s:fg4, s:bg2, s:bold)[J

calling function <SNR>13_HL[J('CtrlPStats', ['#7c6f64', 243], ['#d5c4a1', 250], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CtrlPStats guifg=#7c6f64 ctermfg=243 guibg=#d5c4a1 ctermbg=250 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 803: [J

line 804: " }}}[J

line 805: " Startify: {{{[J

line 806: [J

line 807: hi! link StartifyBracket GruvboxFg3[J

line 808: hi! link StartifyFile GruvboxFg1[J

line 809: hi! link StartifyNumber GruvboxBlue[J

line 810: hi! link StartifyPath GruvboxGray[J

line 811: hi! link StartifySlash GruvboxGray[J

line 812: hi! link StartifySection GruvboxYellow[J

line 813: hi! link StartifySpecial GruvboxBg2[J

line 814: hi! link StartifyHeader GruvboxOrange[J

line 815: hi! link StartifyFooter GruvboxBg2[J

line 816: [J

line 817: " }}}[J

line 818: " Vimshell: {{{[J

line 819: [J

line 825: let g:vimshell_escape_colors = [ s:bg4[0], s:red[0], s:green[0], s:yellow[0], s:blue[0], s:purple[0], s:aqua[0], s:fg4[0], s:bg0[0], s:red[0], s:green[0], s:orange[0], s:blue[0], s:purple[0], s:aqua[0], s:fg0[0] ][J

line 826: [J

line 827: " }}}[J

line 828: " BufTabLine: {{{[J

line 829: [J

line 830: call s:HL('BufTabLineCurrent', s:bg0, s:fg4)[J

calling function <SNR>13_HL[J('BufTabLineCurrent', ['#fbf1c7', 229], ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi BufTabLineCurrent guifg=#fbf1c7 ctermfg=229 guibg=#7c6f64 ctermbg=243 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 831: call s:HL('BufTabLineActive', s:fg4, s:bg2)[J

calling function <SNR>13_HL[J('BufTabLineActive', ['#7c6f64', 243], ['#d5c4a1', 250])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi BufTabLineActive guifg=#7c6f64 ctermfg=243 guibg=#d5c4a1 ctermbg=250 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 832: call s:HL('BufTabLineHidden', s:bg4, s:bg1)[J

calling function <SNR>13_HL[J('BufTabLineHidden', ['#a89984', 246], ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi BufTabLineHidden guifg=#a89984 ctermfg=246 guibg=#ebdbb2 ctermbg=223 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 833: call s:HL('BufTabLineFill', s:bg0, s:bg0)[J

calling function <SNR>13_HL[J('BufTabLineFill', ['#fbf1c7', 229], ['#fbf1c7', 229])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi BufTabLineFill guifg=#fbf1c7 ctermfg=229 guibg=#fbf1c7 ctermbg=229 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 834: [J

line 835: " }}}[J

line 836: " Asynchronous Lint Engine: {{{[J

line 837: [J

line 838: call s:HL('ALEError', s:none, s:none, s:undercurl, s:red)[J

calling function <SNR>13_HL[J('ALEError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#9d0006', 88])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ALEError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#9d0006[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 839: call s:HL('ALEWarning', s:none, s:none, s:undercurl, s:yellow)[J

calling function <SNR>13_HL[J('ALEWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#b57614', 136])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ALEWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#b57614[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 840: call s:HL('ALEInfo', s:none, s:none, s:undercurl, s:blue)[J

calling function <SNR>13_HL[J('ALEInfo', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#076678', 24])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ALEInfo guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#076678[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 841: [J

line 842: hi! link ALEErrorSign GruvboxRedSign[J

line 843: hi! link ALEWarningSign GruvboxYellowSign[J

line 844: hi! link ALEInfoSign GruvboxBlueSign[J

line 845: [J

line 846: " }}}[J

line 847: " Dirvish: {{{[J

line 848: [J

line 849: hi! link DirvishPathTail GruvboxAqua[J

line 850: hi! link DirvishArg GruvboxYellow[J

line 851: [J

line 852: " }}}[J

line 853: " Netrw: {{{[J

line 854: [J

line 855: hi! link netrwDir GruvboxAqua[J

line 856: hi! link netrwClassify GruvboxAqua[J

line 857: hi! link netrwLink GruvboxGray[J

line 858: hi! link netrwSymLink GruvboxFg1[J

line 859: hi! link netrwExe GruvboxYellow[J

line 860: hi! link netrwComment GruvboxGray[J

line 861: hi! link netrwList GruvboxBlue[J

line 862: hi! link netrwHelpCmd GruvboxAqua[J

line 863: hi! link netrwCmdSep GruvboxFg3[J

line 864: hi! link netrwVersion GruvboxGreen[J

line 865: [J

line 866: " }}}[J

line 867: " NERDTree: {{{[J

line 868: [J

line 869: hi! link NERDTreeDir GruvboxAqua[J

line 870: hi! link NERDTreeDirSlash GruvboxAqua[J

line 871: [J

line 872: hi! link NERDTreeOpenable GruvboxOrange[J

line 873: hi! link NERDTreeClosable GruvboxOrange[J

line 874: [J

line 875: hi! link NERDTreeFile GruvboxFg1[J

line 876: hi! link NERDTreeExecFile GruvboxYellow[J

line 877: [J

line 878: hi! link NERDTreeUp GruvboxGray[J

line 879: hi! link NERDTreeCWD GruvboxGreen[J

line 880: hi! link NERDTreeHelp GruvboxFg1[J

line 881: [J

line 882: hi! link NERDTreeToggleOn GruvboxGreen[J

line 883: hi! link NERDTreeToggleOff GruvboxRed[J

line 884: [J

line 885: " }}}[J

line 886: " Vim Multiple Cursors: {{{[J

line 887: [J

line 888: call s:HL('multiple_cursors_cursor', s:none, s:none, s:inverse)[J

calling function <SNR>13_HL[J('multiple_cursors_cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi multiple_cursors_cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 889: call s:HL('multiple_cursors_visual', s:none, s:bg2)[J

calling function <SNR>13_HL[J('multiple_cursors_visual', ['NONE', 'NONE'], ['#d5c4a1', 250])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi multiple_cursors_visual guifg=NONE ctermfg=NONE guibg=#d5c4a1 ctermbg=250 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 890: [J

line 891: " }}}[J

line 892: [J

line 893: " Filetype specific -----------------------------------------------------------[J

line 894: " Diff: {{{[J

line 895: [J

line 896: hi! link diffAdded GruvboxGreen[J

line 897: hi! link diffRemoved GruvboxRed[J

line 898: hi! link diffChanged GruvboxAqua[J

line 899: [J

line 900: hi! link diffFile GruvboxOrange[J

line 901: hi! link diffNewFile GruvboxYellow[J

line 902: [J

line 903: hi! link diffLine GruvboxBlue[J

line 904: [J

line 905: " }}}[J

line 906: " Html: {{{[J

line 907: [J

line 908: hi! link htmlTag GruvboxBlue[J

line 909: hi! link htmlEndTag GruvboxBlue[J

line 910: [J

line 911: hi! link htmlTagName GruvboxAquaBold[J

line 912: hi! link htmlArg GruvboxAqua[J

line 913: [J

line 914: hi! link htmlScriptTag GruvboxPurple[J

line 915: hi! link htmlTagN GruvboxFg1[J

line 916: hi! link htmlSpecialTagName GruvboxAquaBold[J

line 917: [J

line 918: call s:HL('htmlLink', s:fg4, s:none, s:underline)[J

calling function <SNR>13_HL[J('htmlLink', ['#7c6f64', 243], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlLink guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 919: [J

line 920: hi! link htmlSpecialChar GruvboxOrange[J

line 921: [J

line 922: call s:HL('htmlBold', s:vim_fg, s:vim_bg, s:bold)[J

calling function <SNR>13_HL[J('htmlBold', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlBold guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 923: call s:HL('htmlBoldUnderline', s:vim_fg, s:vim_bg, s:bold . s:underline)[J

calling function <SNR>13_HL[J('htmlBoldUnderline', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlBoldUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 924: call s:HL('htmlBoldItalic', s:vim_fg, s:vim_bg, s:bold . s:italic)[J

calling function <SNR>13_HL[J('htmlBoldItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlBoldItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 925: call s:HL('htmlBoldUnderlineItalic', s:vim_fg, s:vim_bg, s:bold . s:underline . s:italic)[J

calling function <SNR>13_HL[J('htmlBoldUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlBoldUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 926: [J

line 927: call s:HL('htmlUnderline', s:vim_fg, s:vim_bg, s:underline)[J

calling function <SNR>13_HL[J('htmlUnderline', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 928: call s:HL('htmlUnderlineItalic', s:vim_fg, s:vim_bg, s:underline . s:italic)[J

calling function <SNR>13_HL[J('htmlUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 929: call s:HL('htmlItalic', s:vim_fg, s:vim_bg, s:italic)[J

calling function <SNR>13_HL[J('htmlItalic', ['fg', 'fg'], ['bg', 'bg'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 930: [J

line 931: " }}}[J

line 932: " Xml: {{{[J

line 933: [J

line 934: hi! link xmlTag GruvboxBlue[J

line 935: hi! link xmlEndTag GruvboxBlue[J

line 936: hi! link xmlTagName GruvboxBlue[J

line 937: hi! link xmlEqual GruvboxBlue[J

line 938: hi! link docbkKeyword GruvboxAquaBold[J

line 939: [J

line 940: hi! link xmlDocTypeDecl GruvboxGray[J

line 941: hi! link xmlDocTypeKeyword GruvboxPurple[J

line 942: hi! link xmlCdataStart GruvboxGray[J

line 943: hi! link xmlCdataCdata GruvboxPurple[J

line 944: hi! link dtdFunction GruvboxGray[J

line 945: hi! link dtdTagName GruvboxPurple[J

line 946: [J

line 947: hi! link xmlAttrib GruvboxAqua[J

line 948: hi! link xmlProcessingDelim GruvboxGray[J

line 949: hi! link dtdParamEntityPunct GruvboxGray[J

line 950: hi! link dtdParamEntityDPunct GruvboxGray[J

line 951: hi! link xmlAttribPunct GruvboxGray[J

line 952: [J

line 953: hi! link xmlEntity GruvboxOrange[J

line 954: hi! link xmlEntityPunct GruvboxOrange[J

line 955: " }}}[J

line 956: " Vim: {{{[J

line 957: [J

line 958: call s:HL('vimCommentTitle', s:fg4_256, s:none, s:bold . s:italicize_comments)[J

calling function <SNR>13_HL[J('vimCommentTitle', ['#7c6f64', 243], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi vimCommentTitle guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 959: [J

line 960: hi! link vimNotation GruvboxOrange[J

line 961: hi! link vimBracket GruvboxOrange[J

line 962: hi! link vimMapModKey GruvboxOrange[J

line 963: hi! link vimFuncSID GruvboxFg3[J

line 964: hi! link vimSetSep GruvboxFg3[J

line 965: hi! link vimSep GruvboxFg3[J

line 966: hi! link vimContinue GruvboxFg3[J

line 967: [J

line 968: " }}}[J

line 969: " Clojure: {{{[J

line 970: [J

line 971: hi! link clojureKeyword GruvboxBlue[J

line 972: hi! link clojureCond GruvboxOrange[J

line 973: hi! link clojureSpecial GruvboxOrange[J

line 974: hi! link clojureDefine GruvboxOrange[J

line 975: [J

line 976: hi! link clojureFunc GruvboxYellow[J

line 977: hi! link clojureRepeat GruvboxYellow[J

line 978: hi! link clojureCharacter GruvboxAqua[J

line 979: hi! link clojureStringEscape GruvboxAqua[J

line 980: hi! link clojureException GruvboxRed[J

line 981: [J

line 982: hi! link clojureRegexp GruvboxAqua[J

line 983: hi! link clojureRegexpEscape GruvboxAqua[J

line 984: call s:HL('clojureRegexpCharClass', s:fg3, s:none, s:bold)[J

calling function <SNR>13_HL[J('clojureRegexpCharClass', ['#665c54', 241], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi clojureRegexpCharClass guifg=#665c54 ctermfg=241 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 985: hi! link clojureRegexpMod clojureRegexpCharClass[J

line 986: hi! link clojureRegexpQuantifier clojureRegexpCharClass[J

line 987: [J

line 988: hi! link clojureParen GruvboxFg3[J

line 989: hi! link clojureAnonArg GruvboxYellow[J

line 990: hi! link clojureVariable GruvboxBlue[J

line 991: hi! link clojureMacro GruvboxOrange[J

line 992: [J

line 993: hi! link clojureMeta GruvboxYellow[J

line 994: hi! link clojureDeref GruvboxYellow[J

line 995: hi! link clojureQuote GruvboxYellow[J

line 996: hi! link clojureUnquote GruvboxYellow[J

line 997: [J

line 998: " }}}[J

line 999: " C: {{{[J

line 1000: [J

line 1001: hi! link cOperator GruvboxPurple[J

line 1002: hi! link cStructure GruvboxOrange[J

line 1003: [J

line 1004: " }}}[J

line 1005: " Python: {{{[J

line 1006: [J

line 1007: hi! link pythonBuiltin GruvboxOrange[J

line 1008: hi! link pythonBuiltinObj GruvboxOrange[J

line 1009: hi! link pythonBuiltinFunc GruvboxOrange[J

line 1010: hi! link pythonFunction GruvboxAqua[J

line 1011: hi! link pythonDecorator GruvboxRed[J

line 1012: hi! link pythonInclude GruvboxBlue[J

line 1013: hi! link pythonImport GruvboxBlue[J

line 1014: hi! link pythonRun GruvboxBlue[J

line 1015: hi! link pythonCoding GruvboxBlue[J

line 1016: hi! link pythonOperator GruvboxRed[J

line 1017: hi! link pythonException GruvboxRed[J

line 1018: hi! link pythonExceptions GruvboxPurple[J

line 1019: hi! link pythonBoolean GruvboxPurple[J

line 1020: hi! link pythonDot GruvboxFg3[J

line 1021: hi! link pythonConditional GruvboxRed[J

line 1022: hi! link pythonRepeat GruvboxRed[J

line 1023: hi! link pythonDottedName GruvboxGreenBold[J

line 1024: [J

line 1025: " }}}[J

line 1026: " CSS: {{{[J

line 1027: [J

line 1028: hi! link cssBraces GruvboxBlue[J

line 1029: hi! link cssFunctionName GruvboxYellow[J

line 1030: hi! link cssIdentifier GruvboxOrange[J

line 1031: hi! link cssClassName GruvboxGreen[J

line 1032: hi! link cssColor GruvboxBlue[J

line 1033: hi! link cssSelectorOp GruvboxBlue[J

line 1034: hi! link cssSelectorOp2 GruvboxBlue[J

line 1035: hi! link cssImportant GruvboxGreen[J

line 1036: hi! link cssVendor GruvboxFg1[J

line 1037: [J

line 1038: hi! link cssTextProp GruvboxAqua[J

line 1039: hi! link cssAnimationProp GruvboxAqua[J

line 1040: hi! link cssUIProp GruvboxYellow[J

line 1041: hi! link cssTransformProp GruvboxAqua[J

line 1042: hi! link cssTransitionProp GruvboxAqua[J

line 1043: hi! link cssPrintProp GruvboxAqua[J

line 1044: hi! link cssPositioningProp GruvboxYellow[J

line 1045: hi! link cssBoxProp GruvboxAqua[J

line 1046: hi! link cssFontDescriptorProp GruvboxAqua[J

line 1047: hi! link cssFlexibleBoxProp GruvboxAqua[J

line 1048: hi! link cssBorderOutlineProp GruvboxAqua[J

line 1049: hi! link cssBackgroundProp GruvboxAqua[J

line 1050: hi! link cssMarginProp GruvboxAqua[J

line 1051: hi! link cssListProp GruvboxAqua[J

line 1052: hi! link cssTableProp GruvboxAqua[J

line 1053: hi! link cssFontProp GruvboxAqua[J

line 1054: hi! link cssPaddingProp GruvboxAqua[J

line 1055: hi! link cssDimensionProp GruvboxAqua[J

line 1056: hi! link cssRenderProp GruvboxAqua[J

line 1057: hi! link cssColorProp GruvboxAqua[J

line 1058: hi! link cssGeneratedContentProp GruvboxAqua[J

line 1059: [J

line 1060: " }}}[J

line 1061: " JavaScript: {{{[J

line 1062: [J

line 1063: hi! link javaScriptBraces GruvboxFg1[J

line 1064: hi! link javaScriptFunction GruvboxAqua[J

line 1065: hi! link javaScriptIdentifier GruvboxRed[J

line 1066: hi! link javaScriptMember GruvboxBlue[J

line 1067: hi! link javaScriptNumber GruvboxPurple[J

line 1068: hi! link javaScriptNull GruvboxPurple[J

line 1069: hi! link javaScriptParens GruvboxFg3[J

line 1070: [J

line 1071: " }}}[J

line 1072: " YAJS: {{{[J

line 1073: [J

line 1074: hi! link javascriptImport GruvboxAqua[J

line 1075: hi! link javascriptExport GruvboxAqua[J

line 1076: hi! link javascriptClassKeyword GruvboxAqua[J

line 1077: hi! link javascriptClassExtends GruvboxAqua[J

line 1078: hi! link javascriptDefault GruvboxAqua[J

line 1079: [J

line 1080: hi! link javascriptClassName GruvboxYellow[J

line 1081: hi! link javascriptClassSuperName GruvboxYellow[J

line 1082: hi! link javascriptGlobal GruvboxYellow[J

line 1083: [J

line 1084: hi! link javascriptEndColons GruvboxFg1[J

line 1085: hi! link javascriptFuncArg GruvboxFg1[J

line 1086: hi! link javascriptGlobalMethod GruvboxFg1[J

line 1087: hi! link javascriptNodeGlobal GruvboxFg1[J

line 1088: hi! link javascriptBOMWindowProp GruvboxFg1[J

line 1089: hi! link javascriptArrayMethod GruvboxFg1[J

line 1090: hi! link javascriptArrayStaticMethod GruvboxFg1[J

line 1091: hi! link javascriptCacheMethod GruvboxFg1[J

line 1092: hi! link javascriptDateMethod GruvboxFg1[J

line 1093: hi! link javascriptMathStaticMethod GruvboxFg1[J

line 1094: [J

line 1095: " hi! link javascriptProp GruvboxFg1[J

line 1096: hi! link javascriptURLUtilsProp GruvboxFg1[J

line 1097: hi! link javascriptBOMNavigatorProp GruvboxFg1[J

line 1098: hi! link javascriptDOMDocMethod GruvboxFg1[J

line 1099: hi! link javascriptDOMDocProp GruvboxFg1[J

line 1100: hi! link javascriptBOMLocationMethod GruvboxFg1[J

line 1101: hi! link javascriptBOMWindowMethod GruvboxFg1[J

line 1102: hi! link javascriptStringMethod GruvboxFg1[J

line 1103: [J

line 1104: hi! link javascriptVariable GruvboxOrange[J

line 1105: " hi! link javascriptVariable GruvboxRed[J

line 1106: " hi! link javascriptIdentifier GruvboxOrange[J

line 1107: " hi! link javascriptClassSuper GruvboxOrange[J

line 1108: hi! link javascriptIdentifier GruvboxOrange[J

line 1109: hi! link javascriptClassSuper GruvboxOrange[J

line 1110: [J

line 1111: " hi! link javascriptFuncKeyword GruvboxOrange[J

line 1112: " hi! link javascriptAsyncFunc GruvboxOrange[J

line 1113: hi! link javascriptFuncKeyword GruvboxAqua[J

line 1114: hi! link javascriptAsyncFunc GruvboxAqua[J

line 1115: hi! link javascriptClassStatic GruvboxOrange[J

line 1116: [J

line 1117: hi! link javascriptOperator GruvboxRed[J

line 1118: hi! link javascriptForOperator GruvboxRed[J

line 1119: hi! link javascriptYield GruvboxRed[J

line 1120: hi! link javascriptExceptions GruvboxRed[J

line 1121: hi! link javascriptMessage GruvboxRed[J

line 1122: [J

line 1123: hi! link javascriptTemplateSB GruvboxAqua[J

line 1124: hi! link javascriptTemplateSubstitution GruvboxFg1[J

line 1125: [J

line 1126: " hi! link javascriptLabel GruvboxBlue[J

line 1127: " hi! link javascriptObjectLabel GruvboxBlue[J

line 1128: " hi! link javascriptPropertyName GruvboxBlue[J

line 1129: hi! link javascriptLabel GruvboxFg1[J

line 1130: hi! link javascriptObjectLabel GruvboxFg1[J

line 1131: hi! link javascriptPropertyName GruvboxFg1[J

line 1132: [J

line 1133: hi! link javascriptLogicSymbols GruvboxFg1[J

line 1134: hi! link javascriptArrowFunc GruvboxYellow[J

line 1135: [J

line 1136: hi! link javascriptDocParamName GruvboxFg4[J

line 1137: hi! link javascriptDocTags GruvboxFg4[J

line 1138: hi! link javascriptDocNotation GruvboxFg4[J

line 1139: hi! link javascriptDocParamType GruvboxFg4[J

line 1140: hi! link javascriptDocNamedParamType GruvboxFg4[J

line 1141: [J

line 1142: hi! link javascriptBrackets GruvboxFg1[J

line 1143: hi! link javascriptDOMElemAttrs GruvboxFg1[J

line 1144: hi! link javascriptDOMEventMethod GruvboxFg1[J

line 1145: hi! link javascriptDOMNodeMethod GruvboxFg1[J

line 1146: hi! link javascriptDOMStorageMethod GruvboxFg1[J

line 1147: hi! link javascriptHeadersMethod GruvboxFg1[J

line 1148: [J

line 1149: hi! link javascriptAsyncFuncKeyword GruvboxRed[J

line 1150: hi! link javascriptAwaitFuncKeyword GruvboxRed[J

line 1151: [J

line 1152: " }}}[J

line 1153: " PanglossJS: {{{[J

line 1154: [J

line 1155: hi! link jsClassKeyword GruvboxAqua[J

line 1156: hi! link jsExtendsKeyword GruvboxAqua[J

line 1157: hi! link jsExportDefault GruvboxAqua[J

line 1158: hi! link jsTemplateBraces GruvboxAqua[J

line 1159: hi! link jsGlobalNodeObjects GruvboxFg1[J

line 1160: hi! link jsGlobalObjects GruvboxFg1[J

line 1161: hi! link jsFunction GruvboxAqua[J

line 1162: hi! link jsFuncParens GruvboxFg3[J

line 1163: hi! link jsParens GruvboxFg3[J

line 1164: hi! link jsNull GruvboxPurple[J

line 1165: hi! link jsUndefined GruvboxPurple[J

line 1166: hi! link jsClassDefinition GruvboxYellow[J

line 1167: [J

line 1168: " }}}[J

line 1169: " TypeScript: {{{[J

line 1170: [J

line 1171: hi! link typeScriptReserved GruvboxAqua[J

line 1172: hi! link typeScriptLabel GruvboxAqua[J

line 1173: hi! link typeScriptFuncKeyword GruvboxAqua[J

line 1174: hi! link typeScriptIdentifier GruvboxOrange[J

line 1175: hi! link typeScriptBraces GruvboxFg1[J

line 1176: hi! link typeScriptEndColons GruvboxFg1[J

line 1177: hi! link typeScriptDOMObjects GruvboxFg1[J

line 1178: hi! link typeScriptAjaxMethods GruvboxFg1[J

line 1179: hi! link typeScriptLogicSymbols GruvboxFg1[J

line 1180: hi! link typeScriptDocSeeTag Comment[J

line 1181: hi! link typeScriptDocParam Comment[J

line 1182: hi! link typeScriptDocTags vimCommentTitle[J

line 1183: hi! link typeScriptGlobalObjects GruvboxFg1[J

line 1184: hi! link typeScriptParens GruvboxFg3[J

line 1185: hi! link typeScriptOpSymbols GruvboxFg3[J

line 1186: hi! link typeScriptHtmlElemProperties GruvboxFg1[J

line 1187: hi! link typeScriptNull GruvboxPurple[J

line 1188: hi! link typeScriptInterpolationDelimiter GruvboxAqua[J

line 1189: [J

line 1190: " }}}[J

line 1191: " PureScript: {{{[J

line 1192: [J

line 1193: hi! link purescriptModuleKeyword GruvboxAqua[J

line 1194: hi! link purescriptModuleName GruvboxFg1[J

line 1195: hi! link purescriptWhere GruvboxAqua[J

line 1196: hi! link purescriptDelimiter GruvboxFg4[J

line 1197: hi! link purescriptType GruvboxFg1[J

line 1198: hi! link purescriptImportKeyword GruvboxAqua[J

line 1199: hi! link purescriptHidingKeyword GruvboxAqua[J

line 1200: hi! link purescriptAsKeyword GruvboxAqua[J

line 1201: hi! link purescriptStructure GruvboxAqua[J

line 1202: hi! link purescriptOperator GruvboxBlue[J

line 1203: [J

line 1204: hi! link purescriptTypeVar GruvboxFg1[J

line 1205: hi! link purescriptConstructor GruvboxFg1[J

line 1206: hi! link purescriptFunction GruvboxFg1[J

line 1207: hi! link purescriptConditional GruvboxOrange[J

line 1208: hi! link purescriptBacktick GruvboxOrange[J

line 1209: [J

line 1210: " }}}[J

line 1211: " CoffeeScript: {{{[J

line 1212: [J

line 1213: hi! link coffeeExtendedOp GruvboxFg3[J

line 1214: hi! link coffeeSpecialOp GruvboxFg3[J

line 1215: hi! link coffeeCurly GruvboxOrange[J

line 1216: hi! link coffeeParen GruvboxFg3[J

line 1217: hi! link coffeeBracket GruvboxOrange[J

line 1218: [J

line 1219: " }}}[J

line 1220: " Ruby: {{{[J

line 1221: [J

line 1222: hi! link rubyStringDelimiter GruvboxGreen[J

line 1223: hi! link rubyInterpolationDelimiter GruvboxAqua[J

line 1224: [J

line 1225: " }}}[J

line 1226: " ObjectiveC: {{{[J

line 1227: [J

line 1228: hi! link objcTypeModifier GruvboxRed[J

line 1229: hi! link objcDirective GruvboxBlue[J

line 1230: [J

line 1231: " }}}[J

line 1232: " Go: {{{[J

line 1233: [J

line 1234: hi! link goDirective GruvboxAqua[J

line 1235: hi! link goConstants GruvboxPurple[J

line 1236: hi! link goDeclaration GruvboxRed[J

line 1237: hi! link goDeclType GruvboxBlue[J

line 1238: hi! link goBuiltins GruvboxOrange[J

line 1239: [J

line 1240: " }}}[J

line 1241: " Lua: {{{[J

line 1242: [J

line 1243: hi! link luaIn GruvboxRed[J

line 1244: hi! link luaFunction GruvboxAqua[J

line 1245: hi! link luaTable GruvboxOrange[J

line 1246: [J

line 1247: " }}}[J

line 1248: " MoonScript: {{{[J

line 1249: [J

line 1250: hi! link moonSpecialOp GruvboxFg3[J

line 1251: hi! link moonExtendedOp GruvboxFg3[J

line 1252: hi! link moonFunction GruvboxFg3[J

line 1253: hi! link moonObject GruvboxYellow[J

line 1254: [J

line 1255: " }}}[J

line 1256: " Java: {{{[J

line 1257: [J

line 1258: hi! link javaAnnotation GruvboxBlue[J

line 1259: hi! link javaDocTags GruvboxAqua[J

line 1260: hi! link javaCommentTitle vimCommentTitle[J

line 1261: hi! link javaParen GruvboxFg3[J

line 1262: hi! link javaParen1 GruvboxFg3[J

line 1263: hi! link javaParen2 GruvboxFg3[J

line 1264: hi! link javaParen3 GruvboxFg3[J

line 1265: hi! link javaParen4 GruvboxFg3[J

line 1266: hi! link javaParen5 GruvboxFg3[J

line 1267: hi! link javaOperator GruvboxOrange[J

line 1268: [J

line 1269: hi! link javaVarArg GruvboxGreen[J

line 1270: [J

line 1271: " }}}[J

line 1272: " Elixir: {{{[J

line 1273: [J

line 1274: hi! link elixirDocString Comment[J

line 1275: [J

line 1276: hi! link elixirStringDelimiter GruvboxGreen[J

line 1277: hi! link elixirInterpolationDelimiter GruvboxAqua[J

line 1278: [J

line 1279: hi! link elixirModuleDeclaration GruvboxYellow[J

line 1280: [J

line 1281: " }}}[J

line 1282: " Scala: {{{[J

line 1283: [J

line 1284: " NB: scala vim syntax file is kinda horrible[J

line 1285: hi! link scalaNameDefinition GruvboxFg1[J

line 1286: hi! link scalaCaseFollowing GruvboxFg1[J

line 1287: hi! link scalaCapitalWord GruvboxFg1[J

line 1288: hi! link scalaTypeExtension GruvboxFg1[J

line 1289: [J

line 1290: hi! link scalaKeyword GruvboxRed[J

line 1291: hi! link scalaKeywordModifier GruvboxRed[J

line 1292: [J

line 1293: hi! link scalaSpecial GruvboxAqua[J

line 1294: hi! link scalaOperator GruvboxFg1[J

line 1295: [J

line 1296: hi! link scalaTypeDeclaration GruvboxYellow[J

line 1297: hi! link scalaTypeTypePostDeclaration GruvboxYellow[J

line 1298: [J

line 1299: hi! link scalaInstanceDeclaration GruvboxFg1[J

line 1300: hi! link scalaInterpolation GruvboxAqua[J

line 1301: [J

line 1302: " }}}[J

line 1303: " Markdown: {{{[J

line 1304: [J

line 1305: call s:HL('markdownItalic', s:fg3, s:none, s:italic)[J

calling function <SNR>13_HL[J('markdownItalic', ['#665c54', 241], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi markdownItalic guifg=#665c54 ctermfg=241 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 1306: [J

line 1307: hi! link markdownH1 GruvboxGreenBold[J

line 1308: hi! link markdownH2 GruvboxGreenBold[J

line 1309: hi! link markdownH3 GruvboxYellowBold[J

line 1310: hi! link markdownH4 GruvboxYellowBold[J

line 1311: hi! link markdownH5 GruvboxYellow[J

line 1312: hi! link markdownH6 GruvboxYellow[J

line 1313: [J

line 1314: hi! link markdownCode GruvboxAqua[J

line 1315: hi! link markdownCodeBlock GruvboxAqua[J

line 1316: hi! link markdownCodeDelimiter GruvboxAqua[J

line 1317: [J

line 1318: hi! link markdownBlockquote GruvboxGray[J

line 1319: hi! link markdownListMarker GruvboxGray[J

line 1320: hi! link markdownOrderedListMarker GruvboxGray[J

line 1321: hi! link markdownRule GruvboxGray[J

line 1322: hi! link markdownHeadingRule GruvboxGray[J

line 1323: [J

line 1324: hi! link markdownUrlDelimiter GruvboxFg3[J

line 1325: hi! link markdownLinkDelimiter GruvboxFg3[J

line 1326: hi! link markdownLinkTextDelimiter GruvboxFg3[J

line 1327: [J

line 1328: hi! link markdownHeadingDelimiter GruvboxOrange[J

line 1329: hi! link markdownUrl GruvboxPurple[J

line 1330: hi! link markdownUrlTitleDelimiter GruvboxGreen[J

line 1331: [J

line 1332: call s:HL('markdownLinkText', s:gray, s:none, s:underline)[J

calling function <SNR>13_HL[J('markdownLinkText', ['#928374', 244], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi markdownLinkText guifg=#928374 ctermfg=244 guibg=NONE ctermbg=NONE gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 1333: hi! link markdownIdDeclaration markdownLinkText[J

line 1334: [J

line 1335: " }}}[J

line 1336: " Haskell: {{{[J

line 1337: [J

line 1338: " hi! link haskellType GruvboxYellow[J

line 1339: " hi! link haskellOperators GruvboxOrange[J

line 1340: " hi! link haskellConditional GruvboxAqua[J

line 1341: " hi! link haskellLet GruvboxOrange[J

line 1342: "[J

line 1343: hi! link haskellType GruvboxFg1[J

line 1344: hi! link haskellIdentifier GruvboxFg1[J

line 1345: hi! link haskellSeparator GruvboxFg1[J

line 1346: hi! link haskellDelimiter GruvboxFg4[J

line 1347: hi! link haskellOperators GruvboxBlue[J

line 1348: "[J

line 1349: hi! link haskellBacktick GruvboxOrange[J

line 1350: hi! link haskellStatement GruvboxOrange[J

line 1351: hi! link haskellConditional GruvboxOrange[J

line 1352: [J

line 1353: hi! link haskellLet GruvboxAqua[J

line 1354: hi! link haskellDefault GruvboxAqua[J

line 1355: hi! link haskellWhere GruvboxAqua[J

line 1356: hi! link haskellBottom GruvboxAqua[J

line 1357: hi! link haskellBlockKeywords GruvboxAqua[J

line 1358: hi! link haskellImportKeywords GruvboxAqua[J

line 1359: hi! link haskellDeclKeyword GruvboxAqua[J

line 1360: hi! link haskellDeriving GruvboxAqua[J

line 1361: hi! link haskellAssocType GruvboxAqua[J

line 1362: [J

line 1363: hi! link haskellNumber GruvboxPurple[J

line 1364: hi! link haskellPragma GruvboxPurple[J

line 1365: [J

line 1366: hi! link haskellString GruvboxGreen[J

line 1367: hi! link haskellChar GruvboxGreen[J

line 1368: [J

line 1369: " }}}[J

line 1370: " Json: {{{[J

line 1371: [J

line 1372: hi! link jsonKeyword GruvboxGreen[J

line 1373: hi! link jsonQuote GruvboxGreen[J

line 1374: hi! link jsonBraces GruvboxFg1[J

line 1375: hi! link jsonString GruvboxFg1[J

line 1376: [J

line 1377: " }}}[J

line 1378: [J

line 1379: [J

line 1380: " Functions -------------------------------------------------------------------[J

line 1381: " Search Highlighting Cursor {{{[J

line 1382: [J

line 1383: function! GruvboxHlsShowCursor()[J

line 1386: [J

line 1387: function! GruvboxHlsHideCursor()[J

line 1390: [J

line 1391: " }}}[J

line 1392: [J

line 1393: " vim: set sw=2 ts=2 sts=2 et tw=80 ft=vim fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J
continuing in /Users/ygarrot/.vimrc[J
line 59: let g:gruvbox_contrast_dark = "hard" " soft, medium, hard[J

line 60: let g:gruvbox_contrast_light = "medium"[J

line 61: set background=dark[J

Searching for "colors/gruvbox.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim"[J
chdir(/Users/ygarrot/.vim/plugged/gruvbox/colors)[J
fchdir() to previous dir[J
line 61: sourcing "/Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim"[J
line 1: " -----------------------------------------------------------------------------[J

line 2: " File: gruvbox.vim[J

line 3: " Description: Retro groove color scheme for Vim[J

line 4: " Author: morhetz <morhetz@gmail.com>[J

line 5: " Source: https://github.com/morhetz/gruvbox[J

line 6: " Last Modified: 12 Aug 2017[J

line 7: " -----------------------------------------------------------------------------[J

line 8: [J

line 9: " Supporting code -------------------------------------------------------------[J

line 10: " Initialisation: {{{[J

line 11: [J

line 12: if version > 580[J

line 13:   hi clear[J

Searching for "syntax/syncolor.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim74/syntax)[J
fchdir() to previous dir[J
line 13: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim[J
continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/after/syntax/syncolor.vim"[J
line 14:   if exists("syntax_on")[J

line 15:     syntax reset[J

line 15: runtime! syntax/syncolor.vim[J

Searching for "syntax/syncolor.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after"[J
Searching for "/Users/ygarrot/.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim74/syntax)[J
fchdir() to previous dir[J
line 15: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi! link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi! link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi! link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi! link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi! link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi! link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi! link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi! link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi! link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi! link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi! link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi! link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi! link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi! link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi! link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi! link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi! link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi! link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi! link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi! link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi! link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi! link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi! link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi! link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim[J
continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/after/syntax/syncolor.vim"[J
line 16:   endif[J

line 17: endif[J

line 18: [J

line 19: let g:colors_name='gruvbox'[J

line 20: [J

line 21: if !(has('termguicolors') && &termguicolors) && !has('gui_running') && &t_Co != 256[J

line 22:   finish[J

line 23: endif[J

line 24: [J

line 25: " }}}[J

line 26: " Global Settings: {{{[J

line 27: [J

line 28: if !exists('g:gruvbox_bold')[J

line 29:   let g:gruvbox_bold=1[J

line 30: endif[J

line 31: if !exists('g:gruvbox_italic')[J

line 32:   if has('gui_running') || $TERM_ITALICS == 'true'[J

line 33:     let g:gruvbox_italic=1[J

line 34:   else[J

line 35:     let g:gruvbox_italic=0[J

line 36:   endif[J

line 37: endif[J

line 38: if !exists('g:gruvbox_undercurl')[J

line 39:   let g:gruvbox_undercurl=1[J

line 40: endif[J

line 41: if !exists('g:gruvbox_underline')[J

line 42:   let g:gruvbox_underline=1[J

line 43: endif[J

line 44: if !exists('g:gruvbox_inverse')[J

line 45:   let g:gruvbox_inverse=1[J

line 46: endif[J

line 47: [J

line 48: if !exists('g:gruvbox_guisp_fallback') || index(['fg', 'bg'], g:gruvbox_guisp_fallback) == -1[J

line 49:   let g:gruvbox_guisp_fallback='NONE'[J

line 50: endif[J

line 51: [J

line 52: if !exists('g:gruvbox_improved_strings')[J

line 53:   let g:gruvbox_improved_strings=0[J

line 54: endif[J

line 55: [J

line 56: if !exists('g:gruvbox_improved_warnings')[J

line 57:   let g:gruvbox_improved_warnings=0[J

line 58: endif[J

line 59: [J

line 60: if !exists('g:gruvbox_termcolors')[J

line 61:   let g:gruvbox_termcolors=256[J

line 62: endif[J

line 63: [J

line 64: if !exists('g:gruvbox_invert_indent_guides')[J

line 65:   let g:gruvbox_invert_indent_guides=0[J

line 66: endif[J

line 67: [J

line 68: if exists('g:gruvbox_contrast')[J

line 69:   echo 'g:gruvbox_contrast is deprecated; use g:gruvbox_contrast_light and g:gruvbox_contrast_dark instead'[J

line 70: endif[J

line 71: [J

line 72: if !exists('g:gruvbox_contrast_dark')[J

line 73:   let g:gruvbox_contrast_dark='medium'[J

line 74: endif[J

line 75: [J

line 76: if !exists('g:gruvbox_contrast_light')[J

line 77:   let g:gruvbox_contrast_light='medium'[J

line 78: endif[J

line 79: [J

line 80: let s:is_dark=(&background == 'dark')[J

line 81: [J

line 82: " }}}[J

line 83: " Palette: {{{[J

line 84: [J

line 85: " setup palette dictionary[J

line 86: let s:gb = {}[J

line 87: [J

line 88: " fill it with absolute colors[J

line 89: let s:gb.dark0_hard  = ['#1d2021', 234]     " 29-32-33[J

line 90: let s:gb.dark0       = ['#282828', 235]     " 40-40-40[J

line 91: let s:gb.dark0_soft  = ['#32302f', 236]     " 50-48-47[J

line 92: let s:gb.dark1       = ['#3c3836', 237]     " 60-56-54[J

line 93: let s:gb.dark2       = ['#504945', 239]     " 80-73-69[J

line 94: let s:gb.dark3       = ['#665c54', 241]     " 102-92-84[J

line 95: let s:gb.dark4       = ['#7c6f64', 243]     " 124-111-100[J

line 96: let s:gb.dark4_256   = ['#7c6f64', 243]     " 124-111-100[J

line 97: [J

line 98: let s:gb.gray_245    = ['#928374', 245]     " 146-131-116[J

line 99: let s:gb.gray_244    = ['#928374', 244]     " 146-131-116[J

line 100: [J

line 101: let s:gb.light0_hard = ['#f9f5d7', 230]     " 249-245-215[J

line 102: let s:gb.light0      = ['#fbf1c7', 229]     " 253-244-193[J

line 103: let s:gb.light0_soft = ['#f2e5bc', 228]     " 242-229-188[J

line 104: let s:gb.light1      = ['#ebdbb2', 223]     " 235-219-178[J

line 105: let s:gb.light2      = ['#d5c4a1', 250]     " 213-196-161[J

line 106: let s:gb.light3      = ['#bdae93', 248]     " 189-174-147[J

line 107: let s:gb.light4      = ['#a89984', 246]     " 168-153-132[J

line 108: let s:gb.light4_256  = ['#a89984', 246]     " 168-153-132[J

line 109: [J

line 110: let s:gb.bright_red     = ['#fb4934', 167]     " 251-73-52[J

line 111: let s:gb.bright_green   = ['#b8bb26', 142]     " 184-187-38[J

line 112: let s:gb.bright_yellow  = ['#fabd2f', 214]     " 250-189-47[J

line 113: let s:gb.bright_blue    = ['#83a598', 109]     " 131-165-152[J

line 114: let s:gb.bright_purple  = ['#d3869b', 175]     " 211-134-155[J

line 115: let s:gb.bright_aqua    = ['#8ec07c', 108]     " 142-192-124[J

line 116: let s:gb.bright_orange  = ['#fe8019', 208]     " 254-128-25[J

line 117: [J

line 118: let s:gb.neutral_red    = ['#cc241d', 124]     " 204-36-29[J

line 119: let s:gb.neutral_green  = ['#98971a', 106]     " 152-151-26[J

line 120: let s:gb.neutral_yellow = ['#d79921', 172]     " 215-153-33[J

line 121: let s:gb.neutral_blue   = ['#458588', 66]      " 69-133-136[J

line 122: let s:gb.neutral_purple = ['#b16286', 132]     " 177-98-134[J

line 123: let s:gb.neutral_aqua   = ['#689d6a', 72]      " 104-157-106[J

line 124: let s:gb.neutral_orange = ['#d65d0e', 166]     " 214-93-14[J

line 125: [J

line 126: let s:gb.faded_red      = ['#9d0006', 88]      " 157-0-6[J

line 127: let s:gb.faded_green    = ['#79740e', 100]     " 121-116-14[J

line 128: let s:gb.faded_yellow   = ['#b57614', 136]     " 181-118-20[J

line 129: let s:gb.faded_blue     = ['#076678', 24]      " 7-102-120[J

line 130: let s:gb.faded_purple   = ['#8f3f71', 96]      " 143-63-113[J

line 131: let s:gb.faded_aqua     = ['#427b58', 66]      " 66-123-88[J

line 132: let s:gb.faded_orange   = ['#af3a03', 130]     " 175-58-3[J

line 133: [J

line 134: " }}}[J

line 135: " Setup Emphasis: {{{[J

line 136: [J

line 137: let s:bold = 'bold,'[J

line 138: if g:gruvbox_bold == 0[J

line 139:   let s:bold = ''[J

line 140: endif[J

line 141: [J

line 142: let s:italic = 'italic,'[J

line 143: if g:gruvbox_italic == 0[J

line 144:   let s:italic = ''[J

line 145: endif[J

line 146: [J

line 147: let s:underline = 'underline,'[J

line 148: if g:gruvbox_underline == 0[J

line 149:   let s:underline = ''[J

line 150: endif[J

line 151: [J

line 152: let s:undercurl = 'undercurl,'[J

line 153: if g:gruvbox_undercurl == 0[J

line 154:   let s:undercurl = ''[J

line 155: endif[J

line 156: [J

line 157: let s:inverse = 'inverse,'[J

line 158: if g:gruvbox_inverse == 0[J

line 159:   let s:inverse = ''[J

line 160: endif[J

line 161: [J

line 162: " }}}[J

line 163: " Setup Colors: {{{[J

line 164: [J

line 165: let s:vim_bg = ['bg', 'bg'][J

line 166: let s:vim_fg = ['fg', 'fg'][J

line 167: let s:none = ['NONE', 'NONE'][J

line 168: [J

line 169: " determine relative colors[J

line 170: if s:is_dark[J

line 171:   let s:bg0  = s:gb.dark0[J

line 172:   if g:gruvbox_contrast_dark == 'soft'[J

line 173:     let s:bg0  = s:gb.dark0_soft[J

line 174:   elseif g:gruvbox_contrast_dark == 'hard'[J

line 175:     let s:bg0  = s:gb.dark0_hard[J

line 176:   endif[J

line 177: [J

line 178:   let s:bg1  = s:gb.dark1[J

line 179:   let s:bg2  = s:gb.dark2[J

line 180:   let s:bg3  = s:gb.dark3[J

line 181:   let s:bg4  = s:gb.dark4[J

line 182: [J

line 183:   let s:gray = s:gb.gray_245[J

line 184: [J

line 185:   let s:fg0 = s:gb.light0[J

line 186:   let s:fg1 = s:gb.light1[J

line 187:   let s:fg2 = s:gb.light2[J

line 188:   let s:fg3 = s:gb.light3[J

line 189:   let s:fg4 = s:gb.light4[J

line 190: [J

line 191:   let s:fg4_256 = s:gb.light4_256[J

line 192: [J

line 193:   let s:red    = s:gb.bright_red[J

line 194:   let s:green  = s:gb.bright_green[J

line 195:   let s:yellow = s:gb.bright_yellow[J

line 196:   let s:blue   = s:gb.bright_blue[J

line 197:   let s:purple = s:gb.bright_purple[J

line 198:   let s:aqua   = s:gb.bright_aqua[J

line 199:   let s:orange = s:gb.bright_orange[J

line 200: else[J

line 201:   let s:bg0  = s:gb.light0[J

line 202:   if g:gruvbox_contrast_light == 'soft'[J

line 203:     let s:bg0  = s:gb.light0_soft[J

line 204:   elseif g:gruvbox_contrast_light == 'hard'[J

line 205:     let s:bg0  = s:gb.light0_hard[J

line 206:   endif[J

line 207: [J

line 208:   let s:bg1  = s:gb.light1[J

line 209:   let s:bg2  = s:gb.light2[J

line 210:   let s:bg3  = s:gb.light3[J

line 211:   let s:bg4  = s:gb.light4[J

line 212: [J

line 213:   let s:gray = s:gb.gray_244[J

line 214: [J

line 215:   let s:fg0 = s:gb.dark0[J

line 216:   let s:fg1 = s:gb.dark1[J

line 217:   let s:fg2 = s:gb.dark2[J

line 218:   let s:fg3 = s:gb.dark3[J

line 219:   let s:fg4 = s:gb.dark4[J

line 220: [J

line 221:   let s:fg4_256 = s:gb.dark4_256[J

line 222: [J

line 223:   let s:red    = s:gb.faded_red[J

line 224:   let s:green  = s:gb.faded_green[J

line 225:   let s:yellow = s:gb.faded_yellow[J

line 226:   let s:blue   = s:gb.faded_blue[J

line 227:   let s:purple = s:gb.faded_purple[J

line 228:   let s:aqua   = s:gb.faded_aqua[J

line 229:   let s:orange = s:gb.faded_orange[J

line 230: endif[J

line 231: [J

line 232: " reset to 16 colors fallback[J

line 233: if g:gruvbox_termcolors == 16[J

line 234:   let s:bg0[1]    = 0[J

line 235:   let s:fg4[1]    = 7[J

line 236:   let s:gray[1]   = 8[J

line 237:   let s:red[1]    = 9[J

line 238:   let s:green[1]  = 10[J

line 239:   let s:yellow[1] = 11[J

line 240:   let s:blue[1]   = 12[J

line 241:   let s:purple[1] = 13[J

line 242:   let s:aqua[1]   = 14[J

line 243:   let s:fg1[1]    = 15[J

line 244: endif[J

line 245: [J

line 246: " save current relative colors back to palette dictionary[J

line 247: let s:gb.bg0 = s:bg0[J

line 248: let s:gb.bg1 = s:bg1[J

line 249: let s:gb.bg2 = s:bg2[J

line 250: let s:gb.bg3 = s:bg3[J

line 251: let s:gb.bg4 = s:bg4[J

line 252: [J

line 253: let s:gb.gray = s:gray[J

line 254: [J

line 255: let s:gb.fg0 = s:fg0[J

line 256: let s:gb.fg1 = s:fg1[J

line 257: let s:gb.fg2 = s:fg2[J

line 258: let s:gb.fg3 = s:fg3[J

line 259: let s:gb.fg4 = s:fg4[J

line 260: [J

line 261: let s:gb.fg4_256 = s:fg4_256[J

line 262: [J

line 263: let s:gb.red    = s:red[J

line 264: let s:gb.green  = s:green[J

line 265: let s:gb.yellow = s:yellow[J

line 266: let s:gb.blue   = s:blue[J

line 267: let s:gb.purple = s:purple[J

line 268: let s:gb.aqua   = s:aqua[J

line 269: let s:gb.orange = s:orange[J

line 270: [J

line 271: " }}}[J

line 272: " Setup Terminal Colors For Neovim: {{{[J

line 273: [J

line 274: if has('nvim')[J

line 275:   let g:terminal_color_0 = s:bg0[0][J

line 276:   let g:terminal_color_8 = s:gray[0][J

line 277: [J

line 278:   let g:terminal_color_1 = s:gb.neutral_red[0][J

line 279:   let g:terminal_color_9 = s:red[0][J

line 280: [J

line 281:   let g:terminal_color_2 = s:gb.neutral_green[0][J

line 282:   let g:terminal_color_10 = s:green[0][J

line 283: [J

line 284:   let g:terminal_color_3 = s:gb.neutral_yellow[0][J

line 285:   let g:terminal_color_11 = s:yellow[0][J

line 286: [J

line 287:   let g:terminal_color_4 = s:gb.neutral_blue[0][J

line 288:   let g:terminal_color_12 = s:blue[0][J

line 289: [J

line 290:   let g:terminal_color_5 = s:gb.neutral_purple[0][J

line 291:   let g:terminal_color_13 = s:purple[0][J

line 292: [J

line 293:   let g:terminal_color_6 = s:gb.neutral_aqua[0][J

line 294:   let g:terminal_color_14 = s:aqua[0][J

line 295: [J

line 296:   let g:terminal_color_7 = s:fg4[0][J

line 297:   let g:terminal_color_15 = s:fg1[0][J

line 298: endif[J

line 299: [J

line 300: " }}}[J

line 301: " Overload Setting: {{{[J

line 302: [J

line 303: let s:hls_cursor = s:orange[J

line 304: if exists('g:gruvbox_hls_cursor')[J

line 305:   let s:hls_cursor = get(s:gb, g:gruvbox_hls_cursor)[J

line 306: endif[J

line 307: [J

line 308: let s:number_column = s:none[J

line 309: if exists('g:gruvbox_number_column')[J

line 310:   let s:number_column = get(s:gb, g:gruvbox_number_column)[J

line 311: endif[J

line 312: [J

line 313: let s:sign_column = s:bg1[J

line 314: [J

line 316: if exists('g:gitgutter_override_sign_column_highlight') && g:gitgutter_override_sign_column_highlight == 1[J

line 317:   let s:sign_column = s:number_column[J

line 318: else[J

line 319:   let g:gitgutter_override_sign_column_highlight = 0[J

line 320: [J

line 321:   if exists('g:gruvbox_sign_column')[J

line 322:     let s:sign_column = get(s:gb, g:gruvbox_sign_column)[J

line 323:   endif[J

line 324: endif[J

line 325: [J

line 326: let s:color_column = s:bg1[J

line 327: if exists('g:gruvbox_color_column')[J

line 328:   let s:color_column = get(s:gb, g:gruvbox_color_column)[J

line 329: endif[J

line 330: [J

line 331: let s:vert_split = s:bg0[J

line 332: if exists('g:gruvbox_vert_split')[J

line 333:   let s:vert_split = get(s:gb, g:gruvbox_vert_split)[J

line 334: endif[J

line 335: [J

line 336: let s:invert_signs = ''[J

line 337: if exists('g:gruvbox_invert_signs')[J

line 338:   if g:gruvbox_invert_signs == 1[J

line 339:     let s:invert_signs = s:inverse[J

line 340:   endif[J

line 341: endif[J

line 342: [J

line 343: let s:invert_selection = s:inverse[J

line 344: if exists('g:gruvbox_invert_selection')[J

line 345:   if g:gruvbox_invert_selection == 0[J

line 346:     let s:invert_selection = ''[J

line 347:   endif[J

line 348: endif[J

line 349: [J

line 350: let s:invert_tabline = ''[J

line 351: if exists('g:gruvbox_invert_tabline')[J

line 352:   if g:gruvbox_invert_tabline == 1[J

line 353:     let s:invert_tabline = s:inverse[J

line 354:   endif[J

line 355: endif[J

line 356: [J

line 357: let s:italicize_comments = s:italic[J

line 358: if exists('g:gruvbox_italicize_comments')[J

line 359:   if g:gruvbox_italicize_comments == 0[J

line 360:     let s:italicize_comments = ''[J

line 361:   endif[J

line 362: endif[J

line 363: [J

line 364: let s:italicize_strings = ''[J

line 365: if exists('g:gruvbox_italicize_strings')[J

line 366:   if g:gruvbox_italicize_strings == 1[J

line 367:     let s:italicize_strings = s:italic[J

line 368:   endif[J

line 369: endif[J

line 370: [J

line 371: " }}}[J

line 372: " Highlighting Function: {{{[J

line 373: [J

line 374: function! s:HL(group, fg, ...)[J

line 419: [J

line 420: " }}}[J

line 421: " Gruvbox Hi Groups: {{{[J

line 422: [J

line 423: " memoize common hi groups[J

line 424: call s:HL('GruvboxFg0', s:fg0)[J

calling function <SNR>13_HL[J('GruvboxFg0', ['#fbf1c7', 229])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg0 guifg=#fbf1c7 ctermfg=229 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 425: call s:HL('GruvboxFg1', s:fg1)[J

calling function <SNR>13_HL[J('GruvboxFg1', ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg1 guifg=#ebdbb2 ctermfg=223 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 426: call s:HL('GruvboxFg2', s:fg2)[J

calling function <SNR>13_HL[J('GruvboxFg2', ['#d5c4a1', 250])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg2 guifg=#d5c4a1 ctermfg=250 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 427: call s:HL('GruvboxFg3', s:fg3)[J

calling function <SNR>13_HL[J('GruvboxFg3', ['#bdae93', 248])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg3 guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 428: call s:HL('GruvboxFg4', s:fg4)[J

calling function <SNR>13_HL[J('GruvboxFg4', ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg4 guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 429: call s:HL('GruvboxGray', s:gray)[J

calling function <SNR>13_HL[J('GruvboxGray', ['#928374', 245])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxGray guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 430: call s:HL('GruvboxBg0', s:bg0)[J

calling function <SNR>13_HL[J('GruvboxBg0', ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg0 guifg=#1d2021 ctermfg=234 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 431: call s:HL('GruvboxBg1', s:bg1)[J

calling function <SNR>13_HL[J('GruvboxBg1', ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg1 guifg=#3c3836 ctermfg=237 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 432: call s:HL('GruvboxBg2', s:bg2)[J

calling function <SNR>13_HL[J('GruvboxBg2', ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg2 guifg=#504945 ctermfg=239 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 433: call s:HL('GruvboxBg3', s:bg3)[J

calling function <SNR>13_HL[J('GruvboxBg3', ['#665c54', 241])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg3 guifg=#665c54 ctermfg=241 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 434: call s:HL('GruvboxBg4', s:bg4)[J

calling function <SNR>13_HL[J('GruvboxBg4', ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg4 guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 435: [J

line 436: call s:HL('GruvboxRed', s:red)[J

calling function <SNR>13_HL[J('GruvboxRed', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxRed guifg=#fb4934 ctermfg=167 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 437: call s:HL('GruvboxRedBold', s:red, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxRedBold', ['#fb4934', 167], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxRedBold guifg=#fb4934 ctermfg=167 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 438: call s:HL('GruvboxGreen', s:green)[J

calling function <SNR>13_HL[J('GruvboxGreen', ['#b8bb26', 142])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxGreen guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 439: call s:HL('GruvboxGreenBold', s:green, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxGreenBold', ['#b8bb26', 142], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxGreenBold guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 440: call s:HL('GruvboxYellow', s:yellow)[J

calling function <SNR>13_HL[J('GruvboxYellow', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxYellow guifg=#fabd2f ctermfg=214 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 441: call s:HL('GruvboxYellowBold', s:yellow, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxYellowBold', ['#fabd2f', 214], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxYellowBold guifg=#fabd2f ctermfg=214 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 442: call s:HL('GruvboxBlue', s:blue)[J

calling function <SNR>13_HL[J('GruvboxBlue', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBlue guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 443: call s:HL('GruvboxBlueBold', s:blue, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxBlueBold', ['#83a598', 109], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBlueBold guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 444: call s:HL('GruvboxPurple', s:purple)[J

calling function <SNR>13_HL[J('GruvboxPurple', ['#d3869b', 175])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxPurple guifg=#d3869b ctermfg=175 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 445: call s:HL('GruvboxPurpleBold', s:purple, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxPurpleBold', ['#d3869b', 175], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxPurpleBold guifg=#d3869b ctermfg=175 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 446: call s:HL('GruvboxAqua', s:aqua)[J

calling function <SNR>13_HL[J('GruvboxAqua', ['#8ec07c', 108])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxAqua guifg=#8ec07c ctermfg=108 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 447: call s:HL('GruvboxAquaBold', s:aqua, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxAquaBold', ['#8ec07c', 108], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxAquaBold guifg=#8ec07c ctermfg=108 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 448: call s:HL('GruvboxOrange', s:orange)[J

calling function <SNR>13_HL[J('GruvboxOrange', ['#fe8019', 208])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxOrange guifg=#fe8019 ctermfg=208 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 449: call s:HL('GruvboxOrangeBold', s:orange, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxOrangeBold', ['#fe8019', 208], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxOrangeBold guifg=#fe8019 ctermfg=208 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 450: [J

line 451: call s:HL('GruvboxRedSign', s:red, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxRedSign', ['#fb4934', 167], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxRedSign guifg=#fb4934 ctermfg=167 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 452: call s:HL('GruvboxGreenSign', s:green, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxGreenSign', ['#b8bb26', 142], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxGreenSign guifg=#b8bb26 ctermfg=142 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 453: call s:HL('GruvboxYellowSign', s:yellow, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxYellowSign', ['#fabd2f', 214], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxYellowSign guifg=#fabd2f ctermfg=214 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 454: call s:HL('GruvboxBlueSign', s:blue, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxBlueSign', ['#83a598', 109], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBlueSign guifg=#83a598 ctermfg=109 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 455: call s:HL('GruvboxPurpleSign', s:purple, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxPurpleSign', ['#d3869b', 175], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxPurpleSign guifg=#d3869b ctermfg=175 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 456: call s:HL('GruvboxAquaSign', s:aqua, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxAquaSign', ['#8ec07c', 108], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxAquaSign guifg=#8ec07c ctermfg=108 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 457: [J

line 458: " }}}[J

line 459: [J

line 460: " Vanilla colorscheme ---------------------------------------------------------[J

line 461: " General UI: {{{[J

line 462: [J

line 463: " Normal text[J

line 464: call s:HL('Normal', s:fg1, s:bg0)[J

calling function <SNR>13_HL[J('Normal', ['#ebdbb2', 223], ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Normal guifg=#ebdbb2 ctermfg=223 guibg=#1d2021 ctermbg=234 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 465: [J

line 466: " Correct background (see issue #7):[J

line 467: " --- Problem with changing between dark and light on 256 color terminal[J

line 468: " --- https://github.com/morhetz/gruvbox/issues/7[J

line 469: if s:is_dark[J

line 470:   set background=dark[J

line 471: else[J

line 472:   set background=light[J

line 473: endif[J

line 474: [J

line 475: if version >= 700[J

line 476:   " Screen line that the cursor is[J

line 477:   call s:HL('CursorLine',   s:none, s:bg1)[J

calling function <SNR>13_HL[J('CursorLine', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CursorLine guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 478:   " Screen column that the cursor is[J

line 479:   hi! link CursorColumn CursorLine[J

line 480: [J

line 481:   " Tab pages line filler[J

line 482:   call s:HL('TabLineFill', s:bg4, s:bg1, s:invert_tabline)[J

calling function <SNR>13_HL[J('TabLineFill', ['#7c6f64', 243], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi TabLineFill guifg=#7c6f64 ctermfg=243 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 483:   " Active tab page label[J

line 484:   call s:HL('TabLineSel', s:green, s:bg1, s:invert_tabline)[J

calling function <SNR>13_HL[J('TabLineSel', ['#b8bb26', 142], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi TabLineSel guifg=#b8bb26 ctermfg=142 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 485:   " Not active tab page label[J

line 486:   hi! link TabLine TabLineFill[J

line 487: [J

line 488:   " Match paired bracket under the cursor[J

line 489:   call s:HL('MatchParen', s:none, s:bg3, s:bold)[J

calling function <SNR>13_HL[J('MatchParen', ['NONE', 'NONE'], ['#665c54', 241], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi MatchParen guifg=NONE ctermfg=NONE guibg=#665c54 ctermbg=241 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 490: endif[J

line 491: [J

line 492: if version >= 703[J

line 493:   " Highlighted screen columns[J

line 494:   call s:HL('ColorColumn',  s:none, s:color_column)[J

calling function <SNR>13_HL[J('ColorColumn', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ColorColumn guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 495: [J

line 496:   " Concealed element: \lambda → λ[J

line 497:   call s:HL('Conceal', s:blue, s:none)[J

calling function <SNR>13_HL[J('Conceal', ['#83a598', 109], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Conceal guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 498: [J

line 499:   " Line number of CursorLine[J

line 500:   call s:HL('CursorLineNr', s:yellow, s:bg1)[J

calling function <SNR>13_HL[J('CursorLineNr', ['#fabd2f', 214], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CursorLineNr guifg=#fabd2f ctermfg=214 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 501: endif[J

line 502: [J

line 503: hi! link NonText GruvboxBg2[J

line 504: hi! link SpecialKey GruvboxBg2[J

line 505: [J

line 506: call s:HL('Visual',    s:none,  s:bg3, s:invert_selection)[J

calling function <SNR>13_HL[J('Visual', ['NONE', 'NONE'], ['#665c54', 241], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Visual guifg=NONE ctermfg=NONE guibg=#665c54 ctermbg=241 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 507: hi! link VisualNOS Visual[J

line 508: [J

line 509: call s:HL('Search',    s:yellow, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('Search', ['#fabd2f', 214], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Search guifg=#fabd2f ctermfg=214 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 510: call s:HL('IncSearch', s:hls_cursor, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('IncSearch', ['#fe8019', 208], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi IncSearch guifg=#fe8019 ctermfg=208 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 511: [J

line 512: call s:HL('Underlined', s:blue, s:none, s:underline)[J

calling function <SNR>13_HL[J('Underlined', ['#83a598', 109], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Underlined guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 513: [J

line 514: call s:HL('StatusLine',   s:bg2, s:fg1, s:inverse)[J

calling function <SNR>13_HL[J('StatusLine', ['#504945', 239], ['#ebdbb2', 223], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi StatusLine guifg=#504945 ctermfg=239 guibg=#ebdbb2 ctermbg=223 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 515: call s:HL('StatusLineNC', s:bg1, s:fg4, s:inverse)[J

calling function <SNR>13_HL[J('StatusLineNC', ['#3c3836', 237], ['#a89984', 246], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi StatusLineNC guifg=#3c3836 ctermfg=237 guibg=#a89984 ctermbg=246 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 516: [J

line 517: " The column separating vertically split windows[J

line 518: call s:HL('VertSplit', s:bg3, s:vert_split)[J

calling function <SNR>13_HL[J('VertSplit', ['#665c54', 241], ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi VertSplit guifg=#665c54 ctermfg=241 guibg=#1d2021 ctermbg=234 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 519: [J

line 520: " Current match in wildmenu completion[J

line 521: call s:HL('WildMenu', s:blue, s:bg2, s:bold)[J

calling function <SNR>13_HL[J('WildMenu', ['#83a598', 109], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi WildMenu guifg=#83a598 ctermfg=109 guibg=#504945 ctermbg=239 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 522: [J

line 523: " Directory names, special names in listing[J

line 524: hi! link Directory GruvboxGreenBold[J

line 525: [J

line 526: " Titles for output from :set all, :autocmd, etc.[J

line 527: hi! link Title GruvboxGreenBold[J

line 528: [J

line 529: " Error messages on the command line[J

line 530: call s:HL('ErrorMsg',   s:bg0, s:red, s:bold)[J

calling function <SNR>13_HL[J('ErrorMsg', ['#1d2021', 234], ['#fb4934', 167], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ErrorMsg guifg=#1d2021 ctermfg=234 guibg=#fb4934 ctermbg=167 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 531: " More prompt: -- More --[J

line 532: hi! link MoreMsg GruvboxYellowBold[J

line 533: " Current mode message: -- INSERT --[J

line 534: hi! link ModeMsg GruvboxYellowBold[J

line 535: " 'Press enter' prompt and yes/no questions[J

line 536: hi! link Question GruvboxOrangeBold[J

line 537: " Warning messages[J

line 538: hi! link WarningMsg GruvboxRedBold[J

line 539: [J

line 540: " }}}[J

line 541: " Gutter: {{{[J

line 542: [J

line 543: " Line number for :number and :# commands[J

line 544: call s:HL('LineNr', s:bg4, s:number_column)[J

calling function <SNR>13_HL[J('LineNr', ['#7c6f64', 243], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi LineNr guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 545: [J

line 546: " Column where signs are displayed[J

line 547: call s:HL('SignColumn', s:none, s:sign_column)[J

calling function <SNR>13_HL[J('SignColumn', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SignColumn guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 548: [J

line 549: " Line used for closed folds[J

line 550: call s:HL('Folded', s:gray, s:bg1, s:italic)[J

calling function <SNR>13_HL[J('Folded', ['#928374', 245], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Folded guifg=#928374 ctermfg=245 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 551: " Column where folds are displayed[J

line 552: call s:HL('FoldColumn', s:gray, s:bg1)[J

calling function <SNR>13_HL[J('FoldColumn', ['#928374', 245], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi FoldColumn guifg=#928374 ctermfg=245 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 553: [J

line 554: " }}}[J

line 555: " Cursor: {{{[J

line 556: [J

line 557: " Character under cursor[J

line 558: call s:HL('Cursor', s:none, s:none, s:inverse)[J

calling function <SNR>13_HL[J('Cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 559: " Visual mode cursor, selection[J

line 560: hi! link vCursor Cursor[J

line 561: " Input moder cursor[J

line 562: hi! link iCursor Cursor[J

line 563: " Language mapping cursor[J

line 564: hi! link lCursor Cursor[J

line 565: [J

line 566: " }}}[J

line 567: " Syntax Highlighting: {{{[J

line 568: [J

line 569: if g:gruvbox_improved_strings == 0[J

line 570:   hi! link Special GruvboxOrange[J

line 571: else[J

line 572:   call s:HL('Special', s:orange, s:bg1, s:italicize_strings)[J

line 573: endif[J

line 574: [J

line 575: call s:HL('Comment', s:gray, s:none, s:italicize_comments)[J

calling function <SNR>13_HL[J('Comment', ['#928374', 245], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Comment guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 576: call s:HL('Todo', s:vim_fg, s:vim_bg, s:bold . s:italic)[J

calling function <SNR>13_HL[J('Todo', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Todo guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 577: call s:HL('Error', s:red, s:vim_bg, s:bold . s:inverse)[J

calling function <SNR>13_HL[J('Error', ['#fb4934', 167], ['bg', 'bg'], 'bold,inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Error guifg=#fb4934 ctermfg=167 guibg=bg ctermbg=bg gui=bold,inverse cterm=bold,inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 578: [J

line 579: " Generic statement[J

line 580: hi! link Statement GruvboxRed[J

line 581: " if, then, else, endif, swicth, etc.[J

line 582: hi! link Conditional GruvboxRed[J

line 583: " for, do, while, etc.[J

line 584: hi! link Repeat GruvboxRed[J

line 585: " case, default, etc.[J

line 586: hi! link Label GruvboxRed[J

line 587: " try, catch, throw[J

line 588: hi! link Exception GruvboxRed[J

line 589: " sizeof, "+", "*", etc.[J

line 590: hi! link Operator Normal[J

line 591: " Any other keyword[J

line 592: hi! link Keyword GruvboxRed[J

line 593: [J

line 594: " Variable name[J

line 595: hi! link Identifier GruvboxBlue[J

line 596: " Function name[J

line 597: hi! link Function GruvboxGreenBold[J

line 598: [J

line 599: " Generic preprocessor[J

line 600: hi! link PreProc GruvboxAqua[J

line 601: " Preprocessor #include[J

line 602: hi! link Include GruvboxAqua[J

line 603: " Preprocessor #define[J

line 604: hi! link Define GruvboxAqua[J

line 605: " Same as Define[J

line 606: hi! link Macro GruvboxAqua[J

line 607: " Preprocessor #if, #else, #endif, etc.[J

line 608: hi! link PreCondit GruvboxAqua[J

line 609: [J

line 610: " Generic constant[J

line 611: hi! link Constant GruvboxPurple[J

line 612: " Character constant: 'c', '/n'[J

line 613: hi! link Character GruvboxPurple[J

line 614: " String constant: "this is a string"[J

line 615: if g:gruvbox_improved_strings == 0[J

line 616:   call s:HL('String',  s:green, s:none, s:italicize_strings)[J

calling function <SNR>13_HL[J('String', ['#b8bb26', 142], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi String guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 617: else[J

line 618:   call s:HL('String',  s:fg1, s:bg1, s:italicize_strings)[J

line 619: endif[J

line 620: " Boolean constant: TRUE, false[J

line 621: hi! link Boolean GruvboxPurple[J

line 622: " Number constant: 234, 0xff[J

line 623: hi! link Number GruvboxPurple[J

line 624: " Floating point constant: 2.3e10[J

line 625: hi! link Float GruvboxPurple[J

line 626: [J

line 627: " Generic type[J

line 628: hi! link Type GruvboxYellow[J

line 629: " static, register, volatile, etc[J

line 630: hi! link StorageClass GruvboxOrange[J

line 631: " struct, union, enum, etc.[J

line 632: hi! link Structure GruvboxAqua[J

line 633: " typedef[J

line 634: hi! link Typedef GruvboxYellow[J

line 635: [J

line 636: " }}}[J

line 637: " Completion Menu: {{{[J

line 638: [J

line 639: if version >= 700[J

line 640:   " Popup menu: normal item[J

line 641:   call s:HL('Pmenu', s:fg1, s:bg2)[J

calling function <SNR>13_HL[J('Pmenu', ['#ebdbb2', 223], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Pmenu guifg=#ebdbb2 ctermfg=223 guibg=#504945 ctermbg=239 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 642:   " Popup menu: selected item[J

line 643:   call s:HL('PmenuSel', s:bg2, s:blue, s:bold)[J

calling function <SNR>13_HL[J('PmenuSel', ['#504945', 239], ['#83a598', 109], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi PmenuSel guifg=#504945 ctermfg=239 guibg=#83a598 ctermbg=109 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 644:   " Popup menu: scrollbar[J

line 645:   call s:HL('PmenuSbar', s:none, s:bg2)[J

calling function <SNR>13_HL[J('PmenuSbar', ['NONE', 'NONE'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi PmenuSbar guifg=NONE ctermfg=NONE guibg=#504945 ctermbg=239 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 646:   " Popup menu: scrollbar thumb[J

line 647:   call s:HL('PmenuThumb', s:none, s:bg4)[J

calling function <SNR>13_HL[J('PmenuThumb', ['NONE', 'NONE'], ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi PmenuThumb guifg=NONE ctermfg=NONE guibg=#7c6f64 ctermbg=243 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 648: endif[J

line 649: [J

line 650: " }}}[J

line 651: " Diffs: {{{[J

line 652: [J

line 653: call s:HL('DiffDelete', s:red, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('DiffDelete', ['#fb4934', 167], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi DiffDelete guifg=#fb4934 ctermfg=167 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 654: call s:HL('DiffAdd',    s:green, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('DiffAdd', ['#b8bb26', 142], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi DiffAdd guifg=#b8bb26 ctermfg=142 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 655: "call s:HL('DiffChange', s:bg0, s:blue)[J

line 656: "call s:HL('DiffText',   s:bg0, s:yellow)[J

line 657: [J

line 658: " Alternative setting[J

line 659: call s:HL('DiffChange', s:aqua, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('DiffChange', ['#8ec07c', 108], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi DiffChange guifg=#8ec07c ctermfg=108 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 660: call s:HL('DiffText',   s:yellow, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('DiffText', ['#fabd2f', 214], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi DiffText guifg=#fabd2f ctermfg=214 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 661: [J

line 662: " }}}[J

line 663: " Spelling: {{{[J

line 664: [J

line 665: if has("spell")[J

line 666:   " Not capitalised word, or compile warnings[J

line 667:   if g:gruvbox_improved_warnings == 0[J

line 668:     call s:HL('SpellCap',   s:none, s:none, s:undercurl, s:red)[J

calling function <SNR>13_HL[J('SpellCap', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SpellCap guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 669:   else[J

line 670:     call s:HL('SpellCap',   s:green, s:none, s:bold . s:italic)[J

line 671:   endif[J

line 672:   " Not recognized word[J

line 673:   call s:HL('SpellBad',   s:none, s:none, s:undercurl, s:blue)[J

calling function <SNR>13_HL[J('SpellBad', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SpellBad guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#83a598[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 674:   " Wrong spelling for selected region[J

line 675:   call s:HL('SpellLocal', s:none, s:none, s:undercurl, s:aqua)[J

calling function <SNR>13_HL[J('SpellLocal', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#8ec07c', 108])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SpellLocal guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#8ec07c[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 676:   " Rare word[J

line 677:   call s:HL('SpellRare',  s:none, s:none, s:undercurl, s:purple)[J

calling function <SNR>13_HL[J('SpellRare', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#d3869b', 175])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SpellRare guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#d3869b[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 678: endif[J

line 679: [J

line 680: " }}}[J

line 681: [J

line 682: " Plugin specific -------------------------------------------------------------[J

line 683: " EasyMotion: {{{[J

line 684: [J

line 685: hi! link EasyMotionTarget Search[J

line 686: hi! link EasyMotionShade Comment[J

line 687: [J

line 688: " }}}[J

line 689: " Sneak: {{{[J

line 690: [J

line 691: hi! link Sneak Search[J

line 692: hi! link SneakLabel Search[J

line 693: [J

line 694: " }}}[J

line 695: " Indent Guides: {{{[J

line 696: [J

line 697: if !exists('g:indent_guides_auto_colors')[J

line 698:   let g:indent_guides_auto_colors = 0[J

line 699: endif[J

line 700: [J

line 701: if g:indent_guides_auto_colors == 0[J

line 702:   if g:gruvbox_invert_indent_guides == 0[J

line 703:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2)[J

calling function <SNR>13_HL[J('IndentGuidesOdd', ['bg', 'bg'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi IndentGuidesOdd guifg=bg ctermfg=bg guibg=#504945 ctermbg=239 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 704:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg1)[J

calling function <SNR>13_HL[J('IndentGuidesEven', ['bg', 'bg'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi IndentGuidesEven guifg=bg ctermfg=bg guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 705:   else[J

line 706:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2, s:inverse)[J

line 707:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg3, s:inverse)[J

line 708:   endif[J

line 709: endif[J

line 710: [J

line 711: " }}}[J

line 712: " IndentLine: {{{[J

line 713: [J

line 714: if !exists('g:indentLine_color_term')[J

line 715:   let g:indentLine_color_term = s:bg2[1][J

line 716: endif[J

line 717: if !exists('g:indentLine_color_gui')[J

line 718:   let g:indentLine_color_gui = s:bg2[0][J

line 719: endif[J

line 720: [J

line 721: " }}}[J

line 722: " Rainbow Parentheses: {{{[J

line 723: [J

line 724: if !exists('g:rbpt_colorpairs')[J

line 729:   let g:rbpt_colorpairs = [ ['blue', '#458588'], ['magenta', '#b16286'], ['red',  '#cc241d'], ['166',     '#d65d0e'] ][J

line 730: endif[J

line 731: [J

line 732: let g:rainbow_guifgs = [ '#d65d0e', '#cc241d', '#b16286', '#458588' ][J

line 733: let g:rainbow_ctermfgs = [ '166', 'red', 'magenta', 'blue' ][J

line 734: [J

line 735: if !exists('g:rainbow_conf')[J

line 736:    let g:rainbow_conf = {}[J

line 737: endif[J

line 738: if !has_key(g:rainbow_conf, 'guifgs')[J

line 739:    let g:rainbow_conf['guifgs'] = g:rainbow_guifgs[J

line 740: endif[J

line 741: if !has_key(g:rainbow_conf, 'ctermfgs')[J

line 742:    let g:rainbow_conf['ctermfgs'] = g:rainbow_ctermfgs[J

line 743: endif[J

line 744: [J

line 745: let g:niji_dark_colours = g:rbpt_colorpairs[J

line 746: let g:niji_light_colours = g:rbpt_colorpairs[J

line 747: [J

line 748: "}}}[J

line 749: " GitGutter: {{{[J

line 750: [J

line 751: hi! link GitGutterAdd GruvboxGreenSign[J

line 752: hi! link GitGutterChange GruvboxAquaSign[J

line 753: hi! link GitGutterDelete GruvboxRedSign[J

line 754: hi! link GitGutterChangeDelete GruvboxAquaSign[J

line 755: [J

line 756: " }}}[J

line 757: " GitCommit: "{{{[J

line 758: [J

line 759: hi! link gitcommitSelectedFile GruvboxGreen[J

line 760: hi! link gitcommitDiscardedFile GruvboxRed[J

line 761: [J

line 762: " }}}[J

line 763: " Signify: {{{[J

line 764: [J

line 765: hi! link SignifySignAdd GruvboxGreenSign[J

line 766: hi! link SignifySignChange GruvboxAquaSign[J

line 767: hi! link SignifySignDelete GruvboxRedSign[J

line 768: [J

line 769: " }}}[J

line 770: " Syntastic: {{{[J

line 771: [J

line 772: call s:HL('SyntasticError', s:none, s:none, s:undercurl, s:red)[J

calling function <SNR>13_HL[J('SyntasticError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SyntasticError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 773: call s:HL('SyntasticWarning', s:none, s:none, s:undercurl, s:yellow)[J

calling function <SNR>13_HL[J('SyntasticWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SyntasticWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fabd2f[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 774: [J

line 775: hi! link SyntasticErrorSign GruvboxRedSign[J

line 776: hi! link SyntasticWarningSign GruvboxYellowSign[J

line 777: [J

line 778: " }}}[J

line 779: " Signature: {{{[J

line 780: hi! link SignatureMarkText   GruvboxBlueSign[J

line 781: hi! link SignatureMarkerText GruvboxPurpleSign[J

line 782: [J

line 783: " }}}[J

line 784: " ShowMarks: {{{[J

line 785: [J

line 786: hi! link ShowMarksHLl GruvboxBlueSign[J

line 787: hi! link ShowMarksHLu GruvboxBlueSign[J

line 788: hi! link ShowMarksHLo GruvboxBlueSign[J

line 789: hi! link ShowMarksHLm GruvboxBlueSign[J

line 790: [J

line 791: " }}}[J

line 792: " CtrlP: {{{[J

line 793: [J

line 794: hi! link CtrlPMatch GruvboxYellow[J

line 795: hi! link CtrlPNoEntries GruvboxRed[J

line 796: hi! link CtrlPPrtBase GruvboxBg2[J

line 797: hi! link CtrlPPrtCursor GruvboxBlue[J

line 798: hi! link CtrlPLinePre GruvboxBg2[J

line 799: [J

line 800: call s:HL('CtrlPMode1', s:blue, s:bg2, s:bold)[J

calling function <SNR>13_HL[J('CtrlPMode1', ['#83a598', 109], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CtrlPMode1 guifg=#83a598 ctermfg=109 guibg=#504945 ctermbg=239 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 801: call s:HL('CtrlPMode2', s:bg0, s:blue, s:bold)[J

calling function <SNR>13_HL[J('CtrlPMode2', ['#1d2021', 234], ['#83a598', 109], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CtrlPMode2 guifg=#1d2021 ctermfg=234 guibg=#83a598 ctermbg=109 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 802: call s:HL('CtrlPStats', s:fg4, s:bg2, s:bold)[J

calling function <SNR>13_HL[J('CtrlPStats', ['#a89984', 246], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CtrlPStats guifg=#a89984 ctermfg=246 guibg=#504945 ctermbg=239 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 803: [J

line 804: " }}}[J

line 805: " Startify: {{{[J

line 806: [J

line 807: hi! link StartifyBracket GruvboxFg3[J

line 808: hi! link StartifyFile GruvboxFg1[J

line 809: hi! link StartifyNumber GruvboxBlue[J

line 810: hi! link StartifyPath GruvboxGray[J

line 811: hi! link StartifySlash GruvboxGray[J

line 812: hi! link StartifySection GruvboxYellow[J

line 813: hi! link StartifySpecial GruvboxBg2[J

line 814: hi! link StartifyHeader GruvboxOrange[J

line 815: hi! link StartifyFooter GruvboxBg2[J

line 816: [J

line 817: " }}}[J

line 818: " Vimshell: {{{[J

line 819: [J

line 825: let g:vimshell_escape_colors = [ s:bg4[0], s:red[0], s:green[0], s:yellow[0], s:blue[0], s:purple[0], s:aqua[0], s:fg4[0], s:bg0[0], s:red[0], s:green[0], s:orange[0], s:blue[0], s:purple[0], s:aqua[0], s:fg0[0] ][J

line 826: [J

line 827: " }}}[J

line 828: " BufTabLine: {{{[J

line 829: [J

line 830: call s:HL('BufTabLineCurrent', s:bg0, s:fg4)[J

calling function <SNR>13_HL[J('BufTabLineCurrent', ['#1d2021', 234], ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi BufTabLineCurrent guifg=#1d2021 ctermfg=234 guibg=#a89984 ctermbg=246 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 831: call s:HL('BufTabLineActive', s:fg4, s:bg2)[J

calling function <SNR>13_HL[J('BufTabLineActive', ['#a89984', 246], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi BufTabLineActive guifg=#a89984 ctermfg=246 guibg=#504945 ctermbg=239 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 832: call s:HL('BufTabLineHidden', s:bg4, s:bg1)[J

calling function <SNR>13_HL[J('BufTabLineHidden', ['#7c6f64', 243], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi BufTabLineHidden guifg=#7c6f64 ctermfg=243 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 833: call s:HL('BufTabLineFill', s:bg0, s:bg0)[J

calling function <SNR>13_HL[J('BufTabLineFill', ['#1d2021', 234], ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi BufTabLineFill guifg=#1d2021 ctermfg=234 guibg=#1d2021 ctermbg=234 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 834: [J

line 835: " }}}[J

line 836: " Asynchronous Lint Engine: {{{[J

line 837: [J

line 838: call s:HL('ALEError', s:none, s:none, s:undercurl, s:red)[J

calling function <SNR>13_HL[J('ALEError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ALEError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 839: call s:HL('ALEWarning', s:none, s:none, s:undercurl, s:yellow)[J

calling function <SNR>13_HL[J('ALEWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ALEWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fabd2f[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 840: call s:HL('ALEInfo', s:none, s:none, s:undercurl, s:blue)[J

calling function <SNR>13_HL[J('ALEInfo', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ALEInfo guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#83a598[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 841: [J

line 842: hi! link ALEErrorSign GruvboxRedSign[J

line 843: hi! link ALEWarningSign GruvboxYellowSign[J

line 844: hi! link ALEInfoSign GruvboxBlueSign[J

line 845: [J

line 846: " }}}[J

line 847: " Dirvish: {{{[J

line 848: [J

line 849: hi! link DirvishPathTail GruvboxAqua[J

line 850: hi! link DirvishArg GruvboxYellow[J

line 851: [J

line 852: " }}}[J

line 853: " Netrw: {{{[J

line 854: [J

line 855: hi! link netrwDir GruvboxAqua[J

line 856: hi! link netrwClassify GruvboxAqua[J

line 857: hi! link netrwLink GruvboxGray[J

line 858: hi! link netrwSymLink GruvboxFg1[J

line 859: hi! link netrwExe GruvboxYellow[J

line 860: hi! link netrwComment GruvboxGray[J

line 861: hi! link netrwList GruvboxBlue[J

line 862: hi! link netrwHelpCmd GruvboxAqua[J

line 863: hi! link netrwCmdSep GruvboxFg3[J

line 864: hi! link netrwVersion GruvboxGreen[J

line 865: [J

line 866: " }}}[J

line 867: " NERDTree: {{{[J

line 868: [J

line 869: hi! link NERDTreeDir GruvboxAqua[J

line 870: hi! link NERDTreeDirSlash GruvboxAqua[J

line 871: [J

line 872: hi! link NERDTreeOpenable GruvboxOrange[J

line 873: hi! link NERDTreeClosable GruvboxOrange[J

line 874: [J

line 875: hi! link NERDTreeFile GruvboxFg1[J

line 876: hi! link NERDTreeExecFile GruvboxYellow[J

line 877: [J

line 878: hi! link NERDTreeUp GruvboxGray[J

line 879: hi! link NERDTreeCWD GruvboxGreen[J

line 880: hi! link NERDTreeHelp GruvboxFg1[J

line 881: [J

line 882: hi! link NERDTreeToggleOn GruvboxGreen[J

line 883: hi! link NERDTreeToggleOff GruvboxRed[J

line 884: [J

line 885: " }}}[J

line 886: " Vim Multiple Cursors: {{{[J

line 887: [J

line 888: call s:HL('multiple_cursors_cursor', s:none, s:none, s:inverse)[J

calling function <SNR>13_HL[J('multiple_cursors_cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi multiple_cursors_cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 889: call s:HL('multiple_cursors_visual', s:none, s:bg2)[J

calling function <SNR>13_HL[J('multiple_cursors_visual', ['NONE', 'NONE'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi multiple_cursors_visual guifg=NONE ctermfg=NONE guibg=#504945 ctermbg=239 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 890: [J

line 891: " }}}[J

line 892: [J

line 893: " Filetype specific -----------------------------------------------------------[J

line 894: " Diff: {{{[J

line 895: [J

line 896: hi! link diffAdded GruvboxGreen[J

line 897: hi! link diffRemoved GruvboxRed[J

line 898: hi! link diffChanged GruvboxAqua[J

line 899: [J

line 900: hi! link diffFile GruvboxOrange[J

line 901: hi! link diffNewFile GruvboxYellow[J

line 902: [J

line 903: hi! link diffLine GruvboxBlue[J

line 904: [J

line 905: " }}}[J

line 906: " Html: {{{[J

line 907: [J

line 908: hi! link htmlTag GruvboxBlue[J

line 909: hi! link htmlEndTag GruvboxBlue[J

line 910: [J

line 911: hi! link htmlTagName GruvboxAquaBold[J

line 912: hi! link htmlArg GruvboxAqua[J

line 913: [J

line 914: hi! link htmlScriptTag GruvboxPurple[J

line 915: hi! link htmlTagN GruvboxFg1[J

line 916: hi! link htmlSpecialTagName GruvboxAquaBold[J

line 917: [J

line 918: call s:HL('htmlLink', s:fg4, s:none, s:underline)[J

calling function <SNR>13_HL[J('htmlLink', ['#a89984', 246], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlLink guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 919: [J

line 920: hi! link htmlSpecialChar GruvboxOrange[J

line 921: [J

line 922: call s:HL('htmlBold', s:vim_fg, s:vim_bg, s:bold)[J

calling function <SNR>13_HL[J('htmlBold', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlBold guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 923: call s:HL('htmlBoldUnderline', s:vim_fg, s:vim_bg, s:bold . s:underline)[J

calling function <SNR>13_HL[J('htmlBoldUnderline', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlBoldUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 924: call s:HL('htmlBoldItalic', s:vim_fg, s:vim_bg, s:bold . s:italic)[J

calling function <SNR>13_HL[J('htmlBoldItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlBoldItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 925: call s:HL('htmlBoldUnderlineItalic', s:vim_fg, s:vim_bg, s:bold . s:underline . s:italic)[J

calling function <SNR>13_HL[J('htmlBoldUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlBoldUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 926: [J

line 927: call s:HL('htmlUnderline', s:vim_fg, s:vim_bg, s:underline)[J

calling function <SNR>13_HL[J('htmlUnderline', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 928: call s:HL('htmlUnderlineItalic', s:vim_fg, s:vim_bg, s:underline . s:italic)[J

calling function <SNR>13_HL[J('htmlUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 929: call s:HL('htmlItalic', s:vim_fg, s:vim_bg, s:italic)[J

calling function <SNR>13_HL[J('htmlItalic', ['fg', 'fg'], ['bg', 'bg'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 930: [J

line 931: " }}}[J

line 932: " Xml: {{{[J

line 933: [J

line 934: hi! link xmlTag GruvboxBlue[J

line 935: hi! link xmlEndTag GruvboxBlue[J

line 936: hi! link xmlTagName GruvboxBlue[J

line 937: hi! link xmlEqual GruvboxBlue[J

line 938: hi! link docbkKeyword GruvboxAquaBold[J

line 939: [J

line 940: hi! link xmlDocTypeDecl GruvboxGray[J

line 941: hi! link xmlDocTypeKeyword GruvboxPurple[J

line 942: hi! link xmlCdataStart GruvboxGray[J

line 943: hi! link xmlCdataCdata GruvboxPurple[J

line 944: hi! link dtdFunction GruvboxGray[J

line 945: hi! link dtdTagName GruvboxPurple[J

line 946: [J

line 947: hi! link xmlAttrib GruvboxAqua[J

line 948: hi! link xmlProcessingDelim GruvboxGray[J

line 949: hi! link dtdParamEntityPunct GruvboxGray[J

line 950: hi! link dtdParamEntityDPunct GruvboxGray[J

line 951: hi! link xmlAttribPunct GruvboxGray[J

line 952: [J

line 953: hi! link xmlEntity GruvboxOrange[J

line 954: hi! link xmlEntityPunct GruvboxOrange[J

line 955: " }}}[J

line 956: " Vim: {{{[J

line 957: [J

line 958: call s:HL('vimCommentTitle', s:fg4_256, s:none, s:bold . s:italicize_comments)[J

calling function <SNR>13_HL[J('vimCommentTitle', ['#a89984', 246], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi vimCommentTitle guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 959: [J

line 960: hi! link vimNotation GruvboxOrange[J

line 961: hi! link vimBracket GruvboxOrange[J

line 962: hi! link vimMapModKey GruvboxOrange[J

line 963: hi! link vimFuncSID GruvboxFg3[J

line 964: hi! link vimSetSep GruvboxFg3[J

line 965: hi! link vimSep GruvboxFg3[J

line 966: hi! link vimContinue GruvboxFg3[J

line 967: [J

line 968: " }}}[J

line 969: " Clojure: {{{[J

line 970: [J

line 971: hi! link clojureKeyword GruvboxBlue[J

line 972: hi! link clojureCond GruvboxOrange[J

line 973: hi! link clojureSpecial GruvboxOrange[J

line 974: hi! link clojureDefine GruvboxOrange[J

line 975: [J

line 976: hi! link clojureFunc GruvboxYellow[J

line 977: hi! link clojureRepeat GruvboxYellow[J

line 978: hi! link clojureCharacter GruvboxAqua[J

line 979: hi! link clojureStringEscape GruvboxAqua[J

line 980: hi! link clojureException GruvboxRed[J

line 981: [J

line 982: hi! link clojureRegexp GruvboxAqua[J

line 983: hi! link clojureRegexpEscape GruvboxAqua[J

line 984: call s:HL('clojureRegexpCharClass', s:fg3, s:none, s:bold)[J

calling function <SNR>13_HL[J('clojureRegexpCharClass', ['#bdae93', 248], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi clojureRegexpCharClass guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 985: hi! link clojureRegexpMod clojureRegexpCharClass[J

line 986: hi! link clojureRegexpQuantifier clojureRegexpCharClass[J

line 987: [J

line 988: hi! link clojureParen GruvboxFg3[J

line 989: hi! link clojureAnonArg GruvboxYellow[J

line 990: hi! link clojureVariable GruvboxBlue[J

line 991: hi! link clojureMacro GruvboxOrange[J

line 992: [J

line 993: hi! link clojureMeta GruvboxYellow[J

line 994: hi! link clojureDeref GruvboxYellow[J

line 995: hi! link clojureQuote GruvboxYellow[J

line 996: hi! link clojureUnquote GruvboxYellow[J

line 997: [J

line 998: " }}}[J

line 999: " C: {{{[J

line 1000: [J

line 1001: hi! link cOperator GruvboxPurple[J

line 1002: hi! link cStructure GruvboxOrange[J

line 1003: [J

line 1004: " }}}[J

line 1005: " Python: {{{[J

line 1006: [J

line 1007: hi! link pythonBuiltin GruvboxOrange[J

line 1008: hi! link pythonBuiltinObj GruvboxOrange[J

line 1009: hi! link pythonBuiltinFunc GruvboxOrange[J

line 1010: hi! link pythonFunction GruvboxAqua[J

line 1011: hi! link pythonDecorator GruvboxRed[J

line 1012: hi! link pythonInclude GruvboxBlue[J

line 1013: hi! link pythonImport GruvboxBlue[J

line 1014: hi! link pythonRun GruvboxBlue[J

line 1015: hi! link pythonCoding GruvboxBlue[J

line 1016: hi! link pythonOperator GruvboxRed[J

line 1017: hi! link pythonException GruvboxRed[J

line 1018: hi! link pythonExceptions GruvboxPurple[J

line 1019: hi! link pythonBoolean GruvboxPurple[J

line 1020: hi! link pythonDot GruvboxFg3[J

line 1021: hi! link pythonConditional GruvboxRed[J

line 1022: hi! link pythonRepeat GruvboxRed[J

line 1023: hi! link pythonDottedName GruvboxGreenBold[J

line 1024: [J

line 1025: " }}}[J

line 1026: " CSS: {{{[J

line 1027: [J

line 1028: hi! link cssBraces GruvboxBlue[J

line 1029: hi! link cssFunctionName GruvboxYellow[J

line 1030: hi! link cssIdentifier GruvboxOrange[J

line 1031: hi! link cssClassName GruvboxGreen[J

line 1032: hi! link cssColor GruvboxBlue[J

line 1033: hi! link cssSelectorOp GruvboxBlue[J

line 1034: hi! link cssSelectorOp2 GruvboxBlue[J

line 1035: hi! link cssImportant GruvboxGreen[J

line 1036: hi! link cssVendor GruvboxFg1[J

line 1037: [J

line 1038: hi! link cssTextProp GruvboxAqua[J

line 1039: hi! link cssAnimationProp GruvboxAqua[J

line 1040: hi! link cssUIProp GruvboxYellow[J

line 1041: hi! link cssTransformProp GruvboxAqua[J

line 1042: hi! link cssTransitionProp GruvboxAqua[J

line 1043: hi! link cssPrintProp GruvboxAqua[J

line 1044: hi! link cssPositioningProp GruvboxYellow[J

line 1045: hi! link cssBoxProp GruvboxAqua[J

line 1046: hi! link cssFontDescriptorProp GruvboxAqua[J

line 1047: hi! link cssFlexibleBoxProp GruvboxAqua[J

line 1048: hi! link cssBorderOutlineProp GruvboxAqua[J

line 1049: hi! link cssBackgroundProp GruvboxAqua[J

line 1050: hi! link cssMarginProp GruvboxAqua[J

line 1051: hi! link cssListProp GruvboxAqua[J

line 1052: hi! link cssTableProp GruvboxAqua[J

line 1053: hi! link cssFontProp GruvboxAqua[J

line 1054: hi! link cssPaddingProp GruvboxAqua[J

line 1055: hi! link cssDimensionProp GruvboxAqua[J

line 1056: hi! link cssRenderProp GruvboxAqua[J

line 1057: hi! link cssColorProp GruvboxAqua[J

line 1058: hi! link cssGeneratedContentProp GruvboxAqua[J

line 1059: [J

line 1060: " }}}[J

line 1061: " JavaScript: {{{[J

line 1062: [J

line 1063: hi! link javaScriptBraces GruvboxFg1[J

line 1064: hi! link javaScriptFunction GruvboxAqua[J

line 1065: hi! link javaScriptIdentifier GruvboxRed[J

line 1066: hi! link javaScriptMember GruvboxBlue[J

line 1067: hi! link javaScriptNumber GruvboxPurple[J

line 1068: hi! link javaScriptNull GruvboxPurple[J

line 1069: hi! link javaScriptParens GruvboxFg3[J

line 1070: [J

line 1071: " }}}[J

line 1072: " YAJS: {{{[J

line 1073: [J

line 1074: hi! link javascriptImport GruvboxAqua[J

line 1075: hi! link javascriptExport GruvboxAqua[J

line 1076: hi! link javascriptClassKeyword GruvboxAqua[J

line 1077: hi! link javascriptClassExtends GruvboxAqua[J

line 1078: hi! link javascriptDefault GruvboxAqua[J

line 1079: [J

line 1080: hi! link javascriptClassName GruvboxYellow[J

line 1081: hi! link javascriptClassSuperName GruvboxYellow[J

line 1082: hi! link javascriptGlobal GruvboxYellow[J

line 1083: [J

line 1084: hi! link javascriptEndColons GruvboxFg1[J

line 1085: hi! link javascriptFuncArg GruvboxFg1[J

line 1086: hi! link javascriptGlobalMethod GruvboxFg1[J

line 1087: hi! link javascriptNodeGlobal GruvboxFg1[J

line 1088: hi! link javascriptBOMWindowProp GruvboxFg1[J

line 1089: hi! link javascriptArrayMethod GruvboxFg1[J

line 1090: hi! link javascriptArrayStaticMethod GruvboxFg1[J

line 1091: hi! link javascriptCacheMethod GruvboxFg1[J

line 1092: hi! link javascriptDateMethod GruvboxFg1[J

line 1093: hi! link javascriptMathStaticMethod GruvboxFg1[J

line 1094: [J

line 1095: " hi! link javascriptProp GruvboxFg1[J

line 1096: hi! link javascriptURLUtilsProp GruvboxFg1[J

line 1097: hi! link javascriptBOMNavigatorProp GruvboxFg1[J

line 1098: hi! link javascriptDOMDocMethod GruvboxFg1[J

line 1099: hi! link javascriptDOMDocProp GruvboxFg1[J

line 1100: hi! link javascriptBOMLocationMethod GruvboxFg1[J

line 1101: hi! link javascriptBOMWindowMethod GruvboxFg1[J

line 1102: hi! link javascriptStringMethod GruvboxFg1[J

line 1103: [J

line 1104: hi! link javascriptVariable GruvboxOrange[J

line 1105: " hi! link javascriptVariable GruvboxRed[J

line 1106: " hi! link javascriptIdentifier GruvboxOrange[J

line 1107: " hi! link javascriptClassSuper GruvboxOrange[J

line 1108: hi! link javascriptIdentifier GruvboxOrange[J

line 1109: hi! link javascriptClassSuper GruvboxOrange[J

line 1110: [J

line 1111: " hi! link javascriptFuncKeyword GruvboxOrange[J

line 1112: " hi! link javascriptAsyncFunc GruvboxOrange[J

line 1113: hi! link javascriptFuncKeyword GruvboxAqua[J

line 1114: hi! link javascriptAsyncFunc GruvboxAqua[J

line 1115: hi! link javascriptClassStatic GruvboxOrange[J

line 1116: [J

line 1117: hi! link javascriptOperator GruvboxRed[J

line 1118: hi! link javascriptForOperator GruvboxRed[J

line 1119: hi! link javascriptYield GruvboxRed[J

line 1120: hi! link javascriptExceptions GruvboxRed[J

line 1121: hi! link javascriptMessage GruvboxRed[J

line 1122: [J

line 1123: hi! link javascriptTemplateSB GruvboxAqua[J

line 1124: hi! link javascriptTemplateSubstitution GruvboxFg1[J

line 1125: [J

line 1126: " hi! link javascriptLabel GruvboxBlue[J

line 1127: " hi! link javascriptObjectLabel GruvboxBlue[J

line 1128: " hi! link javascriptPropertyName GruvboxBlue[J

line 1129: hi! link javascriptLabel GruvboxFg1[J

line 1130: hi! link javascriptObjectLabel GruvboxFg1[J

line 1131: hi! link javascriptPropertyName GruvboxFg1[J

line 1132: [J

line 1133: hi! link javascriptLogicSymbols GruvboxFg1[J

line 1134: hi! link javascriptArrowFunc GruvboxYellow[J

line 1135: [J

line 1136: hi! link javascriptDocParamName GruvboxFg4[J

line 1137: hi! link javascriptDocTags GruvboxFg4[J

line 1138: hi! link javascriptDocNotation GruvboxFg4[J

line 1139: hi! link javascriptDocParamType GruvboxFg4[J

line 1140: hi! link javascriptDocNamedParamType GruvboxFg4[J

line 1141: [J

line 1142: hi! link javascriptBrackets GruvboxFg1[J

line 1143: hi! link javascriptDOMElemAttrs GruvboxFg1[J

line 1144: hi! link javascriptDOMEventMethod GruvboxFg1[J

line 1145: hi! link javascriptDOMNodeMethod GruvboxFg1[J

line 1146: hi! link javascriptDOMStorageMethod GruvboxFg1[J

line 1147: hi! link javascriptHeadersMethod GruvboxFg1[J

line 1148: [J

line 1149: hi! link javascriptAsyncFuncKeyword GruvboxRed[J

line 1150: hi! link javascriptAwaitFuncKeyword GruvboxRed[J

line 1151: [J

line 1152: " }}}[J

line 1153: " PanglossJS: {{{[J

line 1154: [J

line 1155: hi! link jsClassKeyword GruvboxAqua[J

line 1156: hi! link jsExtendsKeyword GruvboxAqua[J

line 1157: hi! link jsExportDefault GruvboxAqua[J

line 1158: hi! link jsTemplateBraces GruvboxAqua[J

line 1159: hi! link jsGlobalNodeObjects GruvboxFg1[J

line 1160: hi! link jsGlobalObjects GruvboxFg1[J

line 1161: hi! link jsFunction GruvboxAqua[J

line 1162: hi! link jsFuncParens GruvboxFg3[J

line 1163: hi! link jsParens GruvboxFg3[J

line 1164: hi! link jsNull GruvboxPurple[J

line 1165: hi! link jsUndefined GruvboxPurple[J

line 1166: hi! link jsClassDefinition GruvboxYellow[J

line 1167: [J

line 1168: " }}}[J

line 1169: " TypeScript: {{{[J

line 1170: [J

line 1171: hi! link typeScriptReserved GruvboxAqua[J

line 1172: hi! link typeScriptLabel GruvboxAqua[J

line 1173: hi! link typeScriptFuncKeyword GruvboxAqua[J

line 1174: hi! link typeScriptIdentifier GruvboxOrange[J

line 1175: hi! link typeScriptBraces GruvboxFg1[J

line 1176: hi! link typeScriptEndColons GruvboxFg1[J

line 1177: hi! link typeScriptDOMObjects GruvboxFg1[J

line 1178: hi! link typeScriptAjaxMethods GruvboxFg1[J

line 1179: hi! link typeScriptLogicSymbols GruvboxFg1[J

line 1180: hi! link typeScriptDocSeeTag Comment[J

line 1181: hi! link typeScriptDocParam Comment[J

line 1182: hi! link typeScriptDocTags vimCommentTitle[J

line 1183: hi! link typeScriptGlobalObjects GruvboxFg1[J

line 1184: hi! link typeScriptParens GruvboxFg3[J

line 1185: hi! link typeScriptOpSymbols GruvboxFg3[J

line 1186: hi! link typeScriptHtmlElemProperties GruvboxFg1[J

line 1187: hi! link typeScriptNull GruvboxPurple[J

line 1188: hi! link typeScriptInterpolationDelimiter GruvboxAqua[J

line 1189: [J

line 1190: " }}}[J

line 1191: " PureScript: {{{[J

line 1192: [J

line 1193: hi! link purescriptModuleKeyword GruvboxAqua[J

line 1194: hi! link purescriptModuleName GruvboxFg1[J

line 1195: hi! link purescriptWhere GruvboxAqua[J

line 1196: hi! link purescriptDelimiter GruvboxFg4[J

line 1197: hi! link purescriptType GruvboxFg1[J

line 1198: hi! link purescriptImportKeyword GruvboxAqua[J

line 1199: hi! link purescriptHidingKeyword GruvboxAqua[J

line 1200: hi! link purescriptAsKeyword GruvboxAqua[J

line 1201: hi! link purescriptStructure GruvboxAqua[J

line 1202: hi! link purescriptOperator GruvboxBlue[J

line 1203: [J

line 1204: hi! link purescriptTypeVar GruvboxFg1[J

line 1205: hi! link purescriptConstructor GruvboxFg1[J

line 1206: hi! link purescriptFunction GruvboxFg1[J

line 1207: hi! link purescriptConditional GruvboxOrange[J

line 1208: hi! link purescriptBacktick GruvboxOrange[J

line 1209: [J

line 1210: " }}}[J

line 1211: " CoffeeScript: {{{[J

line 1212: [J

line 1213: hi! link coffeeExtendedOp GruvboxFg3[J

line 1214: hi! link coffeeSpecialOp GruvboxFg3[J

line 1215: hi! link coffeeCurly GruvboxOrange[J

line 1216: hi! link coffeeParen GruvboxFg3[J

line 1217: hi! link coffeeBracket GruvboxOrange[J

line 1218: [J

line 1219: " }}}[J

line 1220: " Ruby: {{{[J

line 1221: [J

line 1222: hi! link rubyStringDelimiter GruvboxGreen[J

line 1223: hi! link rubyInterpolationDelimiter GruvboxAqua[J

line 1224: [J

line 1225: " }}}[J

line 1226: " ObjectiveC: {{{[J

line 1227: [J

line 1228: hi! link objcTypeModifier GruvboxRed[J

line 1229: hi! link objcDirective GruvboxBlue[J

line 1230: [J

line 1231: " }}}[J

line 1232: " Go: {{{[J

line 1233: [J

line 1234: hi! link goDirective GruvboxAqua[J

line 1235: hi! link goConstants GruvboxPurple[J

line 1236: hi! link goDeclaration GruvboxRed[J

line 1237: hi! link goDeclType GruvboxBlue[J

line 1238: hi! link goBuiltins GruvboxOrange[J

line 1239: [J

line 1240: " }}}[J

line 1241: " Lua: {{{[J

line 1242: [J

line 1243: hi! link luaIn GruvboxRed[J

line 1244: hi! link luaFunction GruvboxAqua[J

line 1245: hi! link luaTable GruvboxOrange[J

line 1246: [J

line 1247: " }}}[J

line 1248: " MoonScript: {{{[J

line 1249: [J

line 1250: hi! link moonSpecialOp GruvboxFg3[J

line 1251: hi! link moonExtendedOp GruvboxFg3[J

line 1252: hi! link moonFunction GruvboxFg3[J

line 1253: hi! link moonObject GruvboxYellow[J

line 1254: [J

line 1255: " }}}[J

line 1256: " Java: {{{[J

line 1257: [J

line 1258: hi! link javaAnnotation GruvboxBlue[J

line 1259: hi! link javaDocTags GruvboxAqua[J

line 1260: hi! link javaCommentTitle vimCommentTitle[J

line 1261: hi! link javaParen GruvboxFg3[J

line 1262: hi! link javaParen1 GruvboxFg3[J

line 1263: hi! link javaParen2 GruvboxFg3[J

line 1264: hi! link javaParen3 GruvboxFg3[J

line 1265: hi! link javaParen4 GruvboxFg3[J

line 1266: hi! link javaParen5 GruvboxFg3[J

line 1267: hi! link javaOperator GruvboxOrange[J

line 1268: [J

line 1269: hi! link javaVarArg GruvboxGreen[J

line 1270: [J

line 1271: " }}}[J

line 1272: " Elixir: {{{[J

line 1273: [J

line 1274: hi! link elixirDocString Comment[J

line 1275: [J

line 1276: hi! link elixirStringDelimiter GruvboxGreen[J

line 1277: hi! link elixirInterpolationDelimiter GruvboxAqua[J

line 1278: [J

line 1279: hi! link elixirModuleDeclaration GruvboxYellow[J

line 1280: [J

line 1281: " }}}[J

line 1282: " Scala: {{{[J

line 1283: [J

line 1284: " NB: scala vim syntax file is kinda horrible[J

line 1285: hi! link scalaNameDefinition GruvboxFg1[J

line 1286: hi! link scalaCaseFollowing GruvboxFg1[J

line 1287: hi! link scalaCapitalWord GruvboxFg1[J

line 1288: hi! link scalaTypeExtension GruvboxFg1[J

line 1289: [J

line 1290: hi! link scalaKeyword GruvboxRed[J

line 1291: hi! link scalaKeywordModifier GruvboxRed[J

line 1292: [J

line 1293: hi! link scalaSpecial GruvboxAqua[J

line 1294: hi! link scalaOperator GruvboxFg1[J

line 1295: [J

line 1296: hi! link scalaTypeDeclaration GruvboxYellow[J

line 1297: hi! link scalaTypeTypePostDeclaration GruvboxYellow[J

line 1298: [J

line 1299: hi! link scalaInstanceDeclaration GruvboxFg1[J

line 1300: hi! link scalaInterpolation GruvboxAqua[J

line 1301: [J

line 1302: " }}}[J

line 1303: " Markdown: {{{[J

line 1304: [J

line 1305: call s:HL('markdownItalic', s:fg3, s:none, s:italic)[J

calling function <SNR>13_HL[J('markdownItalic', ['#bdae93', 248], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi markdownItalic guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 1306: [J

line 1307: hi! link markdownH1 GruvboxGreenBold[J

line 1308: hi! link markdownH2 GruvboxGreenBold[J

line 1309: hi! link markdownH3 GruvboxYellowBold[J

line 1310: hi! link markdownH4 GruvboxYellowBold[J

line 1311: hi! link markdownH5 GruvboxYellow[J

line 1312: hi! link markdownH6 GruvboxYellow[J

line 1313: [J

line 1314: hi! link markdownCode GruvboxAqua[J

line 1315: hi! link markdownCodeBlock GruvboxAqua[J

line 1316: hi! link markdownCodeDelimiter GruvboxAqua[J

line 1317: [J

line 1318: hi! link markdownBlockquote GruvboxGray[J

line 1319: hi! link markdownListMarker GruvboxGray[J

line 1320: hi! link markdownOrderedListMarker GruvboxGray[J

line 1321: hi! link markdownRule GruvboxGray[J

line 1322: hi! link markdownHeadingRule GruvboxGray[J

line 1323: [J

line 1324: hi! link markdownUrlDelimiter GruvboxFg3[J

line 1325: hi! link markdownLinkDelimiter GruvboxFg3[J

line 1326: hi! link markdownLinkTextDelimiter GruvboxFg3[J

line 1327: [J

line 1328: hi! link markdownHeadingDelimiter GruvboxOrange[J

line 1329: hi! link markdownUrl GruvboxPurple[J

line 1330: hi! link markdownUrlTitleDelimiter GruvboxGreen[J

line 1331: [J

line 1332: call s:HL('markdownLinkText', s:gray, s:none, s:underline)[J

calling function <SNR>13_HL[J('markdownLinkText', ['#928374', 245], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi markdownLinkText guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 1333: hi! link markdownIdDeclaration markdownLinkText[J

line 1334: [J

line 1335: " }}}[J

line 1336: " Haskell: {{{[J

line 1337: [J

line 1338: " hi! link haskellType GruvboxYellow[J

line 1339: " hi! link haskellOperators GruvboxOrange[J

line 1340: " hi! link haskellConditional GruvboxAqua[J

line 1341: " hi! link haskellLet GruvboxOrange[J

line 1342: "[J

line 1343: hi! link haskellType GruvboxFg1[J

line 1344: hi! link haskellIdentifier GruvboxFg1[J

line 1345: hi! link haskellSeparator GruvboxFg1[J

line 1346: hi! link haskellDelimiter GruvboxFg4[J

line 1347: hi! link haskellOperators GruvboxBlue[J

line 1348: "[J

line 1349: hi! link haskellBacktick GruvboxOrange[J

line 1350: hi! link haskellStatement GruvboxOrange[J

line 1351: hi! link haskellConditional GruvboxOrange[J

line 1352: [J

line 1353: hi! link haskellLet GruvboxAqua[J

line 1354: hi! link haskellDefault GruvboxAqua[J

line 1355: hi! link haskellWhere GruvboxAqua[J

line 1356: hi! link haskellBottom GruvboxAqua[J

line 1357: hi! link haskellBlockKeywords GruvboxAqua[J

line 1358: hi! link haskellImportKeywords GruvboxAqua[J

line 1359: hi! link haskellDeclKeyword GruvboxAqua[J

line 1360: hi! link haskellDeriving GruvboxAqua[J

line 1361: hi! link haskellAssocType GruvboxAqua[J

line 1362: [J

line 1363: hi! link haskellNumber GruvboxPurple[J

line 1364: hi! link haskellPragma GruvboxPurple[J

line 1365: [J

line 1366: hi! link haskellString GruvboxGreen[J

line 1367: hi! link haskellChar GruvboxGreen[J

line 1368: [J

line 1369: " }}}[J

line 1370: " Json: {{{[J

line 1371: [J

line 1372: hi! link jsonKeyword GruvboxGreen[J

line 1373: hi! link jsonQuote GruvboxGreen[J

line 1374: hi! link jsonBraces GruvboxFg1[J

line 1375: hi! link jsonString GruvboxFg1[J

line 1376: [J

line 1377: " }}}[J

line 1378: [J

line 1379: [J

line 1380: " Functions -------------------------------------------------------------------[J

line 1381: " Search Highlighting Cursor {{{[J

line 1382: [J

line 1383: function! GruvboxHlsShowCursor()[J

line 1386: [J

line 1387: function! GruvboxHlsHideCursor()[J

line 1390: [J

line 1391: " }}}[J

line 1392: [J

line 1393: " vim: set sw=2 ts=2 sts=2 et tw=80 ft=vim fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J
continuing in /Users/ygarrot/.vimrc[J
line 62: " colorscheme space-vim-dark[J

line 63: imap jj <Esc>[J

line 64: imap kk <Esc>[J

line 65: [J

line 66: nnoremap <C-x> :tabprevious<CR>[J

line 67: nnoremap <Tab> :tabnext<CR>[J

line 68: [J

line 69: [J

line 70: "move between tabs[J

line 71: inoremap <C-x> <Esc>:tabprevious<CR>[J

line 72: noremap <Tab>         :tabnext<CR>[J

line 73: [J

line 74: nnoremap <C-g> :Goyo 200<CR>[J

line 75: [J

line 76: let current_compiler = "gcc"[J

line 77: [J

line 78: execute "set rtp+=/Users/ygarrot/.opam/default/share/merlin/vim"[J

line 78: set rtp+=/Users/ygarrot/.opam/default/share/merlin/vim[J

line 79: [J

line 80: " let g:syntastic_ocaml_use_ocamlc = 1[J

line 81: let g:syntastic_ocaml_checkers = ['merlin'][J

line 82: [J

line 83: let g:syntastic_mode_map = { 'passive_filetypes': ['python'] }[J

line 84: let g:syntastic_always_populate_loc_list = 1[J

line 85: let g:syntastic_check_on_open = 1[J

line 86: let g:syntastic_check_on_wq = 0[J

line 87: let g:syntastic_cpp_compiler = 'gcc'[J

line 88: let g:syntastic_cpp_compiler_options = ' -std=c++11 -stdlib=libc++ -Wall -Werror -Wextra'[J

line 89: let g:syntastic_enable_signs=1[J

line 90: let g:syntastic_cpp_check_header = 1[J

line 91: let g:syntastic_cpp_remove_include_errors = 1[J

line 92: let g:syntastic_c_remove_include_errors = 1[J

line 93: let g:syntastic_c_include_dirs = ['../../../include', '../../include','../include','./include'][J

line 94: [J

line 95: set statusline+=%#warningmsg#[J

line 96: set statusline+=%{SyntasticStatuslineFlag()}[J

line 97: set statusline+=%*[J

line 98: [J

line 99: hi Comment guifg=#5C6370 ctermfg=59[J

line 100: hi Normal     ctermbg=NONE guibg=NONE[J

line 101: hi LineNr     ctermbg=NONE guibg=NONE[J

line 102: hi SignColumn ctermbg=NONE guibg=NONE[J

line 103: [J

line 104: " set fillchars+=vert:│[J

line 105: set clipboard=unnamedplus[J

line 106: " Some basics:[J

line 107: set nocompatible[J

line 108: filetype plugin on[J

Searching for "filetype.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/filetype.vim"[J
Searching for "/usr/share/vim/vimfiles/filetype.vim"[J
Searching for "/usr/share/vim/vim74/filetype.vim"[J
chdir(/usr/share/vim/vim74)[J
fchdir() to previous dir[J
line 108: sourcing "/usr/share/vim/vim74/filetype.vim"[J
line 1: " Vim support file to detect file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2015 Oct 13[J

line 5: [J

line 6: " Listen very carefully, I will say this only once[J

line 7: if exists("did_load_filetypes")[J

line 8:   finish[J

finished sourcing /usr/share/vim/vim74/filetype.vim[J
continuing in /Users/ygarrot/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/filetype.vim"[J
Searching for "/Users/ygarrot/.vim/after/filetype.vim"[J
Searching for "/Users/ygarrot/.opam/default/share/merlin/vim/filetype.vim"[J
Searching for "ftplugin.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/ftplugin.vim"[J
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"[J
Searching for "/usr/share/vim/vim74/ftplugin.vim"[J
chdir(/usr/share/vim/vim74)[J
fchdir() to previous dir[J
line 108: sourcing "/usr/share/vim/vim74/ftplugin.vim"[J
line 1: " Vim support file to switch on loading plugins for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2006 Apr 30[J

line 5: [J

line 6: if exists("did_load_ftplugin")[J

line 7:   finish[J

finished sourcing /usr/share/vim/vim74/ftplugin.vim[J
continuing in /Users/ygarrot/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/ftplugin.vim"[J
Searching for "/Users/ygarrot/.vim/after/ftplugin.vim"[J
Searching for "/Users/ygarrot/.opam/default/share/merlin/vim/ftplugin.vim"[J
line 109: syntax on[J

line 109: so $VIMRUNTIME/syntax/syntax.vim[J

chdir(/usr/share/vim/vim74/syntax)[J
fchdir() to previous dir[J
line 109: sourcing "/usr/share/vim/vim74/syntax/syntax.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 04[J

line 4: [J

line 5: " This file is used for ":syntax on".[J

line 6: " It installs the autocommands and starts highlighting for all buffers.[J

line 7: [J

line 8: if !has("syntax")[J

line 9:   finish[J

line 10: endif[J

line 11: [J

line 12: " If Syntax highlighting appears to be on already, turn it off first, so that[J

line 13: " any leftovers are cleared.[J

line 14: if exists("syntax_on") || exists("syntax_manual")[J

line 15:   so <sfile>:p:h/nosyntax.vim[J

chdir(/usr/share/vim/vim74/syntax)[J
fchdir() to previous dir[J
line 15: sourcing "/usr/share/vim/vim74/syntax/nosyntax.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2006 Apr 16[J

line 4: [J

line 5: " This file is used for ":syntax off".[J

line 6: " It removes the autocommands and stops highlighting for all buffers.[J

line 7: [J

line 8: if !has("syntax")[J

line 9:   finish[J

line 10: endif[J

line 11: [J

line 12: " Remove all autocommands for the Syntax event.  This also avoids that[J

line 13: " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.[J

line 14: au! Syntax[J

line 15: [J

line 16: " remove all syntax autocommands and remove the syntax for each buffer[J

line 17: augroup syntaxset[J

line 18:   au![J

line 19:   au BufEnter * syn clear[J

line 20:   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif[J

line 21:   doautoall syntaxset BufEnter *[J

line 22:   au![J

line 23: augroup END[J

line 24: [J

line 25: if exists("syntax_on")[J

line 26:   unlet syntax_on[J

line 27: endif[J

line 28: if exists("syntax_manual")[J

line 29:   unlet syntax_manual[J

line 30: endif[J

finished sourcing /usr/share/vim/vim74/syntax/nosyntax.vim[J
continuing in /usr/share/vim/vim74/syntax/syntax.vim[J
line 16: endif[J

line 17: [J

line 18: " Load the Syntax autocommands and set the default methods for highlighting.[J

line 19: runtime syntax/synload.vim[J

Searching for "syntax/synload.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/syntax/synload.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/syntax/synload.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"[J
Searching for "/usr/share/vim/vim74/syntax/synload.vim"[J
chdir(/usr/share/vim/vim74/syntax)[J
fchdir() to previous dir[J
line 19: sourcing "/usr/share/vim/vim74/syntax/synload.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2012 Sep 25[J

line 4: [J

line 5: " This file sets up for syntax highlighting.[J

line 6: " It is loaded from "syntax.vim" and "manual.vim".[J

line 7: " 1. Set the default highlight groups.[J

line 8: " 2. Install Syntax autocommands for all the available syntax files.[J

line 9: [J

line 10: if !has("syntax")[J

line 11:   finish[J

line 12: endif[J

line 13: [J

line 14: " let others know that syntax has been switched on[J

line 15: let syntax_on = 1[J

line 16: [J

line 17: " Set the default highlighting colors.  Use a color scheme if specified.[J

line 18: if exists("colors_name")[J

line 19:   exe "colors " . colors_name[J

line 19: colors gruvbox[J

Searching for "colors/gruvbox.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/colors/gruvbox.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim"[J
chdir(/Users/ygarrot/.vim/plugged/gruvbox/colors)[J
fchdir() to previous dir[J
line 19: sourcing "/Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim"[J
line 1: " -----------------------------------------------------------------------------[J

line 2: " File: gruvbox.vim[J

line 3: " Description: Retro groove color scheme for Vim[J

line 4: " Author: morhetz <morhetz@gmail.com>[J

line 5: " Source: https://github.com/morhetz/gruvbox[J

line 6: " Last Modified: 12 Aug 2017[J

line 7: " -----------------------------------------------------------------------------[J

line 8: [J

line 9: " Supporting code -------------------------------------------------------------[J

line 10: " Initialisation: {{{[J

line 11: [J

line 12: if version > 580[J

line 13:   hi clear[J

Searching for "syntax/syncolor.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim74/syntax)[J
fchdir() to previous dir[J
line 13: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim[J
continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.opam/default/share/merlin/vim/syntax/syncolor.vim"[J
line 14:   if exists("syntax_on")[J

line 15:     syntax reset[J

line 15: runtime! syntax/syncolor.vim[J

Searching for "syntax/syncolor.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim74/syntax)[J
fchdir() to previous dir[J
line 15: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi! link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi! link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi! link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi! link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi! link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi! link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi! link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi! link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi! link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi! link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi! link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi! link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi! link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi! link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi! link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi! link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi! link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi! link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi! link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi! link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi! link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi! link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi! link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi! link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim[J
continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/ygarrot/.opam/default/share/merlin/vim/syntax/syncolor.vim"[J
line 16:   endif[J

line 17: endif[J

line 18: [J

line 19: let g:colors_name='gruvbox'[J

line 20: [J

line 21: if !(has('termguicolors') && &termguicolors) && !has('gui_running') && &t_Co != 256[J

line 22:   finish[J

line 23: endif[J

line 24: [J

line 25: " }}}[J

line 26: " Global Settings: {{{[J

line 27: [J

line 28: if !exists('g:gruvbox_bold')[J

line 29:   let g:gruvbox_bold=1[J

line 30: endif[J

line 31: if !exists('g:gruvbox_italic')[J

line 32:   if has('gui_running') || $TERM_ITALICS == 'true'[J

line 33:     let g:gruvbox_italic=1[J

line 34:   else[J

line 35:     let g:gruvbox_italic=0[J

line 36:   endif[J

line 37: endif[J

line 38: if !exists('g:gruvbox_undercurl')[J

line 39:   let g:gruvbox_undercurl=1[J

line 40: endif[J

line 41: if !exists('g:gruvbox_underline')[J

line 42:   let g:gruvbox_underline=1[J

line 43: endif[J

line 44: if !exists('g:gruvbox_inverse')[J

line 45:   let g:gruvbox_inverse=1[J

line 46: endif[J

line 47: [J

line 48: if !exists('g:gruvbox_guisp_fallback') || index(['fg', 'bg'], g:gruvbox_guisp_fallback) == -1[J

line 49:   let g:gruvbox_guisp_fallback='NONE'[J

line 50: endif[J

line 51: [J

line 52: if !exists('g:gruvbox_improved_strings')[J

line 53:   let g:gruvbox_improved_strings=0[J

line 54: endif[J

line 55: [J

line 56: if !exists('g:gruvbox_improved_warnings')[J

line 57:   let g:gruvbox_improved_warnings=0[J

line 58: endif[J

line 59: [J

line 60: if !exists('g:gruvbox_termcolors')[J

line 61:   let g:gruvbox_termcolors=256[J

line 62: endif[J

line 63: [J

line 64: if !exists('g:gruvbox_invert_indent_guides')[J

line 65:   let g:gruvbox_invert_indent_guides=0[J

line 66: endif[J

line 67: [J

line 68: if exists('g:gruvbox_contrast')[J

line 69:   echo 'g:gruvbox_contrast is deprecated; use g:gruvbox_contrast_light and g:gruvbox_contrast_dark instead'[J

line 70: endif[J

line 71: [J

line 72: if !exists('g:gruvbox_contrast_dark')[J

line 73:   let g:gruvbox_contrast_dark='medium'[J

line 74: endif[J

line 75: [J

line 76: if !exists('g:gruvbox_contrast_light')[J

line 77:   let g:gruvbox_contrast_light='medium'[J

line 78: endif[J

line 79: [J

line 80: let s:is_dark=(&background == 'dark')[J

line 81: [J

line 82: " }}}[J

line 83: " Palette: {{{[J

line 84: [J

line 85: " setup palette dictionary[J

line 86: let s:gb = {}[J

line 87: [J

line 88: " fill it with absolute colors[J

line 89: let s:gb.dark0_hard  = ['#1d2021', 234]     " 29-32-33[J

line 90: let s:gb.dark0       = ['#282828', 235]     " 40-40-40[J

line 91: let s:gb.dark0_soft  = ['#32302f', 236]     " 50-48-47[J

line 92: let s:gb.dark1       = ['#3c3836', 237]     " 60-56-54[J

line 93: let s:gb.dark2       = ['#504945', 239]     " 80-73-69[J

line 94: let s:gb.dark3       = ['#665c54', 241]     " 102-92-84[J

line 95: let s:gb.dark4       = ['#7c6f64', 243]     " 124-111-100[J

line 96: let s:gb.dark4_256   = ['#7c6f64', 243]     " 124-111-100[J

line 97: [J

line 98: let s:gb.gray_245    = ['#928374', 245]     " 146-131-116[J

line 99: let s:gb.gray_244    = ['#928374', 244]     " 146-131-116[J

line 100: [J

line 101: let s:gb.light0_hard = ['#f9f5d7', 230]     " 249-245-215[J

line 102: let s:gb.light0      = ['#fbf1c7', 229]     " 253-244-193[J

line 103: let s:gb.light0_soft = ['#f2e5bc', 228]     " 242-229-188[J

line 104: let s:gb.light1      = ['#ebdbb2', 223]     " 235-219-178[J

line 105: let s:gb.light2      = ['#d5c4a1', 250]     " 213-196-161[J

line 106: let s:gb.light3      = ['#bdae93', 248]     " 189-174-147[J

line 107: let s:gb.light4      = ['#a89984', 246]     " 168-153-132[J

line 108: let s:gb.light4_256  = ['#a89984', 246]     " 168-153-132[J

line 109: [J

line 110: let s:gb.bright_red     = ['#fb4934', 167]     " 251-73-52[J

line 111: let s:gb.bright_green   = ['#b8bb26', 142]     " 184-187-38[J

line 112: let s:gb.bright_yellow  = ['#fabd2f', 214]     " 250-189-47[J

line 113: let s:gb.bright_blue    = ['#83a598', 109]     " 131-165-152[J

line 114: let s:gb.bright_purple  = ['#d3869b', 175]     " 211-134-155[J

line 115: let s:gb.bright_aqua    = ['#8ec07c', 108]     " 142-192-124[J

line 116: let s:gb.bright_orange  = ['#fe8019', 208]     " 254-128-25[J

line 117: [J

line 118: let s:gb.neutral_red    = ['#cc241d', 124]     " 204-36-29[J

line 119: let s:gb.neutral_green  = ['#98971a', 106]     " 152-151-26[J

line 120: let s:gb.neutral_yellow = ['#d79921', 172]     " 215-153-33[J

line 121: let s:gb.neutral_blue   = ['#458588', 66]      " 69-133-136[J

line 122: let s:gb.neutral_purple = ['#b16286', 132]     " 177-98-134[J

line 123: let s:gb.neutral_aqua   = ['#689d6a', 72]      " 104-157-106[J

line 124: let s:gb.neutral_orange = ['#d65d0e', 166]     " 214-93-14[J

line 125: [J

line 126: let s:gb.faded_red      = ['#9d0006', 88]      " 157-0-6[J

line 127: let s:gb.faded_green    = ['#79740e', 100]     " 121-116-14[J

line 128: let s:gb.faded_yellow   = ['#b57614', 136]     " 181-118-20[J

line 129: let s:gb.faded_blue     = ['#076678', 24]      " 7-102-120[J

line 130: let s:gb.faded_purple   = ['#8f3f71', 96]      " 143-63-113[J

line 131: let s:gb.faded_aqua     = ['#427b58', 66]      " 66-123-88[J

line 132: let s:gb.faded_orange   = ['#af3a03', 130]     " 175-58-3[J

line 133: [J

line 134: " }}}[J

line 135: " Setup Emphasis: {{{[J

line 136: [J

line 137: let s:bold = 'bold,'[J

line 138: if g:gruvbox_bold == 0[J

line 139:   let s:bold = ''[J

line 140: endif[J

line 141: [J

line 142: let s:italic = 'italic,'[J

line 143: if g:gruvbox_italic == 0[J

line 144:   let s:italic = ''[J

line 145: endif[J

line 146: [J

line 147: let s:underline = 'underline,'[J

line 148: if g:gruvbox_underline == 0[J

line 149:   let s:underline = ''[J

line 150: endif[J

line 151: [J

line 152: let s:undercurl = 'undercurl,'[J

line 153: if g:gruvbox_undercurl == 0[J

line 154:   let s:undercurl = ''[J

line 155: endif[J

line 156: [J

line 157: let s:inverse = 'inverse,'[J

line 158: if g:gruvbox_inverse == 0[J

line 159:   let s:inverse = ''[J

line 160: endif[J

line 161: [J

line 162: " }}}[J

line 163: " Setup Colors: {{{[J

line 164: [J

line 165: let s:vim_bg = ['bg', 'bg'][J

line 166: let s:vim_fg = ['fg', 'fg'][J

line 167: let s:none = ['NONE', 'NONE'][J

line 168: [J

line 169: " determine relative colors[J

line 170: if s:is_dark[J

line 171:   let s:bg0  = s:gb.dark0[J

line 172:   if g:gruvbox_contrast_dark == 'soft'[J

line 173:     let s:bg0  = s:gb.dark0_soft[J

line 174:   elseif g:gruvbox_contrast_dark == 'hard'[J

line 175:     let s:bg0  = s:gb.dark0_hard[J

line 176:   endif[J

line 177: [J

line 178:   let s:bg1  = s:gb.dark1[J

line 179:   let s:bg2  = s:gb.dark2[J

line 180:   let s:bg3  = s:gb.dark3[J

line 181:   let s:bg4  = s:gb.dark4[J

line 182: [J

line 183:   let s:gray = s:gb.gray_245[J

line 184: [J

line 185:   let s:fg0 = s:gb.light0[J

line 186:   let s:fg1 = s:gb.light1[J

line 187:   let s:fg2 = s:gb.light2[J

line 188:   let s:fg3 = s:gb.light3[J

line 189:   let s:fg4 = s:gb.light4[J

line 190: [J

line 191:   let s:fg4_256 = s:gb.light4_256[J

line 192: [J

line 193:   let s:red    = s:gb.bright_red[J

line 194:   let s:green  = s:gb.bright_green[J

line 195:   let s:yellow = s:gb.bright_yellow[J

line 196:   let s:blue   = s:gb.bright_blue[J

line 197:   let s:purple = s:gb.bright_purple[J

line 198:   let s:aqua   = s:gb.bright_aqua[J

line 199:   let s:orange = s:gb.bright_orange[J

line 200: else[J

line 201:   let s:bg0  = s:gb.light0[J

line 202:   if g:gruvbox_contrast_light == 'soft'[J

line 203:     let s:bg0  = s:gb.light0_soft[J

line 204:   elseif g:gruvbox_contrast_light == 'hard'[J

line 205:     let s:bg0  = s:gb.light0_hard[J

line 206:   endif[J

line 207: [J

line 208:   let s:bg1  = s:gb.light1[J

line 209:   let s:bg2  = s:gb.light2[J

line 210:   let s:bg3  = s:gb.light3[J

line 211:   let s:bg4  = s:gb.light4[J

line 212: [J

line 213:   let s:gray = s:gb.gray_244[J

line 214: [J

line 215:   let s:fg0 = s:gb.dark0[J

line 216:   let s:fg1 = s:gb.dark1[J

line 217:   let s:fg2 = s:gb.dark2[J

line 218:   let s:fg3 = s:gb.dark3[J

line 219:   let s:fg4 = s:gb.dark4[J

line 220: [J

line 221:   let s:fg4_256 = s:gb.dark4_256[J

line 222: [J

line 223:   let s:red    = s:gb.faded_red[J

line 224:   let s:green  = s:gb.faded_green[J

line 225:   let s:yellow = s:gb.faded_yellow[J

line 226:   let s:blue   = s:gb.faded_blue[J

line 227:   let s:purple = s:gb.faded_purple[J

line 228:   let s:aqua   = s:gb.faded_aqua[J

line 229:   let s:orange = s:gb.faded_orange[J

line 230: endif[J

line 231: [J

line 232: " reset to 16 colors fallback[J

line 233: if g:gruvbox_termcolors == 16[J

line 234:   let s:bg0[1]    = 0[J

line 235:   let s:fg4[1]    = 7[J

line 236:   let s:gray[1]   = 8[J

line 237:   let s:red[1]    = 9[J

line 238:   let s:green[1]  = 10[J

line 239:   let s:yellow[1] = 11[J

line 240:   let s:blue[1]   = 12[J

line 241:   let s:purple[1] = 13[J

line 242:   let s:aqua[1]   = 14[J

line 243:   let s:fg1[1]    = 15[J

line 244: endif[J

line 245: [J

line 246: " save current relative colors back to palette dictionary[J

line 247: let s:gb.bg0 = s:bg0[J

line 248: let s:gb.bg1 = s:bg1[J

line 249: let s:gb.bg2 = s:bg2[J

line 250: let s:gb.bg3 = s:bg3[J

line 251: let s:gb.bg4 = s:bg4[J

line 252: [J

line 253: let s:gb.gray = s:gray[J

line 254: [J

line 255: let s:gb.fg0 = s:fg0[J

line 256: let s:gb.fg1 = s:fg1[J

line 257: let s:gb.fg2 = s:fg2[J

line 258: let s:gb.fg3 = s:fg3[J

line 259: let s:gb.fg4 = s:fg4[J

line 260: [J

line 261: let s:gb.fg4_256 = s:fg4_256[J

line 262: [J

line 263: let s:gb.red    = s:red[J

line 264: let s:gb.green  = s:green[J

line 265: let s:gb.yellow = s:yellow[J

line 266: let s:gb.blue   = s:blue[J

line 267: let s:gb.purple = s:purple[J

line 268: let s:gb.aqua   = s:aqua[J

line 269: let s:gb.orange = s:orange[J

line 270: [J

line 271: " }}}[J

line 272: " Setup Terminal Colors For Neovim: {{{[J

line 273: [J

line 274: if has('nvim')[J

line 275:   let g:terminal_color_0 = s:bg0[0][J

line 276:   let g:terminal_color_8 = s:gray[0][J

line 277: [J

line 278:   let g:terminal_color_1 = s:gb.neutral_red[0][J

line 279:   let g:terminal_color_9 = s:red[0][J

line 280: [J

line 281:   let g:terminal_color_2 = s:gb.neutral_green[0][J

line 282:   let g:terminal_color_10 = s:green[0][J

line 283: [J

line 284:   let g:terminal_color_3 = s:gb.neutral_yellow[0][J

line 285:   let g:terminal_color_11 = s:yellow[0][J

line 286: [J

line 287:   let g:terminal_color_4 = s:gb.neutral_blue[0][J

line 288:   let g:terminal_color_12 = s:blue[0][J

line 289: [J

line 290:   let g:terminal_color_5 = s:gb.neutral_purple[0][J

line 291:   let g:terminal_color_13 = s:purple[0][J

line 292: [J

line 293:   let g:terminal_color_6 = s:gb.neutral_aqua[0][J

line 294:   let g:terminal_color_14 = s:aqua[0][J

line 295: [J

line 296:   let g:terminal_color_7 = s:fg4[0][J

line 297:   let g:terminal_color_15 = s:fg1[0][J

line 298: endif[J

line 299: [J

line 300: " }}}[J

line 301: " Overload Setting: {{{[J

line 302: [J

line 303: let s:hls_cursor = s:orange[J

line 304: if exists('g:gruvbox_hls_cursor')[J

line 305:   let s:hls_cursor = get(s:gb, g:gruvbox_hls_cursor)[J

line 306: endif[J

line 307: [J

line 308: let s:number_column = s:none[J

line 309: if exists('g:gruvbox_number_column')[J

line 310:   let s:number_column = get(s:gb, g:gruvbox_number_column)[J

line 311: endif[J

line 312: [J

line 313: let s:sign_column = s:bg1[J

line 314: [J

line 316: if exists('g:gitgutter_override_sign_column_highlight') && g:gitgutter_override_sign_column_highlight == 1[J

line 317:   let s:sign_column = s:number_column[J

line 318: else[J

line 319:   let g:gitgutter_override_sign_column_highlight = 0[J

line 320: [J

line 321:   if exists('g:gruvbox_sign_column')[J

line 322:     let s:sign_column = get(s:gb, g:gruvbox_sign_column)[J

line 323:   endif[J

line 324: endif[J

line 325: [J

line 326: let s:color_column = s:bg1[J

line 327: if exists('g:gruvbox_color_column')[J

line 328:   let s:color_column = get(s:gb, g:gruvbox_color_column)[J

line 329: endif[J

line 330: [J

line 331: let s:vert_split = s:bg0[J

line 332: if exists('g:gruvbox_vert_split')[J

line 333:   let s:vert_split = get(s:gb, g:gruvbox_vert_split)[J

line 334: endif[J

line 335: [J

line 336: let s:invert_signs = ''[J

line 337: if exists('g:gruvbox_invert_signs')[J

line 338:   if g:gruvbox_invert_signs == 1[J

line 339:     let s:invert_signs = s:inverse[J

line 340:   endif[J

line 341: endif[J

line 342: [J

line 343: let s:invert_selection = s:inverse[J

line 344: if exists('g:gruvbox_invert_selection')[J

line 345:   if g:gruvbox_invert_selection == 0[J

line 346:     let s:invert_selection = ''[J

line 347:   endif[J

line 348: endif[J

line 349: [J

line 350: let s:invert_tabline = ''[J

line 351: if exists('g:gruvbox_invert_tabline')[J

line 352:   if g:gruvbox_invert_tabline == 1[J

line 353:     let s:invert_tabline = s:inverse[J

line 354:   endif[J

line 355: endif[J

line 356: [J

line 357: let s:italicize_comments = s:italic[J

line 358: if exists('g:gruvbox_italicize_comments')[J

line 359:   if g:gruvbox_italicize_comments == 0[J

line 360:     let s:italicize_comments = ''[J

line 361:   endif[J

line 362: endif[J

line 363: [J

line 364: let s:italicize_strings = ''[J

line 365: if exists('g:gruvbox_italicize_strings')[J

line 366:   if g:gruvbox_italicize_strings == 1[J

line 367:     let s:italicize_strings = s:italic[J

line 368:   endif[J

line 369: endif[J

line 370: [J

line 371: " }}}[J

line 372: " Highlighting Function: {{{[J

line 373: [J

line 374: function! s:HL(group, fg, ...)[J

line 419: [J

line 420: " }}}[J

line 421: " Gruvbox Hi Groups: {{{[J

line 422: [J

line 423: " memoize common hi groups[J

line 424: call s:HL('GruvboxFg0', s:fg0)[J

calling function <SNR>13_HL[J('GruvboxFg0', ['#fbf1c7', 229])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg0 guifg=#fbf1c7 ctermfg=229 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 425: call s:HL('GruvboxFg1', s:fg1)[J

calling function <SNR>13_HL[J('GruvboxFg1', ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg1 guifg=#ebdbb2 ctermfg=223 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 426: call s:HL('GruvboxFg2', s:fg2)[J

calling function <SNR>13_HL[J('GruvboxFg2', ['#d5c4a1', 250])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg2 guifg=#d5c4a1 ctermfg=250 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 427: call s:HL('GruvboxFg3', s:fg3)[J

calling function <SNR>13_HL[J('GruvboxFg3', ['#bdae93', 248])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg3 guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 428: call s:HL('GruvboxFg4', s:fg4)[J

calling function <SNR>13_HL[J('GruvboxFg4', ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxFg4 guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 429: call s:HL('GruvboxGray', s:gray)[J

calling function <SNR>13_HL[J('GruvboxGray', ['#928374', 245])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxGray guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 430: call s:HL('GruvboxBg0', s:bg0)[J

calling function <SNR>13_HL[J('GruvboxBg0', ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg0 guifg=#1d2021 ctermfg=234 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 431: call s:HL('GruvboxBg1', s:bg1)[J

calling function <SNR>13_HL[J('GruvboxBg1', ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg1 guifg=#3c3836 ctermfg=237 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 432: call s:HL('GruvboxBg2', s:bg2)[J

calling function <SNR>13_HL[J('GruvboxBg2', ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg2 guifg=#504945 ctermfg=239 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 433: call s:HL('GruvboxBg3', s:bg3)[J

calling function <SNR>13_HL[J('GruvboxBg3', ['#665c54', 241])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg3 guifg=#665c54 ctermfg=241 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 434: call s:HL('GruvboxBg4', s:bg4)[J

calling function <SNR>13_HL[J('GruvboxBg4', ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBg4 guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 435: [J

line 436: call s:HL('GruvboxRed', s:red)[J

calling function <SNR>13_HL[J('GruvboxRed', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxRed guifg=#fb4934 ctermfg=167 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 437: call s:HL('GruvboxRedBold', s:red, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxRedBold', ['#fb4934', 167], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxRedBold guifg=#fb4934 ctermfg=167 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 438: call s:HL('GruvboxGreen', s:green)[J

calling function <SNR>13_HL[J('GruvboxGreen', ['#b8bb26', 142])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxGreen guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 439: call s:HL('GruvboxGreenBold', s:green, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxGreenBold', ['#b8bb26', 142], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxGreenBold guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 440: call s:HL('GruvboxYellow', s:yellow)[J

calling function <SNR>13_HL[J('GruvboxYellow', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxYellow guifg=#fabd2f ctermfg=214 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 441: call s:HL('GruvboxYellowBold', s:yellow, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxYellowBold', ['#fabd2f', 214], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxYellowBold guifg=#fabd2f ctermfg=214 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 442: call s:HL('GruvboxBlue', s:blue)[J

calling function <SNR>13_HL[J('GruvboxBlue', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBlue guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 443: call s:HL('GruvboxBlueBold', s:blue, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxBlueBold', ['#83a598', 109], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBlueBold guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 444: call s:HL('GruvboxPurple', s:purple)[J

calling function <SNR>13_HL[J('GruvboxPurple', ['#d3869b', 175])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxPurple guifg=#d3869b ctermfg=175 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 445: call s:HL('GruvboxPurpleBold', s:purple, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxPurpleBold', ['#d3869b', 175], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxPurpleBold guifg=#d3869b ctermfg=175 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 446: call s:HL('GruvboxAqua', s:aqua)[J

calling function <SNR>13_HL[J('GruvboxAqua', ['#8ec07c', 108])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxAqua guifg=#8ec07c ctermfg=108 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 447: call s:HL('GruvboxAquaBold', s:aqua, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxAquaBold', ['#8ec07c', 108], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxAquaBold guifg=#8ec07c ctermfg=108 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 448: call s:HL('GruvboxOrange', s:orange)[J

calling function <SNR>13_HL[J('GruvboxOrange', ['#fe8019', 208])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxOrange guifg=#fe8019 ctermfg=208 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 449: call s:HL('GruvboxOrangeBold', s:orange, s:none, s:bold)[J

calling function <SNR>13_HL[J('GruvboxOrangeBold', ['#fe8019', 208], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxOrangeBold guifg=#fe8019 ctermfg=208 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 450: [J

line 451: call s:HL('GruvboxRedSign', s:red, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxRedSign', ['#fb4934', 167], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxRedSign guifg=#fb4934 ctermfg=167 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 452: call s:HL('GruvboxGreenSign', s:green, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxGreenSign', ['#b8bb26', 142], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxGreenSign guifg=#b8bb26 ctermfg=142 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 453: call s:HL('GruvboxYellowSign', s:yellow, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxYellowSign', ['#fabd2f', 214], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxYellowSign guifg=#fabd2f ctermfg=214 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 454: call s:HL('GruvboxBlueSign', s:blue, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxBlueSign', ['#83a598', 109], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxBlueSign guifg=#83a598 ctermfg=109 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 455: call s:HL('GruvboxPurpleSign', s:purple, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxPurpleSign', ['#d3869b', 175], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxPurpleSign guifg=#d3869b ctermfg=175 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 456: call s:HL('GruvboxAquaSign', s:aqua, s:sign_column, s:invert_signs)[J

calling function <SNR>13_HL[J('GruvboxAquaSign', ['#8ec07c', 108], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi GruvboxAquaSign guifg=#8ec07c ctermfg=108 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 457: [J

line 458: " }}}[J

line 459: [J

line 460: " Vanilla colorscheme ---------------------------------------------------------[J

line 461: " General UI: {{{[J

line 462: [J

line 463: " Normal text[J

line 464: call s:HL('Normal', s:fg1, s:bg0)[J

calling function <SNR>13_HL[J('Normal', ['#ebdbb2', 223], ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Normal guifg=#ebdbb2 ctermfg=223 guibg=#1d2021 ctermbg=234 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 465: [J

line 466: " Correct background (see issue #7):[J

line 467: " --- Problem with changing between dark and light on 256 color terminal[J

line 468: " --- https://github.com/morhetz/gruvbox/issues/7[J

line 469: if s:is_dark[J

line 470:   set background=dark[J

line 471: else[J

line 472:   set background=light[J

line 473: endif[J

line 474: [J

line 475: if version >= 700[J

line 476:   " Screen line that the cursor is[J

line 477:   call s:HL('CursorLine',   s:none, s:bg1)[J

calling function <SNR>13_HL[J('CursorLine', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CursorLine guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 478:   " Screen column that the cursor is[J

line 479:   hi! link CursorColumn CursorLine[J

line 480: [J

line 481:   " Tab pages line filler[J

line 482:   call s:HL('TabLineFill', s:bg4, s:bg1, s:invert_tabline)[J

calling function <SNR>13_HL[J('TabLineFill', ['#7c6f64', 243], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi TabLineFill guifg=#7c6f64 ctermfg=243 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 483:   " Active tab page label[J

line 484:   call s:HL('TabLineSel', s:green, s:bg1, s:invert_tabline)[J

calling function <SNR>13_HL[J('TabLineSel', ['#b8bb26', 142], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi TabLineSel guifg=#b8bb26 ctermfg=142 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 485:   " Not active tab page label[J

line 486:   hi! link TabLine TabLineFill[J

line 487: [J

line 488:   " Match paired bracket under the cursor[J

line 489:   call s:HL('MatchParen', s:none, s:bg3, s:bold)[J

calling function <SNR>13_HL[J('MatchParen', ['NONE', 'NONE'], ['#665c54', 241], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi MatchParen guifg=NONE ctermfg=NONE guibg=#665c54 ctermbg=241 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 490: endif[J

line 491: [J

line 492: if version >= 703[J

line 493:   " Highlighted screen columns[J

line 494:   call s:HL('ColorColumn',  s:none, s:color_column)[J

calling function <SNR>13_HL[J('ColorColumn', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ColorColumn guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 495: [J

line 496:   " Concealed element: \lambda → λ[J

line 497:   call s:HL('Conceal', s:blue, s:none)[J

calling function <SNR>13_HL[J('Conceal', ['#83a598', 109], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Conceal guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 498: [J

line 499:   " Line number of CursorLine[J

line 500:   call s:HL('CursorLineNr', s:yellow, s:bg1)[J

calling function <SNR>13_HL[J('CursorLineNr', ['#fabd2f', 214], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CursorLineNr guifg=#fabd2f ctermfg=214 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 501: endif[J

line 502: [J

line 503: hi! link NonText GruvboxBg2[J

line 504: hi! link SpecialKey GruvboxBg2[J

line 505: [J

line 506: call s:HL('Visual',    s:none,  s:bg3, s:invert_selection)[J

calling function <SNR>13_HL[J('Visual', ['NONE', 'NONE'], ['#665c54', 241], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Visual guifg=NONE ctermfg=NONE guibg=#665c54 ctermbg=241 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 507: hi! link VisualNOS Visual[J

line 508: [J

line 509: call s:HL('Search',    s:yellow, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('Search', ['#fabd2f', 214], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Search guifg=#fabd2f ctermfg=214 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 510: call s:HL('IncSearch', s:hls_cursor, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('IncSearch', ['#fe8019', 208], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi IncSearch guifg=#fe8019 ctermfg=208 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 511: [J

line 512: call s:HL('Underlined', s:blue, s:none, s:underline)[J

calling function <SNR>13_HL[J('Underlined', ['#83a598', 109], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Underlined guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 513: [J

line 514: call s:HL('StatusLine',   s:bg2, s:fg1, s:inverse)[J

calling function <SNR>13_HL[J('StatusLine', ['#504945', 239], ['#ebdbb2', 223], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi StatusLine guifg=#504945 ctermfg=239 guibg=#ebdbb2 ctermbg=223 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 515: call s:HL('StatusLineNC', s:bg1, s:fg4, s:inverse)[J

calling function <SNR>13_HL[J('StatusLineNC', ['#3c3836', 237], ['#a89984', 246], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi StatusLineNC guifg=#3c3836 ctermfg=237 guibg=#a89984 ctermbg=246 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 516: [J

line 517: " The column separating vertically split windows[J

line 518: call s:HL('VertSplit', s:bg3, s:vert_split)[J

calling function <SNR>13_HL[J('VertSplit', ['#665c54', 241], ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi VertSplit guifg=#665c54 ctermfg=241 guibg=#1d2021 ctermbg=234 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 519: [J

line 520: " Current match in wildmenu completion[J

line 521: call s:HL('WildMenu', s:blue, s:bg2, s:bold)[J

calling function <SNR>13_HL[J('WildMenu', ['#83a598', 109], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi WildMenu guifg=#83a598 ctermfg=109 guibg=#504945 ctermbg=239 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 522: [J

line 523: " Directory names, special names in listing[J

line 524: hi! link Directory GruvboxGreenBold[J

line 525: [J

line 526: " Titles for output from :set all, :autocmd, etc.[J

line 527: hi! link Title GruvboxGreenBold[J

line 528: [J

line 529: " Error messages on the command line[J

line 530: call s:HL('ErrorMsg',   s:bg0, s:red, s:bold)[J

calling function <SNR>13_HL[J('ErrorMsg', ['#1d2021', 234], ['#fb4934', 167], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ErrorMsg guifg=#1d2021 ctermfg=234 guibg=#fb4934 ctermbg=167 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 531: " More prompt: -- More --[J

line 532: hi! link MoreMsg GruvboxYellowBold[J

line 533: " Current mode message: -- INSERT --[J

line 534: hi! link ModeMsg GruvboxYellowBold[J

line 535: " 'Press enter' prompt and yes/no questions[J

line 536: hi! link Question GruvboxOrangeBold[J

line 537: " Warning messages[J

line 538: hi! link WarningMsg GruvboxRedBold[J

line 539: [J

line 540: " }}}[J

line 541: " Gutter: {{{[J

line 542: [J

line 543: " Line number for :number and :# commands[J

line 544: call s:HL('LineNr', s:bg4, s:number_column)[J

calling function <SNR>13_HL[J('LineNr', ['#7c6f64', 243], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi LineNr guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 545: [J

line 546: " Column where signs are displayed[J

line 547: call s:HL('SignColumn', s:none, s:sign_column)[J

calling function <SNR>13_HL[J('SignColumn', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SignColumn guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 548: [J

line 549: " Line used for closed folds[J

line 550: call s:HL('Folded', s:gray, s:bg1, s:italic)[J

calling function <SNR>13_HL[J('Folded', ['#928374', 245], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Folded guifg=#928374 ctermfg=245 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 551: " Column where folds are displayed[J

line 552: call s:HL('FoldColumn', s:gray, s:bg1)[J

calling function <SNR>13_HL[J('FoldColumn', ['#928374', 245], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi FoldColumn guifg=#928374 ctermfg=245 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 553: [J

line 554: " }}}[J

line 555: " Cursor: {{{[J

line 556: [J

line 557: " Character under cursor[J

line 558: call s:HL('Cursor', s:none, s:none, s:inverse)[J

calling function <SNR>13_HL[J('Cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 559: " Visual mode cursor, selection[J

line 560: hi! link vCursor Cursor[J

line 561: " Input moder cursor[J

line 562: hi! link iCursor Cursor[J

line 563: " Language mapping cursor[J

line 564: hi! link lCursor Cursor[J

line 565: [J

line 566: " }}}[J

line 567: " Syntax Highlighting: {{{[J

line 568: [J

line 569: if g:gruvbox_improved_strings == 0[J

line 570:   hi! link Special GruvboxOrange[J

line 571: else[J

line 572:   call s:HL('Special', s:orange, s:bg1, s:italicize_strings)[J

line 573: endif[J

line 574: [J

line 575: call s:HL('Comment', s:gray, s:none, s:italicize_comments)[J

calling function <SNR>13_HL[J('Comment', ['#928374', 245], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Comment guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 576: call s:HL('Todo', s:vim_fg, s:vim_bg, s:bold . s:italic)[J

calling function <SNR>13_HL[J('Todo', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Todo guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 577: call s:HL('Error', s:red, s:vim_bg, s:bold . s:inverse)[J

calling function <SNR>13_HL[J('Error', ['#fb4934', 167], ['bg', 'bg'], 'bold,inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Error guifg=#fb4934 ctermfg=167 guibg=bg ctermbg=bg gui=bold,inverse cterm=bold,inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 578: [J

line 579: " Generic statement[J

line 580: hi! link Statement GruvboxRed[J

line 581: " if, then, else, endif, swicth, etc.[J

line 582: hi! link Conditional GruvboxRed[J

line 583: " for, do, while, etc.[J

line 584: hi! link Repeat GruvboxRed[J

line 585: " case, default, etc.[J

line 586: hi! link Label GruvboxRed[J

line 587: " try, catch, throw[J

line 588: hi! link Exception GruvboxRed[J

line 589: " sizeof, "+", "*", etc.[J

line 590: hi! link Operator Normal[J

line 591: " Any other keyword[J

line 592: hi! link Keyword GruvboxRed[J

line 593: [J

line 594: " Variable name[J

line 595: hi! link Identifier GruvboxBlue[J

line 596: " Function name[J

line 597: hi! link Function GruvboxGreenBold[J

line 598: [J

line 599: " Generic preprocessor[J

line 600: hi! link PreProc GruvboxAqua[J

line 601: " Preprocessor #include[J

line 602: hi! link Include GruvboxAqua[J

line 603: " Preprocessor #define[J

line 604: hi! link Define GruvboxAqua[J

line 605: " Same as Define[J

line 606: hi! link Macro GruvboxAqua[J

line 607: " Preprocessor #if, #else, #endif, etc.[J

line 608: hi! link PreCondit GruvboxAqua[J

line 609: [J

line 610: " Generic constant[J

line 611: hi! link Constant GruvboxPurple[J

line 612: " Character constant: 'c', '/n'[J

line 613: hi! link Character GruvboxPurple[J

line 614: " String constant: "this is a string"[J

line 615: if g:gruvbox_improved_strings == 0[J

line 616:   call s:HL('String',  s:green, s:none, s:italicize_strings)[J

calling function <SNR>13_HL[J('String', ['#b8bb26', 142], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi String guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 617: else[J

line 618:   call s:HL('String',  s:fg1, s:bg1, s:italicize_strings)[J

line 619: endif[J

line 620: " Boolean constant: TRUE, false[J

line 621: hi! link Boolean GruvboxPurple[J

line 622: " Number constant: 234, 0xff[J

line 623: hi! link Number GruvboxPurple[J

line 624: " Floating point constant: 2.3e10[J

line 625: hi! link Float GruvboxPurple[J

line 626: [J

line 627: " Generic type[J

line 628: hi! link Type GruvboxYellow[J

line 629: " static, register, volatile, etc[J

line 630: hi! link StorageClass GruvboxOrange[J

line 631: " struct, union, enum, etc.[J

line 632: hi! link Structure GruvboxAqua[J

line 633: " typedef[J

line 634: hi! link Typedef GruvboxYellow[J

line 635: [J

line 636: " }}}[J

line 637: " Completion Menu: {{{[J

line 638: [J

line 639: if version >= 700[J

line 640:   " Popup menu: normal item[J

line 641:   call s:HL('Pmenu', s:fg1, s:bg2)[J

calling function <SNR>13_HL[J('Pmenu', ['#ebdbb2', 223], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi Pmenu guifg=#ebdbb2 ctermfg=223 guibg=#504945 ctermbg=239 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 642:   " Popup menu: selected item[J

line 643:   call s:HL('PmenuSel', s:bg2, s:blue, s:bold)[J

calling function <SNR>13_HL[J('PmenuSel', ['#504945', 239], ['#83a598', 109], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi PmenuSel guifg=#504945 ctermfg=239 guibg=#83a598 ctermbg=109 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 644:   " Popup menu: scrollbar[J

line 645:   call s:HL('PmenuSbar', s:none, s:bg2)[J

calling function <SNR>13_HL[J('PmenuSbar', ['NONE', 'NONE'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi PmenuSbar guifg=NONE ctermfg=NONE guibg=#504945 ctermbg=239 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 646:   " Popup menu: scrollbar thumb[J

line 647:   call s:HL('PmenuThumb', s:none, s:bg4)[J

calling function <SNR>13_HL[J('PmenuThumb', ['NONE', 'NONE'], ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi PmenuThumb guifg=NONE ctermfg=NONE guibg=#7c6f64 ctermbg=243 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 648: endif[J

line 649: [J

line 650: " }}}[J

line 651: " Diffs: {{{[J

line 652: [J

line 653: call s:HL('DiffDelete', s:red, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('DiffDelete', ['#fb4934', 167], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi DiffDelete guifg=#fb4934 ctermfg=167 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 654: call s:HL('DiffAdd',    s:green, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('DiffAdd', ['#b8bb26', 142], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi DiffAdd guifg=#b8bb26 ctermfg=142 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 655: "call s:HL('DiffChange', s:bg0, s:blue)[J

line 656: "call s:HL('DiffText',   s:bg0, s:yellow)[J

line 657: [J

line 658: " Alternative setting[J

line 659: call s:HL('DiffChange', s:aqua, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('DiffChange', ['#8ec07c', 108], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi DiffChange guifg=#8ec07c ctermfg=108 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 660: call s:HL('DiffText',   s:yellow, s:bg0, s:inverse)[J

calling function <SNR>13_HL[J('DiffText', ['#fabd2f', 214], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi DiffText guifg=#fabd2f ctermfg=214 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 661: [J

line 662: " }}}[J

line 663: " Spelling: {{{[J

line 664: [J

line 665: if has("spell")[J

line 666:   " Not capitalised word, or compile warnings[J

line 667:   if g:gruvbox_improved_warnings == 0[J

line 668:     call s:HL('SpellCap',   s:none, s:none, s:undercurl, s:red)[J

calling function <SNR>13_HL[J('SpellCap', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SpellCap guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 669:   else[J

line 670:     call s:HL('SpellCap',   s:green, s:none, s:bold . s:italic)[J

line 671:   endif[J

line 672:   " Not recognized word[J

line 673:   call s:HL('SpellBad',   s:none, s:none, s:undercurl, s:blue)[J

calling function <SNR>13_HL[J('SpellBad', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SpellBad guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#83a598[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 674:   " Wrong spelling for selected region[J

line 675:   call s:HL('SpellLocal', s:none, s:none, s:undercurl, s:aqua)[J

calling function <SNR>13_HL[J('SpellLocal', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#8ec07c', 108])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SpellLocal guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#8ec07c[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 676:   " Rare word[J

line 677:   call s:HL('SpellRare',  s:none, s:none, s:undercurl, s:purple)[J

calling function <SNR>13_HL[J('SpellRare', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#d3869b', 175])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SpellRare guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#d3869b[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 678: endif[J

line 679: [J

line 680: " }}}[J

line 681: [J

line 682: " Plugin specific -------------------------------------------------------------[J

line 683: " EasyMotion: {{{[J

line 684: [J

line 685: hi! link EasyMotionTarget Search[J

line 686: hi! link EasyMotionShade Comment[J

line 687: [J

line 688: " }}}[J

line 689: " Sneak: {{{[J

line 690: [J

line 691: hi! link Sneak Search[J

line 692: hi! link SneakLabel Search[J

line 693: [J

line 694: " }}}[J

line 695: " Indent Guides: {{{[J

line 696: [J

line 697: if !exists('g:indent_guides_auto_colors')[J

line 698:   let g:indent_guides_auto_colors = 0[J

line 699: endif[J

line 700: [J

line 701: if g:indent_guides_auto_colors == 0[J

line 702:   if g:gruvbox_invert_indent_guides == 0[J

line 703:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2)[J

calling function <SNR>13_HL[J('IndentGuidesOdd', ['bg', 'bg'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi IndentGuidesOdd guifg=bg ctermfg=bg guibg=#504945 ctermbg=239 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 704:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg1)[J

calling function <SNR>13_HL[J('IndentGuidesEven', ['bg', 'bg'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi IndentGuidesEven guifg=bg ctermfg=bg guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 705:   else[J

line 706:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2, s:inverse)[J

line 707:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg3, s:inverse)[J

line 708:   endif[J

line 709: endif[J

line 710: [J

line 711: " }}}[J

line 712: " IndentLine: {{{[J

line 713: [J

line 714: if !exists('g:indentLine_color_term')[J

line 715:   let g:indentLine_color_term = s:bg2[1][J

line 716: endif[J

line 717: if !exists('g:indentLine_color_gui')[J

line 718:   let g:indentLine_color_gui = s:bg2[0][J

line 719: endif[J

line 720: [J

line 721: " }}}[J

line 722: " Rainbow Parentheses: {{{[J

line 723: [J

line 724: if !exists('g:rbpt_colorpairs')[J

line 729:   let g:rbpt_colorpairs = [ ['blue', '#458588'], ['magenta', '#b16286'], ['red',  '#cc241d'], ['166',     '#d65d0e'] ][J

line 730: endif[J

line 731: [J

line 732: let g:rainbow_guifgs = [ '#d65d0e', '#cc241d', '#b16286', '#458588' ][J

line 733: let g:rainbow_ctermfgs = [ '166', 'red', 'magenta', 'blue' ][J

line 734: [J

line 735: if !exists('g:rainbow_conf')[J

line 736:    let g:rainbow_conf = {}[J

line 737: endif[J

line 738: if !has_key(g:rainbow_conf, 'guifgs')[J

line 739:    let g:rainbow_conf['guifgs'] = g:rainbow_guifgs[J

line 740: endif[J

line 741: if !has_key(g:rainbow_conf, 'ctermfgs')[J

line 742:    let g:rainbow_conf['ctermfgs'] = g:rainbow_ctermfgs[J

line 743: endif[J

line 744: [J

line 745: let g:niji_dark_colours = g:rbpt_colorpairs[J

line 746: let g:niji_light_colours = g:rbpt_colorpairs[J

line 747: [J

line 748: "}}}[J

line 749: " GitGutter: {{{[J

line 750: [J

line 751: hi! link GitGutterAdd GruvboxGreenSign[J

line 752: hi! link GitGutterChange GruvboxAquaSign[J

line 753: hi! link GitGutterDelete GruvboxRedSign[J

line 754: hi! link GitGutterChangeDelete GruvboxAquaSign[J

line 755: [J

line 756: " }}}[J

line 757: " GitCommit: "{{{[J

line 758: [J

line 759: hi! link gitcommitSelectedFile GruvboxGreen[J

line 760: hi! link gitcommitDiscardedFile GruvboxRed[J

line 761: [J

line 762: " }}}[J

line 763: " Signify: {{{[J

line 764: [J

line 765: hi! link SignifySignAdd GruvboxGreenSign[J

line 766: hi! link SignifySignChange GruvboxAquaSign[J

line 767: hi! link SignifySignDelete GruvboxRedSign[J

line 768: [J

line 769: " }}}[J

line 770: " Syntastic: {{{[J

line 771: [J

line 772: call s:HL('SyntasticError', s:none, s:none, s:undercurl, s:red)[J

calling function <SNR>13_HL[J('SyntasticError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SyntasticError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 773: call s:HL('SyntasticWarning', s:none, s:none, s:undercurl, s:yellow)[J

calling function <SNR>13_HL[J('SyntasticWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi SyntasticWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fabd2f[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 774: [J

line 775: hi! link SyntasticErrorSign GruvboxRedSign[J

line 776: hi! link SyntasticWarningSign GruvboxYellowSign[J

line 777: [J

line 778: " }}}[J

line 779: " Signature: {{{[J

line 780: hi! link SignatureMarkText   GruvboxBlueSign[J

line 781: hi! link SignatureMarkerText GruvboxPurpleSign[J

line 782: [J

line 783: " }}}[J

line 784: " ShowMarks: {{{[J

line 785: [J

line 786: hi! link ShowMarksHLl GruvboxBlueSign[J

line 787: hi! link ShowMarksHLu GruvboxBlueSign[J

line 788: hi! link ShowMarksHLo GruvboxBlueSign[J

line 789: hi! link ShowMarksHLm GruvboxBlueSign[J

line 790: [J

line 791: " }}}[J

line 792: " CtrlP: {{{[J

line 793: [J

line 794: hi! link CtrlPMatch GruvboxYellow[J

line 795: hi! link CtrlPNoEntries GruvboxRed[J

line 796: hi! link CtrlPPrtBase GruvboxBg2[J

line 797: hi! link CtrlPPrtCursor GruvboxBlue[J

line 798: hi! link CtrlPLinePre GruvboxBg2[J

line 799: [J

line 800: call s:HL('CtrlPMode1', s:blue, s:bg2, s:bold)[J

calling function <SNR>13_HL[J('CtrlPMode1', ['#83a598', 109], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CtrlPMode1 guifg=#83a598 ctermfg=109 guibg=#504945 ctermbg=239 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 801: call s:HL('CtrlPMode2', s:bg0, s:blue, s:bold)[J

calling function <SNR>13_HL[J('CtrlPMode2', ['#1d2021', 234], ['#83a598', 109], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CtrlPMode2 guifg=#1d2021 ctermfg=234 guibg=#83a598 ctermbg=109 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 802: call s:HL('CtrlPStats', s:fg4, s:bg2, s:bold)[J

calling function <SNR>13_HL[J('CtrlPStats', ['#a89984', 246], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi CtrlPStats guifg=#a89984 ctermfg=246 guibg=#504945 ctermbg=239 gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 803: [J

line 804: " }}}[J

line 805: " Startify: {{{[J

line 806: [J

line 807: hi! link StartifyBracket GruvboxFg3[J

line 808: hi! link StartifyFile GruvboxFg1[J

line 809: hi! link StartifyNumber GruvboxBlue[J

line 810: hi! link StartifyPath GruvboxGray[J

line 811: hi! link StartifySlash GruvboxGray[J

line 812: hi! link StartifySection GruvboxYellow[J

line 813: hi! link StartifySpecial GruvboxBg2[J

line 814: hi! link StartifyHeader GruvboxOrange[J

line 815: hi! link StartifyFooter GruvboxBg2[J

line 816: [J

line 817: " }}}[J

line 818: " Vimshell: {{{[J

line 819: [J

line 825: let g:vimshell_escape_colors = [ s:bg4[0], s:red[0], s:green[0], s:yellow[0], s:blue[0], s:purple[0], s:aqua[0], s:fg4[0], s:bg0[0], s:red[0], s:green[0], s:orange[0], s:blue[0], s:purple[0], s:aqua[0], s:fg0[0] ][J

line 826: [J

line 827: " }}}[J

line 828: " BufTabLine: {{{[J

line 829: [J

line 830: call s:HL('BufTabLineCurrent', s:bg0, s:fg4)[J

calling function <SNR>13_HL[J('BufTabLineCurrent', ['#1d2021', 234], ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi BufTabLineCurrent guifg=#1d2021 ctermfg=234 guibg=#a89984 ctermbg=246 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 831: call s:HL('BufTabLineActive', s:fg4, s:bg2)[J

calling function <SNR>13_HL[J('BufTabLineActive', ['#a89984', 246], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi BufTabLineActive guifg=#a89984 ctermfg=246 guibg=#504945 ctermbg=239 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 832: call s:HL('BufTabLineHidden', s:bg4, s:bg1)[J

calling function <SNR>13_HL[J('BufTabLineHidden', ['#7c6f64', 243], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi BufTabLineHidden guifg=#7c6f64 ctermfg=243 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 833: call s:HL('BufTabLineFill', s:bg0, s:bg0)[J

calling function <SNR>13_HL[J('BufTabLineFill', ['#1d2021', 234], ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi BufTabLineFill guifg=#1d2021 ctermfg=234 guibg=#1d2021 ctermbg=234 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 834: [J

line 835: " }}}[J

line 836: " Asynchronous Lint Engine: {{{[J

line 837: [J

line 838: call s:HL('ALEError', s:none, s:none, s:undercurl, s:red)[J

calling function <SNR>13_HL[J('ALEError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ALEError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 839: call s:HL('ALEWarning', s:none, s:none, s:undercurl, s:yellow)[J

calling function <SNR>13_HL[J('ALEWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ALEWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fabd2f[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 840: call s:HL('ALEInfo', s:none, s:none, s:undercurl, s:blue)[J

calling function <SNR>13_HL[J('ALEInfo', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi ALEInfo guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#83a598[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 841: [J

line 842: hi! link ALEErrorSign GruvboxRedSign[J

line 843: hi! link ALEWarningSign GruvboxYellowSign[J

line 844: hi! link ALEInfoSign GruvboxBlueSign[J

line 845: [J

line 846: " }}}[J

line 847: " Dirvish: {{{[J

line 848: [J

line 849: hi! link DirvishPathTail GruvboxAqua[J

line 850: hi! link DirvishArg GruvboxYellow[J

line 851: [J

line 852: " }}}[J

line 853: " Netrw: {{{[J

line 854: [J

line 855: hi! link netrwDir GruvboxAqua[J

line 856: hi! link netrwClassify GruvboxAqua[J

line 857: hi! link netrwLink GruvboxGray[J

line 858: hi! link netrwSymLink GruvboxFg1[J

line 859: hi! link netrwExe GruvboxYellow[J

line 860: hi! link netrwComment GruvboxGray[J

line 861: hi! link netrwList GruvboxBlue[J

line 862: hi! link netrwHelpCmd GruvboxAqua[J

line 863: hi! link netrwCmdSep GruvboxFg3[J

line 864: hi! link netrwVersion GruvboxGreen[J

line 865: [J

line 866: " }}}[J

line 867: " NERDTree: {{{[J

line 868: [J

line 869: hi! link NERDTreeDir GruvboxAqua[J

line 870: hi! link NERDTreeDirSlash GruvboxAqua[J

line 871: [J

line 872: hi! link NERDTreeOpenable GruvboxOrange[J

line 873: hi! link NERDTreeClosable GruvboxOrange[J

line 874: [J

line 875: hi! link NERDTreeFile GruvboxFg1[J

line 876: hi! link NERDTreeExecFile GruvboxYellow[J

line 877: [J

line 878: hi! link NERDTreeUp GruvboxGray[J

line 879: hi! link NERDTreeCWD GruvboxGreen[J

line 880: hi! link NERDTreeHelp GruvboxFg1[J

line 881: [J

line 882: hi! link NERDTreeToggleOn GruvboxGreen[J

line 883: hi! link NERDTreeToggleOff GruvboxRed[J

line 884: [J

line 885: " }}}[J

line 886: " Vim Multiple Cursors: {{{[J

line 887: [J

line 888: call s:HL('multiple_cursors_cursor', s:none, s:none, s:inverse)[J

calling function <SNR>13_HL[J('multiple_cursors_cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi multiple_cursors_cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 889: call s:HL('multiple_cursors_visual', s:none, s:bg2)[J

calling function <SNR>13_HL[J('multiple_cursors_visual', ['NONE', 'NONE'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi multiple_cursors_visual guifg=NONE ctermfg=NONE guibg=#504945 ctermbg=239 gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 890: [J

line 891: " }}}[J

line 892: [J

line 893: " Filetype specific -----------------------------------------------------------[J

line 894: " Diff: {{{[J

line 895: [J

line 896: hi! link diffAdded GruvboxGreen[J

line 897: hi! link diffRemoved GruvboxRed[J

line 898: hi! link diffChanged GruvboxAqua[J

line 899: [J

line 900: hi! link diffFile GruvboxOrange[J

line 901: hi! link diffNewFile GruvboxYellow[J

line 902: [J

line 903: hi! link diffLine GruvboxBlue[J

line 904: [J

line 905: " }}}[J

line 906: " Html: {{{[J

line 907: [J

line 908: hi! link htmlTag GruvboxBlue[J

line 909: hi! link htmlEndTag GruvboxBlue[J

line 910: [J

line 911: hi! link htmlTagName GruvboxAquaBold[J

line 912: hi! link htmlArg GruvboxAqua[J

line 913: [J

line 914: hi! link htmlScriptTag GruvboxPurple[J

line 915: hi! link htmlTagN GruvboxFg1[J

line 916: hi! link htmlSpecialTagName GruvboxAquaBold[J

line 917: [J

line 918: call s:HL('htmlLink', s:fg4, s:none, s:underline)[J

calling function <SNR>13_HL[J('htmlLink', ['#a89984', 246], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlLink guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 919: [J

line 920: hi! link htmlSpecialChar GruvboxOrange[J

line 921: [J

line 922: call s:HL('htmlBold', s:vim_fg, s:vim_bg, s:bold)[J

calling function <SNR>13_HL[J('htmlBold', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlBold guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 923: call s:HL('htmlBoldUnderline', s:vim_fg, s:vim_bg, s:bold . s:underline)[J

calling function <SNR>13_HL[J('htmlBoldUnderline', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlBoldUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 924: call s:HL('htmlBoldItalic', s:vim_fg, s:vim_bg, s:bold . s:italic)[J

calling function <SNR>13_HL[J('htmlBoldItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlBoldItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 925: call s:HL('htmlBoldUnderlineItalic', s:vim_fg, s:vim_bg, s:bold . s:underline . s:italic)[J

calling function <SNR>13_HL[J('htmlBoldUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlBoldUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 926: [J

line 927: call s:HL('htmlUnderline', s:vim_fg, s:vim_bg, s:underline)[J

calling function <SNR>13_HL[J('htmlUnderline', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 928: call s:HL('htmlUnderlineItalic', s:vim_fg, s:vim_bg, s:underline . s:italic)[J

calling function <SNR>13_HL[J('htmlUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 929: call s:HL('htmlItalic', s:vim_fg, s:vim_bg, s:italic)[J

calling function <SNR>13_HL[J('htmlItalic', ['fg', 'fg'], ['bg', 'bg'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi htmlItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 930: [J

line 931: " }}}[J

line 932: " Xml: {{{[J

line 933: [J

line 934: hi! link xmlTag GruvboxBlue[J

line 935: hi! link xmlEndTag GruvboxBlue[J

line 936: hi! link xmlTagName GruvboxBlue[J

line 937: hi! link xmlEqual GruvboxBlue[J

line 938: hi! link docbkKeyword GruvboxAquaBold[J

line 939: [J

line 940: hi! link xmlDocTypeDecl GruvboxGray[J

line 941: hi! link xmlDocTypeKeyword GruvboxPurple[J

line 942: hi! link xmlCdataStart GruvboxGray[J

line 943: hi! link xmlCdataCdata GruvboxPurple[J

line 944: hi! link dtdFunction GruvboxGray[J

line 945: hi! link dtdTagName GruvboxPurple[J

line 946: [J

line 947: hi! link xmlAttrib GruvboxAqua[J

line 948: hi! link xmlProcessingDelim GruvboxGray[J

line 949: hi! link dtdParamEntityPunct GruvboxGray[J

line 950: hi! link dtdParamEntityDPunct GruvboxGray[J

line 951: hi! link xmlAttribPunct GruvboxGray[J

line 952: [J

line 953: hi! link xmlEntity GruvboxOrange[J

line 954: hi! link xmlEntityPunct GruvboxOrange[J

line 955: " }}}[J

line 956: " Vim: {{{[J

line 957: [J

line 958: call s:HL('vimCommentTitle', s:fg4_256, s:none, s:bold . s:italicize_comments)[J

calling function <SNR>13_HL[J('vimCommentTitle', ['#a89984', 246], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi vimCommentTitle guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 959: [J

line 960: hi! link vimNotation GruvboxOrange[J

line 961: hi! link vimBracket GruvboxOrange[J

line 962: hi! link vimMapModKey GruvboxOrange[J

line 963: hi! link vimFuncSID GruvboxFg3[J

line 964: hi! link vimSetSep GruvboxFg3[J

line 965: hi! link vimSep GruvboxFg3[J

line 966: hi! link vimContinue GruvboxFg3[J

line 967: [J

line 968: " }}}[J

line 969: " Clojure: {{{[J

line 970: [J

line 971: hi! link clojureKeyword GruvboxBlue[J

line 972: hi! link clojureCond GruvboxOrange[J

line 973: hi! link clojureSpecial GruvboxOrange[J

line 974: hi! link clojureDefine GruvboxOrange[J

line 975: [J

line 976: hi! link clojureFunc GruvboxYellow[J

line 977: hi! link clojureRepeat GruvboxYellow[J

line 978: hi! link clojureCharacter GruvboxAqua[J

line 979: hi! link clojureStringEscape GruvboxAqua[J

line 980: hi! link clojureException GruvboxRed[J

line 981: [J

line 982: hi! link clojureRegexp GruvboxAqua[J

line 983: hi! link clojureRegexpEscape GruvboxAqua[J

line 984: call s:HL('clojureRegexpCharClass', s:fg3, s:none, s:bold)[J

calling function <SNR>13_HL[J('clojureRegexpCharClass', ['#bdae93', 248], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi clojureRegexpCharClass guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=bold cterm=bold[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 985: hi! link clojureRegexpMod clojureRegexpCharClass[J

line 986: hi! link clojureRegexpQuantifier clojureRegexpCharClass[J

line 987: [J

line 988: hi! link clojureParen GruvboxFg3[J

line 989: hi! link clojureAnonArg GruvboxYellow[J

line 990: hi! link clojureVariable GruvboxBlue[J

line 991: hi! link clojureMacro GruvboxOrange[J

line 992: [J

line 993: hi! link clojureMeta GruvboxYellow[J

line 994: hi! link clojureDeref GruvboxYellow[J

line 995: hi! link clojureQuote GruvboxYellow[J

line 996: hi! link clojureUnquote GruvboxYellow[J

line 997: [J

line 998: " }}}[J

line 999: " C: {{{[J

line 1000: [J

line 1001: hi! link cOperator GruvboxPurple[J

line 1002: hi! link cStructure GruvboxOrange[J

line 1003: [J

line 1004: " }}}[J

line 1005: " Python: {{{[J

line 1006: [J

line 1007: hi! link pythonBuiltin GruvboxOrange[J

line 1008: hi! link pythonBuiltinObj GruvboxOrange[J

line 1009: hi! link pythonBuiltinFunc GruvboxOrange[J

line 1010: hi! link pythonFunction GruvboxAqua[J

line 1011: hi! link pythonDecorator GruvboxRed[J

line 1012: hi! link pythonInclude GruvboxBlue[J

line 1013: hi! link pythonImport GruvboxBlue[J

line 1014: hi! link pythonRun GruvboxBlue[J

line 1015: hi! link pythonCoding GruvboxBlue[J

line 1016: hi! link pythonOperator GruvboxRed[J

line 1017: hi! link pythonException GruvboxRed[J

line 1018: hi! link pythonExceptions GruvboxPurple[J

line 1019: hi! link pythonBoolean GruvboxPurple[J

line 1020: hi! link pythonDot GruvboxFg3[J

line 1021: hi! link pythonConditional GruvboxRed[J

line 1022: hi! link pythonRepeat GruvboxRed[J

line 1023: hi! link pythonDottedName GruvboxGreenBold[J

line 1024: [J

line 1025: " }}}[J

line 1026: " CSS: {{{[J

line 1027: [J

line 1028: hi! link cssBraces GruvboxBlue[J

line 1029: hi! link cssFunctionName GruvboxYellow[J

line 1030: hi! link cssIdentifier GruvboxOrange[J

line 1031: hi! link cssClassName GruvboxGreen[J

line 1032: hi! link cssColor GruvboxBlue[J

line 1033: hi! link cssSelectorOp GruvboxBlue[J

line 1034: hi! link cssSelectorOp2 GruvboxBlue[J

line 1035: hi! link cssImportant GruvboxGreen[J

line 1036: hi! link cssVendor GruvboxFg1[J

line 1037: [J

line 1038: hi! link cssTextProp GruvboxAqua[J

line 1039: hi! link cssAnimationProp GruvboxAqua[J

line 1040: hi! link cssUIProp GruvboxYellow[J

line 1041: hi! link cssTransformProp GruvboxAqua[J

line 1042: hi! link cssTransitionProp GruvboxAqua[J

line 1043: hi! link cssPrintProp GruvboxAqua[J

line 1044: hi! link cssPositioningProp GruvboxYellow[J

line 1045: hi! link cssBoxProp GruvboxAqua[J

line 1046: hi! link cssFontDescriptorProp GruvboxAqua[J

line 1047: hi! link cssFlexibleBoxProp GruvboxAqua[J

line 1048: hi! link cssBorderOutlineProp GruvboxAqua[J

line 1049: hi! link cssBackgroundProp GruvboxAqua[J

line 1050: hi! link cssMarginProp GruvboxAqua[J

line 1051: hi! link cssListProp GruvboxAqua[J

line 1052: hi! link cssTableProp GruvboxAqua[J

line 1053: hi! link cssFontProp GruvboxAqua[J

line 1054: hi! link cssPaddingProp GruvboxAqua[J

line 1055: hi! link cssDimensionProp GruvboxAqua[J

line 1056: hi! link cssRenderProp GruvboxAqua[J

line 1057: hi! link cssColorProp GruvboxAqua[J

line 1058: hi! link cssGeneratedContentProp GruvboxAqua[J

line 1059: [J

line 1060: " }}}[J

line 1061: " JavaScript: {{{[J

line 1062: [J

line 1063: hi! link javaScriptBraces GruvboxFg1[J

line 1064: hi! link javaScriptFunction GruvboxAqua[J

line 1065: hi! link javaScriptIdentifier GruvboxRed[J

line 1066: hi! link javaScriptMember GruvboxBlue[J

line 1067: hi! link javaScriptNumber GruvboxPurple[J

line 1068: hi! link javaScriptNull GruvboxPurple[J

line 1069: hi! link javaScriptParens GruvboxFg3[J

line 1070: [J

line 1071: " }}}[J

line 1072: " YAJS: {{{[J

line 1073: [J

line 1074: hi! link javascriptImport GruvboxAqua[J

line 1075: hi! link javascriptExport GruvboxAqua[J

line 1076: hi! link javascriptClassKeyword GruvboxAqua[J

line 1077: hi! link javascriptClassExtends GruvboxAqua[J

line 1078: hi! link javascriptDefault GruvboxAqua[J

line 1079: [J

line 1080: hi! link javascriptClassName GruvboxYellow[J

line 1081: hi! link javascriptClassSuperName GruvboxYellow[J

line 1082: hi! link javascriptGlobal GruvboxYellow[J

line 1083: [J

line 1084: hi! link javascriptEndColons GruvboxFg1[J

line 1085: hi! link javascriptFuncArg GruvboxFg1[J

line 1086: hi! link javascriptGlobalMethod GruvboxFg1[J

line 1087: hi! link javascriptNodeGlobal GruvboxFg1[J

line 1088: hi! link javascriptBOMWindowProp GruvboxFg1[J

line 1089: hi! link javascriptArrayMethod GruvboxFg1[J

line 1090: hi! link javascriptArrayStaticMethod GruvboxFg1[J

line 1091: hi! link javascriptCacheMethod GruvboxFg1[J

line 1092: hi! link javascriptDateMethod GruvboxFg1[J

line 1093: hi! link javascriptMathStaticMethod GruvboxFg1[J

line 1094: [J

line 1095: " hi! link javascriptProp GruvboxFg1[J

line 1096: hi! link javascriptURLUtilsProp GruvboxFg1[J

line 1097: hi! link javascriptBOMNavigatorProp GruvboxFg1[J

line 1098: hi! link javascriptDOMDocMethod GruvboxFg1[J

line 1099: hi! link javascriptDOMDocProp GruvboxFg1[J

line 1100: hi! link javascriptBOMLocationMethod GruvboxFg1[J

line 1101: hi! link javascriptBOMWindowMethod GruvboxFg1[J

line 1102: hi! link javascriptStringMethod GruvboxFg1[J

line 1103: [J

line 1104: hi! link javascriptVariable GruvboxOrange[J

line 1105: " hi! link javascriptVariable GruvboxRed[J

line 1106: " hi! link javascriptIdentifier GruvboxOrange[J

line 1107: " hi! link javascriptClassSuper GruvboxOrange[J

line 1108: hi! link javascriptIdentifier GruvboxOrange[J

line 1109: hi! link javascriptClassSuper GruvboxOrange[J

line 1110: [J

line 1111: " hi! link javascriptFuncKeyword GruvboxOrange[J

line 1112: " hi! link javascriptAsyncFunc GruvboxOrange[J

line 1113: hi! link javascriptFuncKeyword GruvboxAqua[J

line 1114: hi! link javascriptAsyncFunc GruvboxAqua[J

line 1115: hi! link javascriptClassStatic GruvboxOrange[J

line 1116: [J

line 1117: hi! link javascriptOperator GruvboxRed[J

line 1118: hi! link javascriptForOperator GruvboxRed[J

line 1119: hi! link javascriptYield GruvboxRed[J

line 1120: hi! link javascriptExceptions GruvboxRed[J

line 1121: hi! link javascriptMessage GruvboxRed[J

line 1122: [J

line 1123: hi! link javascriptTemplateSB GruvboxAqua[J

line 1124: hi! link javascriptTemplateSubstitution GruvboxFg1[J

line 1125: [J

line 1126: " hi! link javascriptLabel GruvboxBlue[J

line 1127: " hi! link javascriptObjectLabel GruvboxBlue[J

line 1128: " hi! link javascriptPropertyName GruvboxBlue[J

line 1129: hi! link javascriptLabel GruvboxFg1[J

line 1130: hi! link javascriptObjectLabel GruvboxFg1[J

line 1131: hi! link javascriptPropertyName GruvboxFg1[J

line 1132: [J

line 1133: hi! link javascriptLogicSymbols GruvboxFg1[J

line 1134: hi! link javascriptArrowFunc GruvboxYellow[J

line 1135: [J

line 1136: hi! link javascriptDocParamName GruvboxFg4[J

line 1137: hi! link javascriptDocTags GruvboxFg4[J

line 1138: hi! link javascriptDocNotation GruvboxFg4[J

line 1139: hi! link javascriptDocParamType GruvboxFg4[J

line 1140: hi! link javascriptDocNamedParamType GruvboxFg4[J

line 1141: [J

line 1142: hi! link javascriptBrackets GruvboxFg1[J

line 1143: hi! link javascriptDOMElemAttrs GruvboxFg1[J

line 1144: hi! link javascriptDOMEventMethod GruvboxFg1[J

line 1145: hi! link javascriptDOMNodeMethod GruvboxFg1[J

line 1146: hi! link javascriptDOMStorageMethod GruvboxFg1[J

line 1147: hi! link javascriptHeadersMethod GruvboxFg1[J

line 1148: [J

line 1149: hi! link javascriptAsyncFuncKeyword GruvboxRed[J

line 1150: hi! link javascriptAwaitFuncKeyword GruvboxRed[J

line 1151: [J

line 1152: " }}}[J

line 1153: " PanglossJS: {{{[J

line 1154: [J

line 1155: hi! link jsClassKeyword GruvboxAqua[J

line 1156: hi! link jsExtendsKeyword GruvboxAqua[J

line 1157: hi! link jsExportDefault GruvboxAqua[J

line 1158: hi! link jsTemplateBraces GruvboxAqua[J

line 1159: hi! link jsGlobalNodeObjects GruvboxFg1[J

line 1160: hi! link jsGlobalObjects GruvboxFg1[J

line 1161: hi! link jsFunction GruvboxAqua[J

line 1162: hi! link jsFuncParens GruvboxFg3[J

line 1163: hi! link jsParens GruvboxFg3[J

line 1164: hi! link jsNull GruvboxPurple[J

line 1165: hi! link jsUndefined GruvboxPurple[J

line 1166: hi! link jsClassDefinition GruvboxYellow[J

line 1167: [J

line 1168: " }}}[J

line 1169: " TypeScript: {{{[J

line 1170: [J

line 1171: hi! link typeScriptReserved GruvboxAqua[J

line 1172: hi! link typeScriptLabel GruvboxAqua[J

line 1173: hi! link typeScriptFuncKeyword GruvboxAqua[J

line 1174: hi! link typeScriptIdentifier GruvboxOrange[J

line 1175: hi! link typeScriptBraces GruvboxFg1[J

line 1176: hi! link typeScriptEndColons GruvboxFg1[J

line 1177: hi! link typeScriptDOMObjects GruvboxFg1[J

line 1178: hi! link typeScriptAjaxMethods GruvboxFg1[J

line 1179: hi! link typeScriptLogicSymbols GruvboxFg1[J

line 1180: hi! link typeScriptDocSeeTag Comment[J

line 1181: hi! link typeScriptDocParam Comment[J

line 1182: hi! link typeScriptDocTags vimCommentTitle[J

line 1183: hi! link typeScriptGlobalObjects GruvboxFg1[J

line 1184: hi! link typeScriptParens GruvboxFg3[J

line 1185: hi! link typeScriptOpSymbols GruvboxFg3[J

line 1186: hi! link typeScriptHtmlElemProperties GruvboxFg1[J

line 1187: hi! link typeScriptNull GruvboxPurple[J

line 1188: hi! link typeScriptInterpolationDelimiter GruvboxAqua[J

line 1189: [J

line 1190: " }}}[J

line 1191: " PureScript: {{{[J

line 1192: [J

line 1193: hi! link purescriptModuleKeyword GruvboxAqua[J

line 1194: hi! link purescriptModuleName GruvboxFg1[J

line 1195: hi! link purescriptWhere GruvboxAqua[J

line 1196: hi! link purescriptDelimiter GruvboxFg4[J

line 1197: hi! link purescriptType GruvboxFg1[J

line 1198: hi! link purescriptImportKeyword GruvboxAqua[J

line 1199: hi! link purescriptHidingKeyword GruvboxAqua[J

line 1200: hi! link purescriptAsKeyword GruvboxAqua[J

line 1201: hi! link purescriptStructure GruvboxAqua[J

line 1202: hi! link purescriptOperator GruvboxBlue[J

line 1203: [J

line 1204: hi! link purescriptTypeVar GruvboxFg1[J

line 1205: hi! link purescriptConstructor GruvboxFg1[J

line 1206: hi! link purescriptFunction GruvboxFg1[J

line 1207: hi! link purescriptConditional GruvboxOrange[J

line 1208: hi! link purescriptBacktick GruvboxOrange[J

line 1209: [J

line 1210: " }}}[J

line 1211: " CoffeeScript: {{{[J

line 1212: [J

line 1213: hi! link coffeeExtendedOp GruvboxFg3[J

line 1214: hi! link coffeeSpecialOp GruvboxFg3[J

line 1215: hi! link coffeeCurly GruvboxOrange[J

line 1216: hi! link coffeeParen GruvboxFg3[J

line 1217: hi! link coffeeBracket GruvboxOrange[J

line 1218: [J

line 1219: " }}}[J

line 1220: " Ruby: {{{[J

line 1221: [J

line 1222: hi! link rubyStringDelimiter GruvboxGreen[J

line 1223: hi! link rubyInterpolationDelimiter GruvboxAqua[J

line 1224: [J

line 1225: " }}}[J

line 1226: " ObjectiveC: {{{[J

line 1227: [J

line 1228: hi! link objcTypeModifier GruvboxRed[J

line 1229: hi! link objcDirective GruvboxBlue[J

line 1230: [J

line 1231: " }}}[J

line 1232: " Go: {{{[J

line 1233: [J

line 1234: hi! link goDirective GruvboxAqua[J

line 1235: hi! link goConstants GruvboxPurple[J

line 1236: hi! link goDeclaration GruvboxRed[J

line 1237: hi! link goDeclType GruvboxBlue[J

line 1238: hi! link goBuiltins GruvboxOrange[J

line 1239: [J

line 1240: " }}}[J

line 1241: " Lua: {{{[J

line 1242: [J

line 1243: hi! link luaIn GruvboxRed[J

line 1244: hi! link luaFunction GruvboxAqua[J

line 1245: hi! link luaTable GruvboxOrange[J

line 1246: [J

line 1247: " }}}[J

line 1248: " MoonScript: {{{[J

line 1249: [J

line 1250: hi! link moonSpecialOp GruvboxFg3[J

line 1251: hi! link moonExtendedOp GruvboxFg3[J

line 1252: hi! link moonFunction GruvboxFg3[J

line 1253: hi! link moonObject GruvboxYellow[J

line 1254: [J

line 1255: " }}}[J

line 1256: " Java: {{{[J

line 1257: [J

line 1258: hi! link javaAnnotation GruvboxBlue[J

line 1259: hi! link javaDocTags GruvboxAqua[J

line 1260: hi! link javaCommentTitle vimCommentTitle[J

line 1261: hi! link javaParen GruvboxFg3[J

line 1262: hi! link javaParen1 GruvboxFg3[J

line 1263: hi! link javaParen2 GruvboxFg3[J

line 1264: hi! link javaParen3 GruvboxFg3[J

line 1265: hi! link javaParen4 GruvboxFg3[J

line 1266: hi! link javaParen5 GruvboxFg3[J

line 1267: hi! link javaOperator GruvboxOrange[J

line 1268: [J

line 1269: hi! link javaVarArg GruvboxGreen[J

line 1270: [J

line 1271: " }}}[J

line 1272: " Elixir: {{{[J

line 1273: [J

line 1274: hi! link elixirDocString Comment[J

line 1275: [J

line 1276: hi! link elixirStringDelimiter GruvboxGreen[J

line 1277: hi! link elixirInterpolationDelimiter GruvboxAqua[J

line 1278: [J

line 1279: hi! link elixirModuleDeclaration GruvboxYellow[J

line 1280: [J

line 1281: " }}}[J

line 1282: " Scala: {{{[J

line 1283: [J

line 1284: " NB: scala vim syntax file is kinda horrible[J

line 1285: hi! link scalaNameDefinition GruvboxFg1[J

line 1286: hi! link scalaCaseFollowing GruvboxFg1[J

line 1287: hi! link scalaCapitalWord GruvboxFg1[J

line 1288: hi! link scalaTypeExtension GruvboxFg1[J

line 1289: [J

line 1290: hi! link scalaKeyword GruvboxRed[J

line 1291: hi! link scalaKeywordModifier GruvboxRed[J

line 1292: [J

line 1293: hi! link scalaSpecial GruvboxAqua[J

line 1294: hi! link scalaOperator GruvboxFg1[J

line 1295: [J

line 1296: hi! link scalaTypeDeclaration GruvboxYellow[J

line 1297: hi! link scalaTypeTypePostDeclaration GruvboxYellow[J

line 1298: [J

line 1299: hi! link scalaInstanceDeclaration GruvboxFg1[J

line 1300: hi! link scalaInterpolation GruvboxAqua[J

line 1301: [J

line 1302: " }}}[J

line 1303: " Markdown: {{{[J

line 1304: [J

line 1305: call s:HL('markdownItalic', s:fg3, s:none, s:italic)[J

calling function <SNR>13_HL[J('markdownItalic', ['#bdae93', 248], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi markdownItalic guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 1306: [J

line 1307: hi! link markdownH1 GruvboxGreenBold[J

line 1308: hi! link markdownH2 GruvboxGreenBold[J

line 1309: hi! link markdownH3 GruvboxYellowBold[J

line 1310: hi! link markdownH4 GruvboxYellowBold[J

line 1311: hi! link markdownH5 GruvboxYellow[J

line 1312: hi! link markdownH6 GruvboxYellow[J

line 1313: [J

line 1314: hi! link markdownCode GruvboxAqua[J

line 1315: hi! link markdownCodeBlock GruvboxAqua[J

line 1316: hi! link markdownCodeDelimiter GruvboxAqua[J

line 1317: [J

line 1318: hi! link markdownBlockquote GruvboxGray[J

line 1319: hi! link markdownListMarker GruvboxGray[J

line 1320: hi! link markdownOrderedListMarker GruvboxGray[J

line 1321: hi! link markdownRule GruvboxGray[J

line 1322: hi! link markdownHeadingRule GruvboxGray[J

line 1323: [J

line 1324: hi! link markdownUrlDelimiter GruvboxFg3[J

line 1325: hi! link markdownLinkDelimiter GruvboxFg3[J

line 1326: hi! link markdownLinkTextDelimiter GruvboxFg3[J

line 1327: [J

line 1328: hi! link markdownHeadingDelimiter GruvboxOrange[J

line 1329: hi! link markdownUrl GruvboxPurple[J

line 1330: hi! link markdownUrlTitleDelimiter GruvboxGreen[J

line 1331: [J

line 1332: call s:HL('markdownLinkText', s:gray, s:none, s:underline)[J

calling function <SNR>13_HL[J('markdownLinkText', ['#928374', 245], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp[J

line 2: [J

line 3:   " foreground[J

line 4:   let fg = a:fg[J

line 5: [J

line 6:   " background[J

line 7:   if a:0 >= 1[J

line 8:     let bg = a:1[J

line 9:   else[J

line 10:     let bg = s:none[J

line 11:   endif[J

line 12: [J

line 13:   " emphasis[J

line 14:   if a:0 >= 2 && strlen(a:2)[J

line 15:     let emstr = a:2[J

line 16:   else[J

line 17:     let emstr = 'NONE,'[J

line 18:   endif[J

line 19: [J

line 20:   " special fallback[J

line 21:   if a:0 >= 3[J

line 22:     if g:gruvbox_guisp_fallback != 'NONE'[J

line 23:       let fg = a:3[J

line 24:     endif[J

line 25: [J

line 26:     " bg fallback mode should invert higlighting[J

line 27:     if g:gruvbox_guisp_fallback == 'bg'[J

line 28:       let emstr .= 'inverse,'[J

line 29:     endif[J

line 30:   endif[J

line 31: [J

line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ][J

line 37: [J

line 38:   " special[J

line 39:   if a:0 >= 3[J

line 40:     call add(histring, 'guisp=' . a:3[0])[J

line 41:   endif[J

line 42: [J

line 43:   execute join(histring, ' ')[J

line 43: hi markdownLinkText guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=underline cterm=underline[J

function <SNR>13_HL returning #0[J

continuing in /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J

line 1333: hi! link markdownIdDeclaration markdownLinkText[J

line 1334: [J

line 1335: " }}}[J

line 1336: " Haskell: {{{[J

line 1337: [J

line 1338: " hi! link haskellType GruvboxYellow[J

line 1339: " hi! link haskellOperators GruvboxOrange[J

line 1340: " hi! link haskellConditional GruvboxAqua[J

line 1341: " hi! link haskellLet GruvboxOrange[J

line 1342: "[J

line 1343: hi! link haskellType GruvboxFg1[J

line 1344: hi! link haskellIdentifier GruvboxFg1[J

line 1345: hi! link haskellSeparator GruvboxFg1[J

line 1346: hi! link haskellDelimiter GruvboxFg4[J

line 1347: hi! link haskellOperators GruvboxBlue[J

line 1348: "[J

line 1349: hi! link haskellBacktick GruvboxOrange[J

line 1350: hi! link haskellStatement GruvboxOrange[J

line 1351: hi! link haskellConditional GruvboxOrange[J

line 1352: [J

line 1353: hi! link haskellLet GruvboxAqua[J

line 1354: hi! link haskellDefault GruvboxAqua[J

line 1355: hi! link haskellWhere GruvboxAqua[J

line 1356: hi! link haskellBottom GruvboxAqua[J

line 1357: hi! link haskellBlockKeywords GruvboxAqua[J

line 1358: hi! link haskellImportKeywords GruvboxAqua[J

line 1359: hi! link haskellDeclKeyword GruvboxAqua[J

line 1360: hi! link haskellDeriving GruvboxAqua[J

line 1361: hi! link haskellAssocType GruvboxAqua[J

line 1362: [J

line 1363: hi! link haskellNumber GruvboxPurple[J

line 1364: hi! link haskellPragma GruvboxPurple[J

line 1365: [J

line 1366: hi! link haskellString GruvboxGreen[J

line 1367: hi! link haskellChar GruvboxGreen[J

line 1368: [J

line 1369: " }}}[J

line 1370: " Json: {{{[J

line 1371: [J

line 1372: hi! link jsonKeyword GruvboxGreen[J

line 1373: hi! link jsonQuote GruvboxGreen[J

line 1374: hi! link jsonBraces GruvboxFg1[J

line 1375: hi! link jsonString GruvboxFg1[J

line 1376: [J

line 1377: " }}}[J

line 1378: [J

line 1379: [J

line 1380: " Functions -------------------------------------------------------------------[J

line 1381: " Search Highlighting Cursor {{{[J

line 1382: [J

line 1383: function! GruvboxHlsShowCursor()[J

line 1386: [J

line 1387: function! GruvboxHlsHideCursor()[J

line 1390: [J

line 1391: " }}}[J

line 1392: [J

line 1393: " vim: set sw=2 ts=2 sts=2 et tw=80 ft=vim fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/gruvbox/colors/gruvbox.vim[J
continuing in /usr/share/vim/vim74/syntax/synload.vim[J
line 20: else[J

line 21:   runtime! syntax/syncolor.vim[J

line 22: endif[J

line 23: [J

line 24: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 25: let s:cpo_save = &cpo[J

line 26: set cpo&vim[J

line 27: [J

line 28: " First remove all old syntax autocommands.[J

line 29: au! Syntax[J

line 30: [J

line 31: au Syntax *^I^Icall s:SynSet()[J

line 32: [J

line 33: fun! s:SynSet()[J

line 61: [J

line 62: [J

line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)[J

line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif[J

line 69: [J

line 70: [J

line 71: " Source the user-specified syntax highlighting file[J

line 72: if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))[J

line 73:   execute "source " . mysyntaxfile[J

line 74: endif[J

line 75: [J

line 76: " Restore 'cpoptions'[J

line 77: let &cpo = s:cpo_save[J

line 78: unlet s:cpo_save[J

finished sourcing /usr/share/vim/vim74/syntax/synload.vim[J
continuing in /usr/share/vim/vim74/syntax/syntax.vim[J
line 20: [J

line 21: " Load the FileType autocommands if not done yet.[J

line 22: if exists("did_load_filetypes")[J

line 23:   let s:did_ft = 1[J

line 24: else[J

line 25:   filetype on[J

line 26:   let s:did_ft = 0[J

line 27: endif[J

line 28: [J

line 29: " Set up the connection between FileType and Syntax autocommands.[J

line 30: " This makes the syntax automatically set when the file type is detected.[J

line 31: augroup syntaxset[J

line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")[J

line 33: augroup END[J

line 34: [J

line 35: [J

line 36: " Execute the syntax autocommands for the each buffer.[J

line 37: " If the filetype wasn't detected yet, do that now.[J

line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'[J

line 39: " already was set manually (e.g., help buffers).[J

line 40: doautoall syntaxset FileType[J

line 41: if !s:did_ft[J

line 42:   doautoall filetypedetect BufRead[J

line 43: endif[J

finished sourcing /usr/share/vim/vim74/syntax/syntax.vim[J
continuing in /Users/ygarrot/.vimrc[J
line 110: set encoding=utf-8[J

line 111: set number relativenumber[J

line 112: " Enable autocompletion:[J

line 113: set wildmode=longest,list,full[J

line 114: " Disables automatic commenting on newline:[J

line 115: autocmd FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o[J

line 116: [J

line 117: " Goyo plugin makes text more readable when writing prose:[J

line 118: map <leader>t :MerlinTypeOf<CR>[J

line 119: map <leader>f :Goyo \| set bg=light \| set linebreak<CR>[J

line 120: [J

line 121: " Spell-check set to <leader>o, 'o' for 'orthography':[J

line 122: map <leader>o :setlocal spell! spelllang=en_us<CR>[J

line 123: [J

line 124: " Splits open at the bottom and right, which is non-retarded, unlike vim defaults.[J

line 125: set splitbelow splitright[J

line 126: [J

line 127: " Nerd tree[J

line 128: map <C-n> :NERDTreeToggle<CR>[J

line 129: autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif[J

line 130: [J

line 131: " vimling:[J

line 132: nm <leader>d :call ToggleDeadKeys()<CR>[J

line 133: imap <leader>d <esc>:call ToggleDeadKeys()<CR>a[J

line 134: nm <leader>i :call ToggleIPA()<CR>[J

line 135: imap <leader>i <esc>:call ToggleIPA()<CR>a[J

line 136: nm <leader>q :call ToggleProse()<CR>[J

line 137: [J

line 138: " Shortcutting split navigation, saving a keypress:[J

line 139: nnoremap <C-h> <C-w>h[J

line 140: nnoremap <C-j> <C-w>j[J

line 141: nnoremap <C-k> <C-w>k[J

line 142: nnoremap <C-l> <C-w>l[J

line 143: [J

line 144: " Check file in shellcheck:[J

line 145: map <leader>s :!clear && shellcheck %<CR>[J

line 146: [J

line 147: " Open my bibliography file in split[J

line 148: map <leader>b :vsp<space>$BIB<CR>[J

line 149: map <leader>r :vsp<space>$REFER<CR>[J

line 150: [J

line 151: " Replace all is aliased to S.[J

line 152: nnoremap S :%s///g<Left><Left><Left>[J

line 153: [J

line 154: " Compile document, be it groff/LaTeX/markdown/etc.[J

line 155: map <leader>c :w! \| !compiler <c-r>%<CR>[J

line 156: [J

line 157: " Open corresponding .pdf/.html or preview[J

line 158: map <leader>p :!opout <c-r>%<CR><CR>[J

line 159: [J

line 160: " Runs a script that cleans out tex build files whenever I close out of a .tex file.[J

line 161: autocmd VimLeave *.tex !texclear %[J

line 162: [J

line 163: " Ensure files are read as what I want:[J

line 164: let g:vimwiki_ext2syntax = {'.Rmd': 'markdown', '.rmd': 'markdown','.md': 'markdown', '.markdown': 'markdown', '.mdown': 'markdown'}[J

line 165: let g:vimwiki_list = [{'path': '~/vimwiki', 'syntax': 'markdown', 'ext': '.md'}][J

line 166: autocmd BufRead,BufNewFile /tmp/calcurse*,~/.calcurse/notes/* set filetype=markdown[J

line 167: autocmd BufRead,BufNewFile *.ms,*.me,*.mom,*.man set filetype=groff[J

line 168: autocmd BufRead,BufNewFile *.tex set filetype=tex[J

line 169: [J

line 170: " Copy selected text to system clipboard (requires gvim/nvim/vim-x11 installed):[J

line 171: vnoremap <C-c> "+y[J

line 172: map <C-p> "+P[J

line 173: [J

line 174: " Enable Goyo by default for mutt writting[J

line 175: " Goyo's width will be the line limit in mutt.[J

line 176: autocmd BufRead,BufNewFile /tmp/neomutt* let g:goyo_width=200[J

line 177: autocmd BufRead,BufNewFile /tmp/neomutt* :Goyo \| set bg=light[J

line 178: [J

line 179: " Automatically deletes all trailing whitespace on save.[J

line 180: " autocmd BufWritePre * %s/\s\+$//e[J

line 181: [J

line 182: " When shortcut files are updated, renew bash and ranger configs with new material:[J

line 183: autocmd BufWritePost ~/.bmdirs,~/.bmfiles !shortcuts[J

line 184: [J

line 185: " Run xrdb whenever Xdefaults or Xresources are updated.[J

line 186: autocmd BufWritePost ~/.Xresources,~/.Xdefaults !xrdb %[J

line 187: map map [J

No mapping found[J
finished sourcing $HOME/.vimrc[J
Searching for "plugin/**/*.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/plugin/**/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-dirvish/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/vim-dirvish/plugin/dirvish.vim"[J
line 1: if exists('g:loaded_dirvish') || &cp || v:version < 700 || &cpo =~# 'C'[J

line 2:   finish[J

line 3: endif[J

line 4: let g:loaded_dirvish = 1[J

line 5: [J

line 6: command! -bar -nargs=? -complete=dir Dirvish call dirvish#open(<q-args>)[J

line 7: command! -nargs=* -complete=file -range -bang Shdo call dirvish#shdo(<bang>0 ? argv() : getline(<line1>, <line2>), <q-args>)[J

line 8: [J

line 9: function! s:isdir(dir)[J

line 13: [J

line 14: augroup dirvish_ftdetect[J

line 15:   autocmd![J

line 16:   " Remove netrw and NERDTree directory handlers.[J

line 17:   autocmd VimEnter * if exists('#FileExplorer') | exe 'au! FileExplorer *' | endif[J

line 18:   autocmd VimEnter * if exists('#NERDTreeHijackNetrw') | exe 'au! NERDTreeHijackNetrw *' | endif[J

line 21:   autocmd BufEnter * if !exists('b:dirvish') && <SID>isdir(expand('%')) | exe 'Dirvish %' | elseif exists('b:dirvish') && &buflisted && bufnr('$') > 1 | setlocal nobuflisted | endif[J

line 22:   autocmd FileType dirvish if exists('#fugitive') | call fugitive#detect(@%) | endif[J

line 23: augroup END[J

line 24: [J

line 25: nnoremap <silent> <Plug>(dirvish_up) :<C-U>exe 'Dirvish %:p'.repeat(':h',v:count1)<CR>[J

line 26: nnoremap <silent> <Plug>(dirvish_split_up) :<C-U>exe 'split +Dirvish\ %:p'.repeat(':h',v:count1)<CR>[J

line 27: nnoremap <silent> <Plug>(dirvish_vsplit_up) :<C-U>exe 'vsplit +Dirvish\ %:p'.repeat(':h',v:count1)<CR>[J

line 28: [J

line 29: highlight default link DirvishSuffix   SpecialKey[J

line 30: highlight default link DirvishPathTail Directory[J

line 31: highlight default link DirvishArg      Todo[J

line 32: [J

line 33: if mapcheck('-', 'n') ==# '' && !hasmapto('<Plug>(dirvish_up)', 'n')[J

line 34:   nmap - <Plug>(dirvish_up)[J

line 35: endif[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-dirvish/plugin/dirvish.vim[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/plugin/**/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-surround/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/vim-surround/plugin/surround.vim"[J
line 1: " surround.vim - Surroundings[J

line 2: " Author:       Tim Pope <http://tpo.pe/>[J

line 3: " Version:      2.1[J

line 4: " GetLatestVimScripts: 1697 1 :AutoInstall: surround.vim[J

line 5: [J

line 6: if exists("g:loaded_surround") || &cp || v:version < 700[J

line 7:   finish[J

line 8: endif[J

line 9: let g:loaded_surround = 1[J

line 10: [J

line 11: " Input functions {{{1[J

line 12: [J

line 13: function! s:getchar()[J

line 20: [J

line 21: function! s:inputtarget()[J

line 35: [J

line 36: function! s:inputreplacement()[J

line 47: [J

line 48: function! s:beep()[J

line 52: [J

line 53: function! s:redraw()[J

line 57: [J

line 58: " }}}1[J

line 59: [J

line 60: " Wrapping functions {{{1[J

line 61: [J

line 62: function! s:extractbefore(str)[J

line 69: [J

line 70: function! s:extractafter(str)[J

line 77: [J

line 78: function! s:fixindent(str,spc)[J

line 87: [J

line 88: function! s:process(string)[J

line 126: [J

line 127: function! s:wrap(string,char,type,removed,special)[J

line 302: [J

line 303: function! s:wrapreg(reg,char,removed,special)[J

line 309: " }}}1[J

line 310: [J

line 311: function! s:insert(...) " {{{1[J

line 362: [J

line 363: function! s:reindent() " {{{1[J

line 368: [J

line 369: function! s:dosurround(...) " {{{1[J

line 482: [J

line 483: function! s:changesurround(...) " {{{1[J

line 494: [J

line 495: function! s:opfunc(type, ...) abort " {{{1[J

line 561: [J

line 562: function! s:opfunc2(...) abort[J

line 569: [J

line 570: function! s:closematch(str) " {{{1[J

line 585: [J

line 586: nnoremap <silent> <Plug>SurroundRepeat .[J

line 587: nnoremap <silent> <Plug>Dsurround  :<C-U>call <SID>dosurround(<SID>inputtarget())<CR>[J

line 588: nnoremap <silent> <Plug>Csurround  :<C-U>call <SID>changesurround()<CR>[J

line 589: nnoremap <silent> <Plug>CSurround  :<C-U>call <SID>changesurround(1)<CR>[J

line 590: nnoremap <expr>   <Plug>Yssurround '^'.v:count1.<SID>opfunc('setup').'g_'[J

line 591: nnoremap <expr>   <Plug>YSsurround <SID>opfunc2('setup').'_'[J

line 592: nnoremap <expr>   <Plug>Ysurround  <SID>opfunc('setup')[J

line 593: nnoremap <expr>   <Plug>YSurround  <SID>opfunc2('setup')[J

line 594: vnoremap <silent> <Plug>VSurround  :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 1 : 0)<CR>[J

line 595: vnoremap <silent> <Plug>VgSurround :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 0 : 1)<CR>[J

line 596: inoremap <silent> <Plug>Isurround  <C-R>=<SID>insert()<CR>[J

line 597: inoremap <silent> <Plug>ISurround  <C-R>=<SID>insert(1)<CR>[J

line 598: [J

line 599: if !exists("g:surround_no_mappings") || ! g:surround_no_mappings[J

line 600:   nmap ds  <Plug>Dsurround[J

line 601:   nmap cs  <Plug>Csurround[J

line 602:   nmap cS  <Plug>CSurround[J

line 603:   nmap ys  <Plug>Ysurround[J

line 604:   nmap yS  <Plug>YSurround[J

line 605:   nmap yss <Plug>Yssurround[J

line 606:   nmap ySs <Plug>YSsurround[J

line 607:   nmap ySS <Plug>YSsurround[J

line 608:   xmap S   <Plug>VSurround[J

line 609:   xmap gS  <Plug>VgSurround[J

line 610:   if !exists("g:surround_no_insert_mappings") || ! g:surround_no_insert_mappings[J

line 611:     if !hasmapto("<Plug>Isurround","i") && "" == mapcheck("<C-S>","i")[J

line 612:       imap    <C-S> <Plug>Isurround[J

line 613:     endif[J

line 614:     imap      <C-G>s <Plug>Isurround[J

line 615:     imap      <C-G>S <Plug>ISurround[J

line 616:   endif[J

line 617: endif[J

line 618: [J

line 619: " vim:set ft=vim sw=2 sts=2 et:[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-surround/plugin/surround.vim[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/goyo.vim/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/goyo.vim/plugin/goyo.vim"[J
line 1: " Copyright (c) 2015 Junegunn Choi[J

line 2: "[J

line 3: " MIT License[J

line 4: "[J

line 5: " Permission is hereby granted, free of charge, to any person obtaining[J

line 6: " a copy of this software and associated documentation files (the[J

line 7: " "Software"), to deal in the Software without restriction, including[J

line 8: " without limitation the rights to use, copy, modify, merge, publish,[J

line 9: " distribute, sublicense, and/or sell copies of the Software, and to[J

line 10: " permit persons to whom the Software is furnished to do so, subject to[J

line 11: " the following conditions:[J

line 12: "[J

line 13: " The above copyright notice and this permission notice shall be[J

line 14: " included in all copies or substantial portions of the Software.[J

line 15: "[J

line 16: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,[J

line 17: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF[J

line 18: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND[J

line 19: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE[J

line 20: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION[J

line 21: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION[J

line 22: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.[J

line 23: [J

line 24: command! -nargs=? -bar -bang Goyo call goyo#execute(<bang>0, <q-args>)[J

finished sourcing /Users/ygarrot/.vim/plugged/goyo.vim/plugin/goyo.vim[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/plugin/**/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vimagit/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/vimagit/plugin/magit.vim"[J
line 1: scriptencoding utf-8[J

line 2: [J

line 3: if exists('g:loaded_magit') || !executable('git') || &cp[J

line 4:   finish[J

line 5: endif[J

line 6: let g:loaded_magit = 1[J

line 7: [J

line 8: let g:vimagit_version = [1, 7, 3][J

line 9: [J

line 10: " Initialisation {{{[J

line 11: [J

line 12: " FIXME: find if there is a minimum vim version required[J

line 13: " if v:version < 703[J

line 14: " endif[J

line 15: [J

line 16: " source common file. variables in common file are shared with plugin and[J

line 17: " syntax files[J

line 18: let g:vimagit_path = fnameescape(resolve(expand('<sfile>:p:h')))[J

line 19: execute 'source ' . g:vimagit_path . '/../common/magit_common.vim'[J

line 19: source /Users/ygarrot/.vim/plugged/vimagit/plugin/../common/magit_common.vim[J

chdir(/Users/ygarrot/.vim/plugged/vimagit/plugin/../common)[J
fchdir() to previous dir[J
line 19: sourcing "/Users/ygarrot/.vim/plugged/vimagit/plugin/../common/magit_common.vim"[J
line 1: " Section names[J

line 2: " These are used to beautify the magit buffer and to help for some block[J

line 3: " selection[J

line 11: let g:magit_sections = { 'info':           'Info', 'help':           'Help', 'staged':         'Staged changes', 'unstaged':       'Unstaged changes', 'commit':         'Commit message', 'stash':          'Stash list' }[J

line 12: [J

line 19: let g:magit_section_info = { 'cur_repo':       'Repository:', 'cur_head':       'Head:', 'cur_upstream':   'Upstream:', 'cur_push':       'Push:', 'commit_mode':    'Commit mode:', }[J

line 20: [J

line 35: let g:magit_git_status_code = { 'M': 'modified',  'A': 'added', 'D': 'deleted', 'R': 'renamed', 'T': 'typechanged', 'C': 'copied', 'U': 'updated but unmerged', '?': 'untracked', '!': 'ignored', 'E': 'empty', 'L': 'symlink', 'N': 'new dir', 'S': 'submodule', }[J

line 36: [J

line 40: let g:magit_commit_mode = { 'CC': 'normal', 'CA': 'amend', }[J

line 41: [J

line 42: " Regular expressions used to select blocks[J

line 43: let g:magit_file_re  = '^\('[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 44: for status_code in values(g:magit_git_status_code)[J

line 45: ^Ilet g:magit_file_re .= status_code . '\|'[J

line 46: endfor[J

line 47: let g:magit_file_re .= 'unknown status\): \(.\{-\}\)\%( -> .*\)\?$'[J

line 48: [J

line 49: let g:magit_section_re  = '^\('[J

line 50: for section_name in values(g:magit_sections)[J

line 51: ^Ilet g:magit_section_re .= section_name . '\|'[J

line 52: endfor[J

line 50: for section_name in values(g:magit_sections)[J

line 51: ^Ilet g:magit_section_re .= section_name . '\|'[J

line 52: endfor[J

line 50: for section_name in values(g:magit_sections)[J

line 51: ^Ilet g:magit_section_re .= section_name . '\|'[J

line 52: endfor[J

line 50: for section_name in values(g:magit_sections)[J

line 51: ^Ilet g:magit_section_re .= section_name . '\|'[J

line 52: endfor[J

line 50: for section_name in values(g:magit_sections)[J

line 51: ^Ilet g:magit_section_re .= section_name . '\|'[J

line 52: endfor[J

line 50: for section_name in values(g:magit_sections)[J

line 51: ^Ilet g:magit_section_re .= section_name . '\|'[J

line 52: endfor[J

line 50: for section_name in values(g:magit_sections)[J

line 51: ^Ilet g:magit_section_re .= section_name . '\|'[J

line 52: endfor[J

line 53: let g:magit_section_re .= 'unknown section\)$'[J

line 54: [J

line 55: let g:magit_diff_re  = '^diff --git'[J

line 56: let g:magit_end_diff_re  = '^$'[J

line 57: let g:magit_stash_re = '^stash@{\d\+}:'[J

line 58: let g:magit_hunk_re  = '^@@ -\(\d\+\),\?\(\d*\) +\(\d\+\),\?\(\d*\) @@'[J

line 59: let g:magit_bin_re   = '^Binary files '[J

line 60: let g:magit_eof_re   = '\%$'[J

line 61: [J

line 62: [J

finished sourcing /Users/ygarrot/.vim/plugged/vimagit/plugin/../common/magit_common.vim[J
continuing in /Users/ygarrot/.vim/plugged/vimagit/plugin/magit.vim[J
line 20: [J

line 21: " these mappings are broadly applied, for all vim buffers[J

line 22: let g:magit_show_magit_mapping     = get(g:, 'magit_show_magit_mapping',        '<leader>M' )[J

line 23: [J

line 24: " user options[J

line 25: let g:magit_enabled                = get(g:, 'magit_enabled',                   1)[J

line 26: let g:magit_show_help              = get(g:, 'magit_show_help',                 0)[J

line 27: let g:magit_default_show_all_files = get(g:, 'magit_default_show_all_files',    1)[J

line 28: let g:magit_default_fold_level     = get(g:, 'magit_default_fold_level',        1)[J

line 29: let g:magit_auto_close             = get(g:, 'magit_auto_close',                0)[J

line 30: let g:magit_auto_foldopen            = get(g:, 'magit_auto_foldopen',               1)[J

line 31: let g:magit_default_sections       = get(g:, 'magit_default_sections',          ['info', 'global_help', 'commit', 'staged', 'unstaged'])[J

line 32: let g:magit_discard_untracked_do_delete = get(g:, 'magit_discard_untracked_do_delete',        0)[J

line 33: [J

line 34: let g:magit_refresh_gutter         = get(g:, 'magit_refresh_gutter'   ,         1)[J

line 35: " Should deprecate the following[J

line 36: let g:magit_refresh_gitgutter      = get(g:, 'magit_refresh_gitgutter',         0)[J

line 37: [J

line 38: let g:magit_commit_title_limit     = get(g:, 'magit_commit_title_limit',        50)[J

line 39: [J

line 40: let g:magit_scrolloff              = get(g:, 'magit_scrolloff',                 3)[J

line 41: [J

line 42: let g:magit_warning_max_lines      = get(g:, 'magit_warning_max_lines',         10000)[J

line 43: [J

line 44: let g:magit_git_cmd                = get(g:, 'magit_git_cmd'          ,         "git")[J

line 45: [J

line 46: execute "nnoremap <silent> " . g:magit_show_magit_mapping . " :call magit#show_magit('v')<cr>"[J

line 46: nnoremap <silent> <leader>M :call magit#show_magit('v')<cr>[J

line 47: [J

line 48: if (g:magit_refresh_gutter == 1 || g:magit_refresh_gitgutter == 1)[J

line 54:   autocmd User VimagitUpdateFile if ( exists("*gitgutter#process_buffer") ) |   call gitgutter#process_buffer(bufnr(g:magit_last_updated_buffer), 0) | elseif ( exists("*sy#util#refresh_windows") ) |   call sy#util#refresh_windows() | endif[J

line 55: endif[J

line 56: " }}}[J

line 57: [J

line 58: " s:mg_cut_str cut a string given a limit size[J

line 59: " param[in] str string to cut[J

line 60: " param[in] limit maximum number of column[J

line 61: " return string cut on limit[J

line 62: function! s:mg_cut_str(str, limit)[J

line 71: [J

line 72: " s:mg_get_info: this function writes in current buffer current git state[J

line 73: " WARNING: this function writes in file, it should only be called through[J

line 74: " protected functions like magit#update_buffer[J

line 75: function! s:mg_get_info()[J

line 127: [J

line 128: " s:mg_display_files: display in current buffer files, filtered by some[J

line 129: " parameters[J

line 130: " param[in] mode: files mode, can be 'staged' or 'unstaged'[J

line 131: " param[in] curdir: directory containing files (only needed for untracked[J

line 132: " directory)[J

line 133: " param[in] depth: current directory depth (only needed for untracked[J

line 134: " directory)[J

line 135: function! s:mg_display_files(mode, curdir, depth)[J

line 173: [J

line 174: " s:mg_get_staged_section: this function writes in current buffer all staged[J

line 175: " or unstaged files, using b:state.dict information[J

line 176: " WARNING: this function writes in file, it should only be called through[J

line 177: " protected functions like magit#update_buffer[J

line 178: " param[in] mode: 'staged' or 'unstaged'[J

line 179: function! s:mg_get_staged_section(mode)[J

line 187: [J

line 188: " s:mg_get_stashes: this function write in current buffer all stashes[J

line 189: " WARNING: this function writes in file, it should only be called through[J

line 190: " protected functions like magit#update_buffer[J

line 191: function! s:mg_get_stashes()[J

line 213: [J

line 214: " b:magit_current_commit_msg: this variable store the current commit message,[J

line 215: " saving it among refreshes (remember? the whole buffer is wiped at each[J

line 216: " refresh).[J

line 217: let b:magit_current_commit_msg = [][J

line 218: [J

line 219: " s:mg_get_commit_section: this function writes in current buffer the commit[J

line 220: " section. It is a commit message, depending on b:magit_current_commit_mode[J

line 221: " WARNING: this function writes in file, it should only be called through[J

line 222: " protected functions like magit#update_buffer[J

line 223: " param[in] b:magit_current_commit_mode: this function uses global commit mode[J

line 224: "       'CC': prepare a brand new commit message[J

line 225: "       'CA': get the last commit message[J

line 226: function! s:mg_get_commit_section()[J

line 251: [J

line 252: " s:mg_search_block: helper function, to get start and end line of a block,[J

line 253: " giving a start and multiple end pattern[J

line 254: " a "pattern parameter" is a List:[J

line 255: "   @[0]: end pattern regex[J

line 256: "   @[1]: number of line to exclude above (negative), below (positive) or none (0)[J

line 257: " param[in] start_pattern: start "pattern parameter", which will be search[J

line 258: " backward (cursor position is set to end of line before searching, to find the[J

line 259: " pattern if on the current line)[J

line 260: " param[in] end_pattern: list of end "pattern parameter". Each pattern is [J

line 261: " searched in order. It'll choose the match with the minimum line number[J

line 262: " (smallest region search)[J

line 263: " param[in] upperlimit_pattern: regex of upper limit. If start_pattern line is[J

line 264: " inferior to upper_limit line, block is discarded[J

line 265: " param[in]: end_pattern_on_cursor: boolean, if true end pattern is also[J

line 266: " search on cursor position[J

line 267: " return: [startline, endline][J

line 269: function! s:mg_search_block(start_pattern, end_pattern, upper_limit_pattern, end_pattern_on_cursor)[J

line 297: [J

line 298: " s:mg_get_commit_msg: get the commit meesgae currently in commit section[J

line 299: " return a string containg the commit message[J

line 300: " \param[in] out_of_block (optional): if set, will first move the cursor to[J

line 301: " the commit block before getting content[J

line 302: function! s:mg_get_commit_msg(...)[J

line 332: [J

line 333: " s:mg_git_commit: commit staged stuff with message prepared in commit section[J

line 334: " param[in] mode: mode to commit[J

line 335: "       'CF': don't use commit section, just amend previous commit with staged[J

line 336: "       stuff, without modifying message[J

line 337: "       'CC': commit staged stuff with message in commit section to a brand new[J

line 338: "       commit[J

line 339: "       'CA': commit staged stuff with message in commit section amending last[J

line 340: "       commit[J

line 341: " return no[J

line 342: function! s:mg_git_commit(mode) abort[J

line 392: [J

line 393: " s:mg_select_file_block: select the whole diff file, relative to the current[J

line 394: " cursor position[J

line 395: " nota: if the cursor is not in a diff file when the function is called, this[J

line 396: " function will fail[J

line 397: " return: a List[J

line 398: "         @[0]: return value[J

line 399: "         @[1]: List of lines containing the patch for the whole file[J

line 400: function! s:mg_select_file_block()[J

line 413: [J

line 414: " s:mg_select_hunk_block: select a hunk, from the current cursor position[J

line 415: " nota: if the cursor is not in a hunk when the function is called, this[J

line 416: " function will fail[J

line 417: " return: a List[J

line 418: "         @[0]: return value[J

line 419: "         @[1]: List of lines containing the hunk[J

line 420: function! s:mg_select_hunk_block()[J

line 433: [J

line 434: " s:mg_create_diff_from_select: craft the diff to apply from a selection[J

line 435: " in a chunk[J

line 436: " remarks: it works with full lines, and can not span over multiple chunks[J

line 437: " param[in] select_lines: List containing all selected line numbers[J

line 438: " return: List containing the diff to apply, including the chunk header (must[J

line 439: " be applied with git apply --recount)[J

line 440: function! s:mg_create_diff_from_select(select_lines)[J

line 488: [J

line 489: " s:mg_mark_lines_in_hunk: this function toggle marks for selected lines in a[J

line 490: " hunk.[J

line 491: " if a hunk contains marked lines, only these lines will be (un)staged on next[J

line 492: " (un)stage command[J

line 493: " param[in] start_select_line,end_select_line: limits of the selection[J

line 494: function! s:mg_mark_lines_in_hunk(start_select_line, end_select_line)[J

line 501: [J

line 502: " }}}[J

line 503: [J

line 504: " {{{ User functions and commands[J

line 505: [J

line 506: " magit#open_close_folding()[J

line 507: " param[in] visible : boolean, force visible value. If not set, toggle[J

line 508: " visibility[J

line 509: function! magit#open_close_folding(...)[J

Searching for "autoload/magit.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/autoload/magit.vim"[J
Searching for "/usr/share/vim/vimfiles/autoload/magit.vim"[J
Searching for "/usr/share/vim/vim74/autoload/magit.vim"[J
Searching for "/usr/share/vim/vimfiles/after/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.vim/after/autoload/magit.vim"[J
Searching for "/Users/ygarrot/.opam/default/share/merlin/vim/autoload/magit.vim"[J
not found in 'runtimepath': "autoload/magit.vim"[J
line 526: [J

line 527: let g:magit_last_updated_buffer = ''[J

line 528: [J

line 529: " s:mg_display_functions: Dict wrapping all display related functions[J

line 530: " This Dict should be accessed through g:magit_default_sections[J

line 538: let s:mg_display_functions = { 'info':        { 'fn': function("s:mg_get_info"), 'arg': []}, 'global_help': { 'fn': function("magit#mapping#get_section_help"), 'arg': ['global']}, 'commit':      { 'fn': function("s:mg_get_commit_section"), 'arg': []}, 'staged':      { 'fn': function("s:mg_get_staged_section"), 'arg': ['staged']}, 'unstaged':    { 'fn': function("s:mg_get_staged_section"), 'arg': ['unstaged']}, 'stash':       { 'fn': function("s:mg_get_stashes"), 'arg': []}, }[J

line 539: [J

line 540: " magit#update_buffer: this function:[J

line 541: " 1. checks that current buffer is the wanted one[J

line 542: " 2. save window state (cursor position...)[J

line 543: " 3. delete buffer[J

line 544: " 4. fills with unstage stuff[J

line 545: " 5. restore window state[J

line 546: " param[in] updated file (optional): this filename is updated to absolute[J

line 547: " path, set in g:magit_last_updated_buffer and the User autocmd[J

line 548: " param[in] current section (optional)[J

line 549: " param[in] current hunk id[J

line 550: " when params 1 & 2 & 3 are set, it means[J

line 551: " that a stage/unstage action occured. We try to smartly set the cursor[J

line 552: " position after the refresh[J

line 553: "  - on current file on closest hunk if still contains hunks in current section[J

line 554: "  - else on next file if any[J

line 555: "  - else on previous file if any[J

line 556: "  - or cursor stay where it is[J

line 557: " VimagitUpdateFile event is raised[J

line 558: function! magit#update_buffer(...)[J

line 717: [J

line 718: " magit#toggle_help: toggle inline help showing in magit buffer[J

line 719: function! magit#toggle_help()[J

line 723: [J

line 724: " magit#show_magit: prepare and show magit buffer[J

line 725: " it also set local mappings to magit buffer[J

line 726: " param[in] display:[J

line 727: "     'v': vertical split[J

line 728: "     'h': horizontal split[J

line 729: "     'c': current buffer (should be used when opening vim in vimagit mode[J

line 730: function! magit#show_magit(display, ...)[J

line 915: [J

line 916: function! magit#close_magit()[J

line 931: [J

line 932: function! s:mg_stage_closed_file(discard)[J

line 988: [J

line 989: " magit#stage_block: this function (un)stage a block, according to parameter[J

line 990: " INFO: in unstaged section, it stages the hunk, and in staged section, it[J

line 991: " unstages the hunk[J

line 992: " param[in] block_type: can be 'file' or 'hunk'[J

line 993: " param[in] discard: boolean, if true, discard instead of (un)stage[J

line 994: " return: no[J

line 995: function! magit#stage_block(selection, discard) abort[J

line 1059: [J

line 1060: " magit#stage_file: this function (un)stage a whole file, from the current[J

line 1061: " cursor position[J

line 1062: " INFO: in unstaged section, it stages the file, and in staged section, it[J

line 1063: " unstages the file[J

line 1064: " return: no[J

line 1065: function! magit#stage_file()[J

line 1088: "[J

line 1089: " magit#stage_hunk: this function (un)stage/discard a hunk, from the current[J

line 1090: " cursor position[J

line 1091: " INFO: in unstaged section, it stages the hunk, and in staged section, it[J

line 1092: " unstages the hunk[J

line 1093: " param[in] discard:[J

line 1094: "     - when set to 0, (un)stage[J

line 1095: "     - when set to 1, discard[J

line 1096: " return: no[J

line 1097: function! magit#stage_hunk(discard)[J

line 1131: [J

line 1132: " magit#stage_vselect: this function (un)stage text being sectected in Visual[J

line 1133: " mode[J

line 1134: " remarks: it works with full lines, and can not span over multiple chunks[J

line 1135: " INFO: in unstaged section, it stages the file, and in staged section, it[J

line 1136: " unstages the file[J

line 1137: " return: no[J

line 1138: function! magit#stage_vselect() range[J

line 1161: [J

line 1162: " magit#mark_vselect: wrapper function to mark selected lines (see[J

line 1163: " mg_mark_lines_in_hunk)[J

line 1164: function! magit#mark_vselect() range[J

line 1167: [J

line 1168: " magit#ignore_file: this function add the file under cursor to .gitignore[J

line 1169: " FIXME: git diff adds some strange characters to end of line[J

line 1170: function! magit#ignore_file() abort[J

line 1176: [J

line 1177: " set magit buffer in write mode[J

line 1178: function! s:set_mode_write()[J

line 1181: [J

line 1182: " set magit buffer in read only mode[J

line 1183: function! s:set_mode_read()[J

line 1186: [J

line 1187: " magit#commit_command: entry function for commit mode[J

line 1188: " INFO: it has a different effect if current section is commit section or not[J

line 1189: " param[in] mode: commit mode[J

line 1190: "   'CF': do not set global b:magit_current_commit_mode, directly call magit#git_commit[J

line 1191: "   'CA'/'CF': if in commit section mode, call magit#git_commit, else just set[J

line 1192: "   global state variable b:magit_current_commit_mode,[J

line 1193: function! magit#commit_command(mode)[J

line 1219: [J

line 1220: " magit#close_commit: cancel for commit mode[J

line 1221: " close commit section if opened[J

line 1222: function! magit#close_commit()[J

line 1241: [J

line 1242: " magit#jump_hunk: function to jump among hunks[J

line 1243: " it closes the current fold (if any), jump to next hunk and unfold it[J

line 1244: " param[in] dir: can be 'N' (for next) or 'P' (for previous)[J

line 1245: function! magit#jump_hunk(dir)[J

line 1275: [J

line 1276: " magit#get_staged_files: function returning an array with staged files names[J

line 1277: " return: an array with staged files names[J

line 1278: function! magit#get_staged_files()[J

line 1281: [J

line 1282: " magit#get_staged_files: function returning an array with unstaged files[J

line 1283: " names[J

line 1284: " return: an array with unstaged files names[J

line 1285: function! magit#get_unstaged_files()[J

line 1288: [J

line 1289: " magit#jump_to: function to move cursor to the file location of the current[J

line 1290: " hunk[J

line 1291: " if this file is already displayed in a window, jump to the window, if not,[J

line 1292: " jump to last window and open buffer, at the beginning of the hunk[J

line 1293: function! magit#jump_to()[J

line 1326: [J

line 1327: function! magit#update_diff(way)[J

line 1337: [J

line 1338: function! magit#show_version()[J

line 1343: [J

line 1344: function! magit#get_current_mode()[J

line 1353: [J

line 1354: command! Magit call magit#show_magit('v')[J

line 1355: command! MagitOnly call magit#show_magit('c')[J

line 1356: [J

line 1357: " }}}[J

finished sourcing /Users/ygarrot/.vim/plugged/vimagit/plugin/magit.vim[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vimwiki/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim"[J
line 1: " vim:tabstop=2:shiftwidth=2:expandtab:textwidth=99[J

line 2: " Vimwiki plugin file[J

line 3: " Home: https://github.com/vimwiki/vimwiki/[J

line 4: " GetLatestVimScripts: 2226 1 :AutoInstall: vimwiki[J

line 5: [J

line 6: [J

line 7: if exists("g:loaded_vimwiki") || &cp[J

line 8:   finish[J

line 9: endif[J

line 10: let g:loaded_vimwiki = 1[J

line 11: [J

line 12: " Set to version number for release, otherwise -1 for dev-branch[J

line 13: let s:plugin_vers = "2.4.1"[J

line 14: [J

line 15: " Get the directory the script is installed in[J

line 16: let s:plugin_dir = expand('<sfile>:p:h:h')[J

line 17: [J

line 18: let s:old_cpo = &cpo[J

line 19: set cpo&vim[J

line 20: [J

line 21: [J

line 22: if exists('g:vimwiki_autowriteall')[J

line 23:   let s:vimwiki_autowriteall_saved = g:vimwiki_autowriteall[J

line 24: else[J

line 25:   let s:vimwiki_autowriteall_saved = 1[J

line 26: endif[J

line 27: [J

line 28: [J

line 29: " this is called when the cursor leaves the buffer[J

line 30: function! s:setup_buffer_leave()[J

line 43: [J

line 44: [J

line 45: " create a new temporary wiki for the current buffer[J

line 46: function! s:create_temporary_wiki()[J

line 68: [J

line 69: [J

line 70: " This function is called when Vim opens a new buffer with a known wiki[J

line 71: " extension. Both when the buffer has never been opened in this session and[J

line 72: " when it has.[J

line 73: function! s:setup_new_wiki_buffer()[J

line 95: [J

line 96: [J

line 97: " this is called when the cursor enters the buffer[J

line 98: function! s:setup_buffer_enter()[J

line 113: [J

line 114: [J

line 115: function! s:setup_cleared_syntax()[J

line 131: [J

line 132: [J

line 133: function! s:vimwiki_get_known_extensions()[J

line 146: [J

line 147: [J

line 148: " Set settings which are global for Vim, but should only be executed for[J

line 149: " Vimwiki buffers. So they must be set when the cursor enters a Vimwiki buffer[J

line 150: " and reset when the cursor leaves the buffer.[J

line 151: function! s:set_global_options()[J

line 159: [J

line 160: [J

line 161: " Set settings which are local to a window. In a new tab they would be reset to[J

line 162: " Vim defaults. So we enforce our settings here when the cursor enters a[J

line 163: " Vimwiki buffer.[J

line 164: function! s:set_windowlocal_options()[J

line 194: [J

line 195: [J

line 196: function! s:get_version()[J

line 212: [J

line 213: [J

line 214: [J

line 215: " Initialization of Vimwiki starts here. Make sure everything below does not[J

line 216: " cause autoload/vimwiki/base.vim to be loaded[J

line 217: [J

line 218: call vimwiki#vars#init()[J

Searching for "autoload/vimwiki/vars.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/autoload/vimwiki/vars.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/autoload/vimwiki/vars.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/autoload/vimwiki/vars.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/autoload/vimwiki/vars.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/autoload/vimwiki/vars.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/autoload/vimwiki/vars.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/autoload/vimwiki/vars.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/autoload/vimwiki/vars.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vimwiki/autoload/vimwiki)[J
fchdir() to previous dir[J
line 218: sourcing "/Users/ygarrot/.vim/plugged/vimwiki/autoload/vimwiki/vars.vim"[J
line 1: " vim:tabstop=2:shiftwidth=2:expandtab:textwidth=99[J

line 2: " Vimwiki autoload plugin file[J

line 3: " Home: https://github.com/vimwiki/vimwiki/[J

line 4: [J

line 5: [J

line 6: [J

line 7: " ------------------------------------------------------------------------------------------------[J

line 8: " This file provides functions to manage the various state variables which are needed during a[J

line 9: " Vimwiki session.[J

line 10: " They consist of:[J

line 11: "[J

line 12: " - global variables. These are stored in the dict g:vimwiki_global_vars. They consist mainly of[J

line 13: "   global user variables and syntax stuff which is the same for every syntax.[J

line 14: "[J

line 15: " - wiki-local variables. They are stored in g:vimwiki_wikilocal_vars which is a list of[J

line 16: "   dictionaries, one dict for every registered wiki. The last dictionary contains default values[J

line 17: "   (used for temporary wikis).[J

line 18: "[J

line 19: " - syntax variables. Stored in the dict g:vimwiki_syntax_variables which holds all the regexes and[J

line 20: "   other stuff which is needed for highlighting.[J

line 21: "[J

line 22: " - buffer-local variables. They are stored as buffer variables directly (b:foo)[J

line 23: [J

line 24: " As a developer, you should, if possible, only use the get_ and set_ functions for these types of[J

line 25: " variables, not the underlying dicts![J

line 26: " ------------------------------------------------------------------------------------------------[J

line 27: [J

line 28: [J

line 29: function! s:populate_global_variables()[J

line 140: [J

line 141: [J

line 142: function! s:read_global_settings_from_user()[J

line 222: [J

line 223: [J

line 224: function! s:normalize_global_settings()[J

line 239: [J

line 240: [J

line 241: function! s:populate_wikilocal_options()[J

line 326: [J

line 327: [J

line 328: function! s:check_users_value(key, users_value, value_infos, comes_from_global_variable)[J

line 380: [J

line 381: [J

line 382: function! s:normalize_wikilocal_settings()[J

line 408: [J

line 409: [J

line 410: function! s:normalize_path(path)[J

line 419: [J

line 420: [J

line 421: function! vimwiki#vars#populate_syntax_vars(syntax)[J

line 600: [J

line 601: [J

line 602: function! s:populate_extra_markdown_vars()[J

line 746: [J

line 747: [J

line 748: function! vimwiki#vars#init()[J

line 752: [J

line 753: [J

line 754: function! vimwiki#vars#get_syntaxlocal(key, ...)[J

line 766: [J

line 767: [J

line 768: " Get a variable for the buffer we are currently in or for the given buffer (number or name).[J

line 769: " Populate the variable, if it doesn't exist.[J

line 770: function! vimwiki#vars#get_bufferlocal(key, ...)[J

line 799: [J

line 800: [J

line 801: function! vimwiki#vars#set_bufferlocal(key, value, ...)[J

line 805: [J

line 806: [J

line 807: function! vimwiki#vars#get_global(key)[J

line 810: [J

line 811: [J

line 812: " the second argument can be a wiki number. When absent, the wiki of the currently active buffer is[J

line 813: " used[J

line 814: function! vimwiki#vars#get_wikilocal(key, ...)[J

line 821: [J

line 822: [J

line 823: function! vimwiki#vars#get_wikilocal_default(key)[J

line 826: [J

line 827: [J

line 828: function! vimwiki#vars#set_wikilocal(key, value, wiki_nr)[J

line 834: [J

line 835: [J

line 836: function! vimwiki#vars#add_temporary_wiki(settings)[J

line 844: [J

line 845: [J

line 846: " number of registered wikis + temporary[J

line 847: function! vimwiki#vars#number_of_wikis()[J

line 850: [J

finished sourcing /Users/ygarrot/.vim/plugged/vimwiki/autoload/vimwiki/vars.vim[J
continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J
calling function vimwiki#vars#init[J()

line 1:   call s:populate_global_variables()[J

calling function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[J()

line 1: [J

line 2:   let g:vimwiki_global_vars = {}[J

line 3: [J

line 4:   call s:read_global_settings_from_user()[J

calling function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[4]..<SNR>21_read_global_settings_from_user[J()

line 1:   let global_settings = { 'CJK_length': {'type': type(0), 'default': 0, 'min': 0, 'max': 1}, 'auto_chdir': {'type': type(0), 'default': 0, 'min': 0, 'max': 1}, 'autowriteall': {'type': type(0), 'default': 1, 'min': 0, 'max': 1}, 'conceallevel': {'type': type(0), 'default': 2, 'min': 0, 'max': 3}, 'diary_months': {'type': type({}), 'default':   {     1: 'January', 2: 'February', 3: 'March',     4: 'April', 5: 'May', 6: 'June',     7: 'July', 8: 'August', 9: 'September',     10: 'October', 11: 'November', 12: 'December'   }}, 'dir_link': {'type': type(''), 'default': ''}, 'ext2syntax': {'type': type({}), 'default': {}}, 'folding': {'type': type(''), 'default': '', 'possible_values': ['', 'expr', 'syntax',     'list', 'custom', ':quick', 'expr:quick', 'syntax:quick', 'list:quick',     'custom:quick']}, 'global_ext': {'type': type(0), 'default': 1, 'min': 0, 'max': 1}, 'hl_cb_checked': {'type': type(0), 'default': 0, 'min': 0, 'max': 2}, 'hl_headers': {'type': type(0), 'default': 0, 'min': 0, 'max': 1}, '[J

line 40: [J

line 41:   " copy the user's settings from variables of the form g:vimwiki_<option> into the dict[J

line 42:   " g:vimwiki_global_vars (or set a default value)[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

calling function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[4]..<SNR>21_read_global_settings_from_user[48]..<SNR>21_check_users_value[J('ext2syntax', {'.markdown': 'markdown', '.md': 'mar... '.Rmd': 'markdown', '.rmd': 'markdown'}, {'type': 4, 'default': {}}, 1)

line 1:   let type_code_to_name = { type(0): 'number', type(''): 'string', type([]): 'list', type({}): 'dictionary'}[J

line 6: [J

line 7:   let setting_origin = a:comes_from_global_variable ? printf('''g:vimwiki_%s''', a:key) : printf('''%s'' in g:vimwiki_list', a:key)[J

line 10: [J

line 11:   if has_key(a:value_infos, 'type') && type(a:users_value) != a:value_infos.type[J

line 12:     echom printf('Vimwiki Error: The provided value of the option %s is a %s, ' . 'but expected is a %s. See '':h g:vimwiki_%s''.', setting_origin, type_code_to_name[type(a:users_value)], type_code_to_name[a:value_infos.type], a:key)[J

line 15:   endif[J

line 16: [J

line 17:   if a:value_infos.type == type(0) && has_key(a:value_infos, 'min') && a:users_value < a:value_infos.min[J

line 19:     echom printf('Vimwiki Error: The provided value ''%i'' of the option %s is' . ' too small. The minimum value is %i. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.min, a:key)[J

line 22:   endif[J

line 23: [J

line 24:   if a:value_infos.type == type(0) && has_key(a:value_infos, 'max') && a:users_value > a:value_infos.max[J

line 26:     echom printf('Vimwiki Error: The provided value ''%i'' of the option %s is' . ' too large. The maximum value is %i. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.max, a:key)[J

line 29:   endif[J

line 30: [J

line 31:   if has_key(a:value_infos, 'possible_values') && index(a:value_infos.possible_values, a:users_value) == -1[J

line 33:     echom printf('Vimwiki Error: The provided value ''%s'' of the option %s is' . ' invalid. Allowed values are %s. See ''g:vimwiki_%s''.', a:users_value, setting_origin, string(a:value_infos.possible_values), a:key)[J

line 36:   endif[J

line 37: [J

line 38:   if a:value_infos.type == type('') && has_key(a:value_infos, 'length') && strwidth(a:users_value) != a:value_infos.length[J

line 40:     echom printf('Vimwiki Error: The provided value ''%s'' of the option %s must' . ' contain exactly %i character(s) but has %i. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.length, strwidth(a:users_value), a:key)[J

line 43:   endif[J

line 44: [J

line 45:   if a:value_infos.type == type('') && has_key(a:value_infos, 'min_length') && strwidth(a:users_value) < a:value_infos.min_length[J

line 47:     echom printf('Vimwiki Error: The provided value ''%s'' of the option %s must' . ' have at least %d character(s) but has %d. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.min_length, strwidth(a:users_value), a:key)[J

line 50:   endif[J

function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[4]..<SNR>21_read_global_settings_from_user[48]..<SNR>21_check_users_value returning #0[J

continuing in function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[4]..<SNR>21_read_global_settings_from_user[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 43:   for key in keys(global_settings)[J

line 44:     if exists('g:vimwiki_'.key)[J

line 45:       let users_value = g:vimwiki_{key}[J

line 46:       let value_infos = global_settings[key][J

line 47: [J

line 48:       call s:check_users_value(key, users_value, value_infos, 1)[J

line 49: [J

line 50:       let g:vimwiki_global_vars[key] = users_value[J

line 51:     else[J

line 52:       let g:vimwiki_global_vars[key] = global_settings[key].default[J

line 53:     endif[J

line 54:   endfor[J

line 55: [J

line 56:   " validate some settings individually[J

line 57: [J

line 58:   let key = 'diary_months'[J

line 59:   let users_value = g:vimwiki_global_vars[key][J

line 60:   for month in range(1, 12)[J

line 61:     if !has_key(users_value, month) || type(users_value[month]) != type('') || empty(users_value[month])[J

line 63:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 65:       break[J

line 66:     endif[J

line 67:   endfor[J

line 60:   for month in range(1, 12)[J

line 61:     if !has_key(users_value, month) || type(users_value[month]) != type('') || empty(users_value[month])[J

line 63:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 65:       break[J

line 66:     endif[J

line 67:   endfor[J

line 60:   for month in range(1, 12)[J

line 61:     if !has_key(users_value, month) || type(users_value[month]) != type('') || empty(users_value[month])[J

line 63:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 65:       break[J

line 66:     endif[J

line 67:   endfor[J

line 60:   for month in range(1, 12)[J

line 61:     if !has_key(users_value, month) || type(users_value[month]) != type('') || empty(users_value[month])[J

line 63:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 65:       break[J

line 66:     endif[J

line 67:   endfor[J

line 60:   for month in range(1, 12)[J

line 61:     if !has_key(users_value, month) || type(users_value[month]) != type('') || empty(users_value[month])[J

line 63:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 65:       break[J

line 66:     endif[J

line 67:   endfor[J

line 60:   for month in range(1, 12)[J

line 61:     if !has_key(users_value, month) || type(users_value[month]) != type('') || empty(users_value[month])[J

line 63:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 65:       break[J

line 66:     endif[J

line 67:   endfor[J

line 60:   for month in range(1, 12)[J

line 61:     if !has_key(users_value, month) || type(users_value[month]) != type('') || empty(users_value[month])[J

line 63:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 65:       break[J

line 66:     endif[J

line 67:   endfor[J

line 60:   for month in range(1, 12)[J

line 61:     if !has_key(users_value, month) || type(users_value[month]) != type('') || empty(users_value[month])[J

line 63:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 65:       break[J

line 66:     endif[J

line 67:   endfor[J

line 60:   for month in range(1, 12)[J

line 61:     if !has_key(users_value, month) || type(users_value[month]) != type('') || empty(users_value[month])[J

line 63:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 65:       break[J

line 66:     endif[J

line 67:   endfor[J

line 60:   for month in range(1, 12)[J

line 61:     if !has_key(users_value, month) || type(users_value[month]) != type('') || empty(users_value[month])[J

line 63:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 65:       break[J

line 66:     endif[J

line 67:   endfor[J

line 60:   for month in range(1, 12)[J

line 61:     if !has_key(users_value, month) || type(users_value[month]) != type('') || empty(users_value[month])[J

line 63:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 65:       break[J

line 66:     endif[J

line 67:   endfor[J

line 60:   for month in range(1, 12)[J

line 61:     if !has_key(users_value, month) || type(users_value[month]) != type('') || empty(users_value[month])[J

line 63:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 65:       break[J

line 66:     endif[J

line 67:   endfor[J

line 60:   for month in range(1, 12)[J

line 61:     if !has_key(users_value, month) || type(users_value[month]) != type('') || empty(users_value[month])[J

line 63:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 65:       break[J

line 66:     endif[J

line 67:   endfor[J

line 68: [J

line 69:   let key = 'ext2syntax'[J

line 70:   let users_value = g:vimwiki_global_vars[key][J

line 71:   for ext in keys(users_value)[J

line 72:     if empty(ext) || index(['markdown', 'media', 'mediawiki', 'default'], users_value[ext]) == -1[J

line 73:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 75:       break[J

line 76:     endif[J

line 77:   endfor[J

line 71:   for ext in keys(users_value)[J

line 72:     if empty(ext) || index(['markdown', 'media', 'mediawiki', 'default'], users_value[ext]) == -1[J

line 73:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 75:       break[J

line 76:     endif[J

line 77:   endfor[J

line 71:   for ext in keys(users_value)[J

line 72:     if empty(ext) || index(['markdown', 'media', 'mediawiki', 'default'], users_value[ext]) == -1[J

line 73:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 75:       break[J

line 76:     endif[J

line 77:   endfor[J

line 71:   for ext in keys(users_value)[J

line 72:     if empty(ext) || index(['markdown', 'media', 'mediawiki', 'default'], users_value[ext]) == -1[J

line 73:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 75:       break[J

line 76:     endif[J

line 77:   endfor[J

line 71:   for ext in keys(users_value)[J

line 72:     if empty(ext) || index(['markdown', 'media', 'mediawiki', 'default'], users_value[ext]) == -1[J

line 73:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 75:       break[J

line 76:     endif[J

line 77:   endfor[J

line 71:   for ext in keys(users_value)[J

line 72:     if empty(ext) || index(['markdown', 'media', 'mediawiki', 'default'], users_value[ext]) == -1[J

line 73:       echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 75:       break[J

line 76:     endif[J

line 77:   endfor[J

line 78: [J

function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[4]..<SNR>21_read_global_settings_from_user returning #0[J

continuing in function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[J

line 5:   call s:normalize_global_settings()[J

calling function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[5]..<SNR>21_normalize_global_settings[J()

line 1:   let keys = keys(g:vimwiki_global_vars.ext2syntax)[J

line 2:   for ext in keys[J

line 3:     " ensure the file extensions in ext2syntax start with a dot[J

line 4:     if ext[0] != '.'[J

line 5:       let new_ext = '.' . ext[J

line 6:       let g:vimwiki_global_vars.ext2syntax[new_ext] = g:vimwiki_global_vars.ext2syntax[ext][J

line 7:       call remove(g:vimwiki_global_vars.ext2syntax, ext)[J

line 8:     endif[J

line 9:     " for convenience, we also allow the term 'mediawiki'[J

line 10:     if g:vimwiki_global_vars.ext2syntax[ext] ==# 'mediawiki'[J

line 11:       let g:vimwiki_global_vars.ext2syntax[ext] = 'media'[J

line 12:     endif[J

line 13:   endfor[J

line 2:   for ext in keys[J

line 3:     " ensure the file extensions in ext2syntax start with a dot[J

line 4:     if ext[0] != '.'[J

line 5:       let new_ext = '.' . ext[J

line 6:       let g:vimwiki_global_vars.ext2syntax[new_ext] = g:vimwiki_global_vars.ext2syntax[ext][J

line 7:       call remove(g:vimwiki_global_vars.ext2syntax, ext)[J

line 8:     endif[J

line 9:     " for convenience, we also allow the term 'mediawiki'[J

line 10:     if g:vimwiki_global_vars.ext2syntax[ext] ==# 'mediawiki'[J

line 11:       let g:vimwiki_global_vars.ext2syntax[ext] = 'media'[J

line 12:     endif[J

line 13:   endfor[J

line 2:   for ext in keys[J

line 3:     " ensure the file extensions in ext2syntax start with a dot[J

line 4:     if ext[0] != '.'[J

line 5:       let new_ext = '.' . ext[J

line 6:       let g:vimwiki_global_vars.ext2syntax[new_ext] = g:vimwiki_global_vars.ext2syntax[ext][J

line 7:       call remove(g:vimwiki_global_vars.ext2syntax, ext)[J

line 8:     endif[J

line 9:     " for convenience, we also allow the term 'mediawiki'[J

line 10:     if g:vimwiki_global_vars.ext2syntax[ext] ==# 'mediawiki'[J

line 11:       let g:vimwiki_global_vars.ext2syntax[ext] = 'media'[J

line 12:     endif[J

line 13:   endfor[J

line 2:   for ext in keys[J

line 3:     " ensure the file extensions in ext2syntax start with a dot[J

line 4:     if ext[0] != '.'[J

line 5:       let new_ext = '.' . ext[J

line 6:       let g:vimwiki_global_vars.ext2syntax[new_ext] = g:vimwiki_global_vars.ext2syntax[ext][J

line 7:       call remove(g:vimwiki_global_vars.ext2syntax, ext)[J

line 8:     endif[J

line 9:     " for convenience, we also allow the term 'mediawiki'[J

line 10:     if g:vimwiki_global_vars.ext2syntax[ext] ==# 'mediawiki'[J

line 11:       let g:vimwiki_global_vars.ext2syntax[ext] = 'media'[J

line 12:     endif[J

line 13:   endfor[J

line 2:   for ext in keys[J

line 3:     " ensure the file extensions in ext2syntax start with a dot[J

line 4:     if ext[0] != '.'[J

line 5:       let new_ext = '.' . ext[J

line 6:       let g:vimwiki_global_vars.ext2syntax[new_ext] = g:vimwiki_global_vars.ext2syntax[ext][J

line 7:       call remove(g:vimwiki_global_vars.ext2syntax, ext)[J

line 8:     endif[J

line 9:     " for convenience, we also allow the term 'mediawiki'[J

line 10:     if g:vimwiki_global_vars.ext2syntax[ext] ==# 'mediawiki'[J

line 11:       let g:vimwiki_global_vars.ext2syntax[ext] = 'media'[J

line 12:     endif[J

line 13:   endfor[J

line 2:   for ext in keys[J

line 3:     " ensure the file extensions in ext2syntax start with a dot[J

line 4:     if ext[0] != '.'[J

line 5:       let new_ext = '.' . ext[J

line 6:       let g:vimwiki_global_vars.ext2syntax[new_ext] = g:vimwiki_global_vars.ext2syntax[ext][J

line 7:       call remove(g:vimwiki_global_vars.ext2syntax, ext)[J

line 8:     endif[J

line 9:     " for convenience, we also allow the term 'mediawiki'[J

line 10:     if g:vimwiki_global_vars.ext2syntax[ext] ==# 'mediawiki'[J

line 11:       let g:vimwiki_global_vars.ext2syntax[ext] = 'media'[J

line 12:     endif[J

line 13:   endfor[J

function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[5]..<SNR>21_normalize_global_settings returning #0[J

continuing in function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[J

line 6: [J

line 7:   " non-configurable global variables:[J

line 8: [J

line 9:   " Scheme regexes must be defined even if syntax file is not loaded yet cause users should be[J

line 10:   " able to <leader>w<leader>w without opening any vimwiki file first[J

line 11:   let g:vimwiki_global_vars.schemes = join(['wiki\d\+', 'diary', 'local'], '\|')[J

line 12:   let g:vimwiki_global_vars.web_schemes1 = join(['http', 'https', 'file', 'ftp', 'gopher', 'telnet', 'nntp', 'ldap', 'rsync', 'imap', 'pop', 'irc', 'ircs', 'cvs', 'svn', 'svn+ssh', 'git', 'ssh', 'fish', 'sftp'], '\|')[J

line 15:   let web_schemes2 = join(['mailto', 'news', 'xmpp', 'sip', 'sips', 'doi', 'urn', 'tel', 'data'], '\|')[J

line 17: [J

line 18:   let g:vimwiki_global_vars.rxSchemes = '\%('. g:vimwiki_global_vars.schemes . '\|'. g:vimwiki_global_vars.web_schemes1 . '\|'. web_schemes2 . '\)'[J

line 23: [J

line 24:   " match URL for common protocols; see http://en.wikipedia.org/wiki/URI_scheme[J

line 25:   " http://tools.ietf.org/html/rfc3986[J

line 26:   let rxWebProtocols = '\%('. '\%('. '\%('.g:vimwiki_global_vars.web_schemes1 . '\):'. '\%(//\)'. '\)'. '\|'. '\%('.web_schemes2.'\):'. '\)'[J

line 35: [J

line 36:   let g:vimwiki_global_vars.rxWeblinkUrl = rxWebProtocols . '\S\{-1,}'. '\%(([^ \t()]*)\)\='[J

line 37: [J

line 38:   let wikilink_prefix = '[['[J

line 39:   let wikilink_suffix = ']]'[J

line 40:   let wikilink_separator = '|'[J

line 41:   let g:vimwiki_global_vars.rx_wikilink_prefix = vimwiki#u#escape(wikilink_prefix)[J

Searching for "autoload/vimwiki/u.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/autoload/vimwiki/u.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/autoload/vimwiki/u.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/autoload/vimwiki/u.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/autoload/vimwiki/u.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/autoload/vimwiki/u.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/autoload/vimwiki/u.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/autoload/vimwiki/u.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/autoload/vimwiki/u.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vimwiki/autoload/vimwiki)[J
fchdir() to previous dir[J
line 41: sourcing "/Users/ygarrot/.vim/plugged/vimwiki/autoload/vimwiki/u.vim"[J
line 1: " vim:tabstop=2:shiftwidth=2:expandtab:textwidth=99[J

line 2: " Vimwiki autoload plugin file[J

line 3: " Description: Utility functions[J

line 4: " Home: https://github.com/vimwiki/vimwiki/[J

line 5: [J

line 6: function! vimwiki#u#trim(string, ...)[J

line 15: [J

line 16: [J

line 17: " Builtin cursor doesn't work right with unicode characters.[J

line 18: function! vimwiki#u#cursor(lnum, cnum)[J

line 22: [J

line 23: [J

line 24: function! vimwiki#u#is_windows()[J

line 27: [J

line 28: [J

line 29: function! vimwiki#u#is_macos()[J

line 37: [J

line 38: [J

line 39: function! vimwiki#u#count_first_sym(line)[J

line 43: [J

line 44: [J

line 45: function! vimwiki#u#escape(string)[J

line 48: [J

line 49: [J

line 50: " Load concrete Wiki syntax: sets regexes and templates for headers and links[J

line 51: function vimwiki#u#reload_regexes()[J

line 54: [J

line 55: [J

line 56: " Load syntax-specific functionality[J

line 57: function vimwiki#u#reload_regexes_custom()[J

line 60: [J

line 61: [J

line 62: " Backward compatible version of the built-in function shiftwidth()[J

line 63: if exists('*shiftwidth')[J

line 64:   func vimwiki#u#sw()[J

line 67: else[J

line 68:   func vimwiki#u#sw()[J

line 71: endif[J

line 72: [J

finished sourcing /Users/ygarrot/.vim/plugged/vimwiki/autoload/vimwiki/u.vim[J
continuing in function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[J
calling function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[41]..vimwiki#u#escape[J('[[')

line 1:   return escape(a:string, '~.*[]\^$')[J

function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[41]..vimwiki#u#escape returning '\[\['[J

continuing in function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[J

line 42:   let g:vimwiki_global_vars.rx_wikilink_suffix = vimwiki#u#escape(wikilink_suffix)[J

calling function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[42]..vimwiki#u#escape[J(']]')

line 1:   return escape(a:string, '~.*[]\^$')[J

function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[42]..vimwiki#u#escape returning '\]\]'[J

continuing in function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[J

line 43:   let g:vimwiki_global_vars.rx_wikilink_separator = vimwiki#u#escape(wikilink_separator)[J

calling function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[43]..vimwiki#u#escape[J('|')

line 1:   return escape(a:string, '~.*[]\^$')[J

function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[43]..vimwiki#u#escape returning '|'[J

continuing in function vimwiki#vars#init[1]..<SNR>21_populate_global_variables[J

line 44: [J

line 45:   " templates for the creation of wiki links[J

line 46:   " [[URL]][J

line 47:   let g:vimwiki_global_vars.WikiLinkTemplate1 = wikilink_prefix . '__LinkUrl__'. wikilink_suffix[J

line 48:   " [[URL|DESCRIPTION]][J

line 49:   let g:vimwiki_global_vars.WikiLinkTemplate2 = wikilink_prefix . '__LinkUrl__'. wikilink_separator . '__LinkDescription__' . wikilink_suffix[J

line 51: [J

line 52:   let valid_chars = '[^\\\]]'[J

line 53:   let g:vimwiki_global_vars.rxWikiLinkUrl = valid_chars.'\{-}'[J

line 54:   let g:vimwiki_global_vars.rxWikiLinkDescr = valid_chars.'\{-}'[J

line 55: [J

line 56:   " this regexp defines what can form a link when the user presses <CR> in the[J

line 57:   " buffer (and not on a link) to create a link[J

line 58:   " basically, it's Ascii alphanumeric characters plus #|./@-_~ plus all[J

line 59:   " non-Ascii characters, except that . is not accepted as the last character[J

line 60:   let g:vimwiki_global_vars.rxWord = '[^[:blank:]!"$%&''()*+,:;<=>?\[\]\\^`{}]*[^[:blank:]!"$%&''()*+.,:;<=>?\[\]\\^`{}]'[J

line 61: [J

line 62:   let g:vimwiki_global_vars.rx_wikilink_prefix1 = g:vimwiki_global_vars.rx_wikilink_prefix . g:vimwiki_global_vars.rxWikiLinkUrl . g:vimwiki_global_vars.rx_wikilink_separator[J

line 64:   let g:vimwiki_global_vars.rx_wikilink_suffix1 = g:vimwiki_global_vars.rx_wikilink_suffix[J

line 65: [J

line 66:   let g:vimwiki_global_vars.rxWikiInclPrefix = '{{'[J

line 67:   let g:vimwiki_global_vars.rxWikiInclSuffix = '}}'[J

line 68:   let g:vimwiki_global_vars.rxWikiInclSeparator = '|'[J

line 69:   " '{{__LinkUrl__}}'[J

line 70:   let g:vimwiki_global_vars.WikiInclTemplate1 = g:vimwiki_global_vars.rxWikiInclPrefix .'__LinkUrl__'. g:vimwiki_global_vars.rxWikiInclSuffix[J

line 72:   " '{{__LinkUrl____LinkDescription__}}'[J

line 73:   let g:vimwiki_global_vars.WikiInclTemplate2 = g:vimwiki_global_vars.rxWikiInclPrefix . '__LinkUrl__' . g:vimwiki_global_vars.rxWikiInclSeparator . '__LinkDescription__' . g:vimwiki_global_vars.rxWikiInclSuffix[J

line 76: [J

line 77:   let valid_chars = '[^\\\}]'[J

line 78:   let g:vimwiki_global_vars.rxWikiInclUrl = valid_chars.'\{-}'[J

line 79:   let g:vimwiki_global_vars.rxWikiInclArg = valid_chars.'\{-}'[J

line 80:   let g:vimwiki_global_vars.rxWikiInclArgs = '\%('. g:vimwiki_global_vars.rxWikiInclSeparator. g:vimwiki_global_vars.rxWikiInclArg. '\)'.'\{-}'[J

line 82: [J

line 83:   " *. {{URL}[{...}]}  - i.e.  {{URL}}, {{URL|ARG1}}, {{URL|ARG1|ARG2}}, etc.[J

line 84:   " *a) match {{URL}[{...}]}[J

line 85:   let g:vimwiki_global_vars.rxWikiIncl = g:vimwiki_global_vars.rxWikiInclPrefix. g:vimwiki_global_vars.rxWikiInclUrl. g:vimwiki_global_vars.rxWikiInclArgs. g:vimwiki_global_vars.rxWikiInclSuffix[J

line 88:   " *b) match URL within {{URL}[{...}]}[J

line 89:   let g:vimwiki_global_vars.rxWikiInclMatchUrl = g:vimwiki_global_vars.rxWikiInclPrefix. '\zs'. g:vimwiki_global_vars.rxWikiInclUrl . '\ze'. g:vimwiki_global_vars.rxWikiInclArgs . g:vimwiki_global_vars.rxWikiInclSuffix[J

line 92: [J

line 93:   let g:vimwiki_global_vars.rxWikiInclPrefix1 = g:vimwiki_global_vars.rxWikiInclPrefix. g:vimwiki_global_vars.rxWikiInclUrl . g:vimwiki_global_vars.rxWikiInclSeparator[J

line 95:   let g:vimwiki_global_vars.rxWikiInclSuffix1 = g:vimwiki_global_vars.rxWikiInclArgs. g:vimwiki_global_vars.rxWikiInclSuffix[J

line 97: [J

line 98:   let g:vimwiki_global_vars.rxTodo = '\C\<\%(TODO\|DONE\|STARTED\|FIXME\|FIXED\|XXX\)\>'[J

line 99: [J

line 100:   " default colors when headers of different levels are highlighted differently[J

line 101:   " not making it yet another option; needed by ColorScheme autocommand[J

line 102:   let g:vimwiki_global_vars.hcolor_guifg_light = ['#aa5858', '#507030', '#1030a0', '#103040' , '#505050', '#636363'][J

line 104:   let g:vimwiki_global_vars.hcolor_ctermfg_light = ['DarkRed', 'DarkGreen', 'DarkBlue', 'Black' , 'Black', 'Black'][J

line 106:   let g:vimwiki_global_vars.hcolor_guifg_dark = ['#e08090', '#80e090', '#6090e0', '#c0c0f0' , '#e0e0f0', '#f0f0f0'][J

line 108:   let g:vimwiki_global_vars.hcolor_ctermfg_dark = ['Red', 'Green', 'Blue', 'White', 'White' , 'White'][J

function vimwiki#vars#init[1]..<SNR>21_populate_global_variables returning #0[J

continuing in function vimwiki#vars#init[J

line 2:   call s:populate_wikilocal_options()[J

calling function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[J()

line 1:   let default_values = { 'auto_diary_index': {'type': type(0), 'default': 0, 'min': 0, 'max': 1}, 'auto_export': {'type': type(0), 'default': 0, 'min': 0, 'max': 1}, 'auto_tags': {'type': type(0), 'default': 0, 'min': 0, 'max': 1}, 'auto_toc': {'type': type(0), 'default': 0, 'min': 0, 'max': 1}, 'automatic_nested_syntaxes': {'type': type(0), 'default': 1, 'min': 0, 'max': 1}, 'css_name': {'type': type(''), 'default': 'style.css', 'min_length': 1}, 'custom_wiki2html': {'type': type(''), 'default': ''}, 'custom_wiki2html_args': {'type': type(''), 'default': ''}, 'diary_header': {'type': type(''), 'default': 'Diary', 'min_length': 1}, 'diary_index': {'type': type(''), 'default': 'diary', 'min_length': 1}, 'diary_rel_path': {'type': type(''), 'default': 'diary/', 'min_length': 1}, 'diary_sort': {'type': type(''), 'default': 'desc', 'possible_values': ['asc', 'desc']}, 'ext': {'type': type(''), 'default': '.wiki', 'min_length': 1}, 'index': {'type': type(''), 'default': 'index', 'min_length': 1}, 'list_mar[J

line 27: [J

line 28:   let g:vimwiki_wikilocal_vars = [][J

line 29: [J

line 30:   let default_wiki_settings = {}[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 31:   for key in keys(default_values)[J

line 32:     if exists('g:vimwiki_'.key)[J

line 33:       call s:check_users_value(key, g:vimwiki_{key}, default_values[key], 1)[J

line 34:       let default_wiki_settings[key] = g:vimwiki_{key}[J

line 35:     else[J

line 36:       let default_wiki_settings[key] = default_values[key].default[J

line 37:     endif[J

line 38:   endfor[J

line 39: [J

line 40:   " set the wiki-local variables according to g:vimwiki_list (or the default settings)[J

line 41:   if exists('g:vimwiki_list')[J

line 42:     for users_wiki_settings in g:vimwiki_list[J

line 43:       let new_wiki_settings = {}[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

calling function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[46]..<SNR>21_check_users_value[J('path', '~/vimwiki', {'min_length': 1, 'type': 1, 'default': '/Users/ygarrot/vimwiki/'}, 0)

line 1:   let type_code_to_name = { type(0): 'number', type(''): 'string', type([]): 'list', type({}): 'dictionary'}[J

line 6: [J

line 7:   let setting_origin = a:comes_from_global_variable ? printf('''g:vimwiki_%s''', a:key) : printf('''%s'' in g:vimwiki_list', a:key)[J

line 10: [J

line 11:   if has_key(a:value_infos, 'type') && type(a:users_value) != a:value_infos.type[J

line 12:     echom printf('Vimwiki Error: The provided value of the option %s is a %s, ' . 'but expected is a %s. See '':h g:vimwiki_%s''.', setting_origin, type_code_to_name[type(a:users_value)], type_code_to_name[a:value_infos.type], a:key)[J

line 15:   endif[J

line 16: [J

line 17:   if a:value_infos.type == type(0) && has_key(a:value_infos, 'min') && a:users_value < a:value_infos.min[J

line 19:     echom printf('Vimwiki Error: The provided value ''%i'' of the option %s is' . ' too small. The minimum value is %i. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.min, a:key)[J

line 22:   endif[J

line 23: [J

line 24:   if a:value_infos.type == type(0) && has_key(a:value_infos, 'max') && a:users_value > a:value_infos.max[J

line 26:     echom printf('Vimwiki Error: The provided value ''%i'' of the option %s is' . ' too large. The maximum value is %i. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.max, a:key)[J

line 29:   endif[J

line 30: [J

line 31:   if has_key(a:value_infos, 'possible_values') && index(a:value_infos.possible_values, a:users_value) == -1[J

line 33:     echom printf('Vimwiki Error: The provided value ''%s'' of the option %s is' . ' invalid. Allowed values are %s. See ''g:vimwiki_%s''.', a:users_value, setting_origin, string(a:value_infos.possible_values), a:key)[J

line 36:   endif[J

line 37: [J

line 38:   if a:value_infos.type == type('') && has_key(a:value_infos, 'length') && strwidth(a:users_value) != a:value_infos.length[J

line 40:     echom printf('Vimwiki Error: The provided value ''%s'' of the option %s must' . ' contain exactly %i character(s) but has %i. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.length, strwidth(a:users_value), a:key)[J

line 43:   endif[J

line 44: [J

line 45:   if a:value_infos.type == type('') && has_key(a:value_infos, 'min_length') && strwidth(a:users_value) < a:value_infos.min_length[J

line 47:     echom printf('Vimwiki Error: The provided value ''%s'' of the option %s must' . ' have at least %d character(s) but has %d. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.min_length, strwidth(a:users_value), a:key)[J

line 50:   endif[J

function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[46]..<SNR>21_check_users_value returning #0[J

continuing in function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

calling function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[46]..<SNR>21_check_users_value[J('syntax', 'markdown', {'possible_values': ['default', 'mark...wiki'], 'type': 1, 'default': 'default'}, 0)

line 1:   let type_code_to_name = { type(0): 'number', type(''): 'string', type([]): 'list', type({}): 'dictionary'}[J

line 6: [J

line 7:   let setting_origin = a:comes_from_global_variable ? printf('''g:vimwiki_%s''', a:key) : printf('''%s'' in g:vimwiki_list', a:key)[J

line 10: [J

line 11:   if has_key(a:value_infos, 'type') && type(a:users_value) != a:value_infos.type[J

line 12:     echom printf('Vimwiki Error: The provided value of the option %s is a %s, ' . 'but expected is a %s. See '':h g:vimwiki_%s''.', setting_origin, type_code_to_name[type(a:users_value)], type_code_to_name[a:value_infos.type], a:key)[J

line 15:   endif[J

line 16: [J

line 17:   if a:value_infos.type == type(0) && has_key(a:value_infos, 'min') && a:users_value < a:value_infos.min[J

line 19:     echom printf('Vimwiki Error: The provided value ''%i'' of the option %s is' . ' too small. The minimum value is %i. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.min, a:key)[J

line 22:   endif[J

line 23: [J

line 24:   if a:value_infos.type == type(0) && has_key(a:value_infos, 'max') && a:users_value > a:value_infos.max[J

line 26:     echom printf('Vimwiki Error: The provided value ''%i'' of the option %s is' . ' too large. The maximum value is %i. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.max, a:key)[J

line 29:   endif[J

line 30: [J

line 31:   if has_key(a:value_infos, 'possible_values') && index(a:value_infos.possible_values, a:users_value) == -1[J

line 33:     echom printf('Vimwiki Error: The provided value ''%s'' of the option %s is' . ' invalid. Allowed values are %s. See ''g:vimwiki_%s''.', a:users_value, setting_origin, string(a:value_infos.possible_values), a:key)[J

line 36:   endif[J

line 37: [J

line 38:   if a:value_infos.type == type('') && has_key(a:value_infos, 'length') && strwidth(a:users_value) != a:value_infos.length[J

line 40:     echom printf('Vimwiki Error: The provided value ''%s'' of the option %s must' . ' contain exactly %i character(s) but has %i. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.length, strwidth(a:users_value), a:key)[J

line 43:   endif[J

line 44: [J

line 45:   if a:value_infos.type == type('') && has_key(a:value_infos, 'min_length') && strwidth(a:users_value) < a:value_infos.min_length[J

line 47:     echom printf('Vimwiki Error: The provided value ''%s'' of the option %s must' . ' have at least %d character(s) but has %d. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.min_length, strwidth(a:users_value), a:key)[J

line 50:   endif[J

function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[46]..<SNR>21_check_users_value returning #0[J

continuing in function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

calling function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[46]..<SNR>21_check_users_value[J('ext', '.md', {'min_length': 1, 'type': 1, 'default': '.wiki'}, 0)

line 1:   let type_code_to_name = { type(0): 'number', type(''): 'string', type([]): 'list', type({}): 'dictionary'}[J

line 6: [J

line 7:   let setting_origin = a:comes_from_global_variable ? printf('''g:vimwiki_%s''', a:key) : printf('''%s'' in g:vimwiki_list', a:key)[J

line 10: [J

line 11:   if has_key(a:value_infos, 'type') && type(a:users_value) != a:value_infos.type[J

line 12:     echom printf('Vimwiki Error: The provided value of the option %s is a %s, ' . 'but expected is a %s. See '':h g:vimwiki_%s''.', setting_origin, type_code_to_name[type(a:users_value)], type_code_to_name[a:value_infos.type], a:key)[J

line 15:   endif[J

line 16: [J

line 17:   if a:value_infos.type == type(0) && has_key(a:value_infos, 'min') && a:users_value < a:value_infos.min[J

line 19:     echom printf('Vimwiki Error: The provided value ''%i'' of the option %s is' . ' too small. The minimum value is %i. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.min, a:key)[J

line 22:   endif[J

line 23: [J

line 24:   if a:value_infos.type == type(0) && has_key(a:value_infos, 'max') && a:users_value > a:value_infos.max[J

line 26:     echom printf('Vimwiki Error: The provided value ''%i'' of the option %s is' . ' too large. The maximum value is %i. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.max, a:key)[J

line 29:   endif[J

line 30: [J

line 31:   if has_key(a:value_infos, 'possible_values') && index(a:value_infos.possible_values, a:users_value) == -1[J

line 33:     echom printf('Vimwiki Error: The provided value ''%s'' of the option %s is' . ' invalid. Allowed values are %s. See ''g:vimwiki_%s''.', a:users_value, setting_origin, string(a:value_infos.possible_values), a:key)[J

line 36:   endif[J

line 37: [J

line 38:   if a:value_infos.type == type('') && has_key(a:value_infos, 'length') && strwidth(a:users_value) != a:value_infos.length[J

line 40:     echom printf('Vimwiki Error: The provided value ''%s'' of the option %s must' . ' contain exactly %i character(s) but has %i. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.length, strwidth(a:users_value), a:key)[J

line 43:   endif[J

line 44: [J

line 45:   if a:value_infos.type == type('') && has_key(a:value_infos, 'min_length') && strwidth(a:users_value) < a:value_infos.min_length[J

line 47:     echom printf('Vimwiki Error: The provided value ''%s'' of the option %s must' . ' have at least %d character(s) but has %d. See '':h g:vimwiki_%s''.', a:users_value, setting_origin, a:value_infos.min_length, strwidth(a:users_value), a:key)[J

line 50:   endif[J

function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[46]..<SNR>21_check_users_value returning #0[J

continuing in function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 52: [J

line 53:       let new_wiki_settings.is_temporary_wiki = 0[J

line 54: [J

line 55:       call add(g:vimwiki_wikilocal_vars, new_wiki_settings)[J

line 56:     endfor[J

line 42:     for users_wiki_settings in g:vimwiki_list[J

line 43:       let new_wiki_settings = {}[J

line 44:       for key in keys(default_values)[J

line 45:         if has_key(users_wiki_settings, key)[J

line 46:           call s:check_users_value(key, users_wiki_settings[key], default_values[key], 0)[J

line 47:           let new_wiki_settings[key] = users_wiki_settings[key][J

line 48:         else[J

line 49:           let new_wiki_settings[key] = default_wiki_settings[key][J

line 50:         endif[J

line 51:       endfor[J

line 52: [J

line 53:       let new_wiki_settings.is_temporary_wiki = 0[J

line 54: [J

line 55:       call add(g:vimwiki_wikilocal_vars, new_wiki_settings)[J

line 56:     endfor[J

line 57:   else[J

line 58:     " if the user hasn't registered any wiki, we register one wiki using the default values[J

line 59:     let new_wiki_settings = deepcopy(default_wiki_settings)[J

line 60:     let new_wiki_settings.is_temporary_wiki = 0[J

line 61:     call add(g:vimwiki_wikilocal_vars, new_wiki_settings)[J

line 62:   endif[J

line 63: [J

line 64:   " default values for temporary wikis[J

line 65:   let temporary_wiki_settings = deepcopy(default_wiki_settings)[J

line 66:   let temporary_wiki_settings.is_temporary_wiki = 1[J

line 67:   call add(g:vimwiki_wikilocal_vars, temporary_wiki_settings)[J

line 68: [J

line 69:   " check some values individually[J

line 70:   let key = 'nested_syntaxes'[J

line 71:   for wiki_settings in g:vimwiki_wikilocal_vars[J

line 72:     let users_value = wiki_settings[key][J

line 73:     for keyword in keys(users_value)[J

line 74:       if type(keyword) != type('') || empty(keyword) || type(users_value[keyword]) != type('') || empty(users_value[keyword])[J

line 76:         echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 78:         break[J

line 79:       endif[J

line 80:     endfor[J

line 81:   endfor[J

line 71:   for wiki_settings in g:vimwiki_wikilocal_vars[J

line 72:     let users_value = wiki_settings[key][J

line 73:     for keyword in keys(users_value)[J

line 74:       if type(keyword) != type('') || empty(keyword) || type(users_value[keyword]) != type('') || empty(users_value[keyword])[J

line 76:         echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 78:         break[J

line 79:       endif[J

line 80:     endfor[J

line 81:   endfor[J

line 71:   for wiki_settings in g:vimwiki_wikilocal_vars[J

line 72:     let users_value = wiki_settings[key][J

line 73:     for keyword in keys(users_value)[J

line 74:       if type(keyword) != type('') || empty(keyword) || type(users_value[keyword]) != type('') || empty(users_value[keyword])[J

line 76:         echom printf('Vimwiki Error: The provided value ''%s'' of the option ''g:vimwiki_%s'' is' . ' invalid. See '':h g:vimwiki_%s''.', string(users_value), key, key)[J

line 78:         break[J

line 79:       endif[J

line 80:     endfor[J

line 81:   endfor[J

line 82: [J

line 83:   call s:normalize_wikilocal_settings()[J

calling function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[J()

line 1:   for wiki_settings in g:vimwiki_wikilocal_vars[J

line 2:     let wiki_settings['path'] = s:normalize_path(wiki_settings['path'])[J

calling function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[2]..<SNR>21_normalize_path[J('~/vimwiki')

line 1:   " trim trailing / and \ because otherwise resolve() doesn't work quite right[J

line 2:   let path = substitute(a:path, '[/\\]\+$', '', '')[J

line 3:   if path !~# '^scp:'[J

line 4:     return resolve(expand(path)).'/'[J

function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[2]..<SNR>21_normalize_path returning '/Users/ygarrot/vimwiki/'[J

continuing in function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[J

line 3: [J

line 4:     let path_html = wiki_settings['path_html'][J

line 5:     if !empty(path_html)[J

line 6:       let wiki_settings['path_html'] = s:normalize_path(path_html)[J

line 7:     else[J

line 8:       let wiki_settings['path_html'] = s:normalize_path( substitute(wiki_settings['path'], '[/\\]\+$', '', '').'_html/')[J

calling function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[8]..<SNR>21_normalize_path[J('/Users/ygarrot/vimwiki_html/')

line 1:   " trim trailing / and \ because otherwise resolve() doesn't work quite right[J

line 2:   let path = substitute(a:path, '[/\\]\+$', '', '')[J

line 3:   if path !~# '^scp:'[J

line 4:     return resolve(expand(path)).'/'[J

function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[8]..<SNR>21_normalize_path returning '/Users/ygarrot/vimwiki_html/'[J

continuing in function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[J

line 10:     endif[J

line 11: [J

line 12:     let wiki_settings['template_path'] = s:normalize_path(wiki_settings['template_path'])[J

calling function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[12]..<SNR>21_normalize_path[J('/Users/ygarrot/vimwiki/templates/')

line 1:   " trim trailing / and \ because otherwise resolve() doesn't work quite right[J

line 2:   let path = substitute(a:path, '[/\\]\+$', '', '')[J

line 3:   if path !~# '^scp:'[J

line 4:     return resolve(expand(path)).'/'[J

function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[12]..<SNR>21_normalize_path returning '/Users/ygarrot/vimwiki/templates/'[J

continuing in function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[J

line 13:     let wiki_settings['diary_rel_path'] = s:normalize_path(wiki_settings['diary_rel_path'])[J

calling function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[13]..<SNR>21_normalize_path[J('diary/')

line 1:   " trim trailing / and \ because otherwise resolve() doesn't work quite right[J

line 2:   let path = substitute(a:path, '[/\\]\+$', '', '')[J

line 3:   if path !~# '^scp:'[J

line 4:     return resolve(expand(path)).'/'[J

function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[13]..<SNR>21_normalize_path returning 'diary/'[J

continuing in function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[J

line 14: [J

line 15:     let ext = wiki_settings['ext'][J

line 16:     if !empty(ext) && ext[0] != '.'[J

line 17:       let wiki_settings['ext'] = '.' . ext[J

line 18:     endif[J

line 19: [J

line 20:     " for convenience, we also allow the term 'mediawiki'[J

line 21:     if wiki_settings.syntax ==# 'mediawiki'[J

line 22:       let wiki_settings.syntax = 'media'[J

line 23:     endif[J

line 24:   endfor[J

line 1:   for wiki_settings in g:vimwiki_wikilocal_vars[J

line 2:     let wiki_settings['path'] = s:normalize_path(wiki_settings['path'])[J

calling function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[2]..<SNR>21_normalize_path[J('/Users/ygarrot/vimwiki/')

line 1:   " trim trailing / and \ because otherwise resolve() doesn't work quite right[J

line 2:   let path = substitute(a:path, '[/\\]\+$', '', '')[J

line 3:   if path !~# '^scp:'[J

line 4:     return resolve(expand(path)).'/'[J

function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[2]..<SNR>21_normalize_path returning '/Users/ygarrot/vimwiki/'[J

continuing in function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[J

line 3: [J

line 4:     let path_html = wiki_settings['path_html'][J

line 5:     if !empty(path_html)[J

line 6:       let wiki_settings['path_html'] = s:normalize_path(path_html)[J

line 7:     else[J

line 8:       let wiki_settings['path_html'] = s:normalize_path( substitute(wiki_settings['path'], '[/\\]\+$', '', '').'_html/')[J

calling function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[8]..<SNR>21_normalize_path[J('/Users/ygarrot/vimwiki_html/')

line 1:   " trim trailing / and \ because otherwise resolve() doesn't work quite right[J

line 2:   let path = substitute(a:path, '[/\\]\+$', '', '')[J

line 3:   if path !~# '^scp:'[J

line 4:     return resolve(expand(path)).'/'[J

function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[8]..<SNR>21_normalize_path returning '/Users/ygarrot/vimwiki_html/'[J

continuing in function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[J

line 10:     endif[J

line 11: [J

line 12:     let wiki_settings['template_path'] = s:normalize_path(wiki_settings['template_path'])[J

calling function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[12]..<SNR>21_normalize_path[J('/Users/ygarrot/vimwiki/templates/')

line 1:   " trim trailing / and \ because otherwise resolve() doesn't work quite right[J

line 2:   let path = substitute(a:path, '[/\\]\+$', '', '')[J

line 3:   if path !~# '^scp:'[J

line 4:     return resolve(expand(path)).'/'[J

function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[12]..<SNR>21_normalize_path returning '/Users/ygarrot/vimwiki/templates/'[J

continuing in function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[J

line 13:     let wiki_settings['diary_rel_path'] = s:normalize_path(wiki_settings['diary_rel_path'])[J

calling function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[13]..<SNR>21_normalize_path[J('diary/')

line 1:   " trim trailing / and \ because otherwise resolve() doesn't work quite right[J

line 2:   let path = substitute(a:path, '[/\\]\+$', '', '')[J

line 3:   if path !~# '^scp:'[J

line 4:     return resolve(expand(path)).'/'[J

function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[13]..<SNR>21_normalize_path returning 'diary/'[J

continuing in function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings[J

line 14: [J

line 15:     let ext = wiki_settings['ext'][J

line 16:     if !empty(ext) && ext[0] != '.'[J

line 17:       let wiki_settings['ext'] = '.' . ext[J

line 18:     endif[J

line 19: [J

line 20:     " for convenience, we also allow the term 'mediawiki'[J

line 21:     if wiki_settings.syntax ==# 'mediawiki'[J

line 22:       let wiki_settings.syntax = 'media'[J

line 23:     endif[J

line 24:   endfor[J

line 1:   for wiki_settings in g:vimwiki_wikilocal_vars[J

line 2:     let wiki_settings['path'] = s:normalize_path(wiki_settings['path'])[J

line 3: [J

line 4:     let path_html = wiki_settings['path_html'][J

line 5:     if !empty(path_html)[J

line 6:       let wiki_settings['path_html'] = s:normalize_path(path_html)[J

line 7:     else[J

line 8:       let wiki_settings['path_html'] = s:normalize_path( substitute(wiki_settings['path'], '[/\\]\+$', '', '').'_html/')[J

line 10:     endif[J

line 11: [J

line 12:     let wiki_settings['template_path'] = s:normalize_path(wiki_settings['template_path'])[J

line 13:     let wiki_settings['diary_rel_path'] = s:normalize_path(wiki_settings['diary_rel_path'])[J

line 14: [J

line 15:     let ext = wiki_settings['ext'][J

line 16:     if !empty(ext) && ext[0] != '.'[J

line 17:       let wiki_settings['ext'] = '.' . ext[J

line 18:     endif[J

line 19: [J

line 20:     " for convenience, we also allow the term 'mediawiki'[J

line 21:     if wiki_settings.syntax ==# 'mediawiki'[J

line 22:       let wiki_settings.syntax = 'media'[J

line 23:     endif[J

line 24:   endfor[J

function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[83]..<SNR>21_normalize_wikilocal_settings returning #0[J

continuing in function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options[J

function vimwiki#vars#init[2]..<SNR>21_populate_wikilocal_options returning #0[J

continuing in function vimwiki#vars#init[J

function vimwiki#vars#init returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 219: [J

line 220: [J

line 221: " Define callback functions which the user can redefine[J

line 222: if !exists("*VimwikiLinkHandler")[J

line 223:   function VimwikiLinkHandler(url)[J

line 226: endif[J

line 227: [J

line 228: if !exists("*VimwikiLinkConverter")[J

line 229:   function VimwikiLinkConverter(url, source, target)[J

line 233: endif[J

line 234: [J

line 235: if !exists("*VimwikiWikiIncludeHandler")[J

line 236:   function! VimwikiWikiIncludeHandler(value)[J

line 239: endif[J

line 240: [J

line 241: [J

line 242: [J

line 243: " Define autocommands for all known wiki extensions[J

line 244: [J

line 245: let s:known_extensions = s:vimwiki_get_known_extensions()[J

calling function <SNR>20_vimwiki_get_known_extensions[J()

line 1:   " Getting all extensions that different wikis could have[J

line 2:   let extensions = {}[J

line 3:   for idx in range(vimwiki#vars#number_of_wikis())[J

calling function <SNR>20_vimwiki_get_known_extensions[3]..vimwiki#vars#number_of_wikis[J()

line 1:   return len(g:vimwiki_wikilocal_vars) - 1[J

function <SNR>20_vimwiki_get_known_extensions[3]..vimwiki#vars#number_of_wikis returning #1[J

continuing in function <SNR>20_vimwiki_get_known_extensions[J

line 4:     let ext = vimwiki#vars#get_wikilocal('ext', idx)[J

calling function <SNR>20_vimwiki_get_known_extensions[4]..vimwiki#vars#get_wikilocal[J('ext', 0)

line 1:   if a:0[J

line 2:     return g:vimwiki_wikilocal_vars[a:1][a:key][J

function <SNR>20_vimwiki_get_known_extensions[4]..vimwiki#vars#get_wikilocal returning '.md'[J

continuing in function <SNR>20_vimwiki_get_known_extensions[J

line 5:     let extensions[ext] = 1[J

line 6:   endfor[J

line 3:   for idx in range(vimwiki#vars#number_of_wikis())[J

line 4:     let ext = vimwiki#vars#get_wikilocal('ext', idx)[J

line 5:     let extensions[ext] = 1[J

line 6:   endfor[J

line 7:   " append extensions from g:vimwiki_ext2syntax[J

line 8:   for ext in keys(vimwiki#vars#get_global('ext2syntax'))[J

calling function <SNR>20_vimwiki_get_known_extensions[8]..vimwiki#vars#get_global[J('ext2syntax')

line 1:   return g:vimwiki_global_vars[a:key][J

function <SNR>20_vimwiki_get_known_extensions[8]..vimwiki#vars#get_global returning {'.markdown': 'markdown', '.md': 'mar... '.Rmd': 'markdown', '.rmd': 'markdown'}[J

continuing in function <SNR>20_vimwiki_get_known_extensions[J

line 9:     let extensions[ext] = 1[J

line 10:   endfor[J

line 8:   for ext in keys(vimwiki#vars#get_global('ext2syntax'))[J

line 9:     let extensions[ext] = 1[J

line 10:   endfor[J

line 8:   for ext in keys(vimwiki#vars#get_global('ext2syntax'))[J

line 9:     let extensions[ext] = 1[J

line 10:   endfor[J

line 8:   for ext in keys(vimwiki#vars#get_global('ext2syntax'))[J

line 9:     let extensions[ext] = 1[J

line 10:   endfor[J

line 8:   for ext in keys(vimwiki#vars#get_global('ext2syntax'))[J

line 9:     let extensions[ext] = 1[J

line 10:   endfor[J

line 8:   for ext in keys(vimwiki#vars#get_global('ext2syntax'))[J

line 9:     let extensions[ext] = 1[J

line 10:   endfor[J

line 11:   return keys(extensions)[J

function <SNR>20_vimwiki_get_known_extensions returning ['.markdown', '.md', '.rmd', '.Rmd', '.mdown'][J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 246: [J

line 247: if index(s:known_extensions, '.wiki') > -1[J

line 248:   augroup filetypedetect[J

line 249:     " clear FlexWiki's stuff[J

line 250:     au! * *.wiki[J

line 251:   augroup end[J

line 252: endif[J

line 253: [J

line 254: augroup vimwiki[J

line 255:   autocmd![J

line 256:   autocmd ColorScheme * call s:setup_cleared_syntax()[J

line 257:   for s:ext in s:known_extensions[J

line 258:     exe 'autocmd BufNewFile,BufRead *'.s:ext.' call s:setup_new_wiki_buffer()'[J

line 258: autocmd BufNewFile,BufRead *.markdown call s:setup_new_wiki_buffer()[J

line 259:     exe 'autocmd BufEnter *'.s:ext.' call s:setup_buffer_enter()'[J

line 259: autocmd BufEnter *.markdown call s:setup_buffer_enter()[J

line 260:     exe 'autocmd BufLeave *'.s:ext.' call s:setup_buffer_leave()'[J

line 260: autocmd BufLeave *.markdown call s:setup_buffer_leave()[J

line 261:     " Format tables when exit from insert mode. Do not use textwidth to[J

line 262:     " autowrap tables.[J

line 263:     if vimwiki#vars#get_global('table_auto_fmt')[J

calling function vimwiki#vars#get_global[J('table_auto_fmt')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning #1[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 264:       exe 'autocmd InsertLeave *'.s:ext.' call vimwiki#tbl#format(line("."))'[J

line 264: autocmd InsertLeave *.markdown call vimwiki#tbl#format(line("."))[J

line 265:       exe 'autocmd InsertEnter *'.s:ext.' call vimwiki#tbl#reset_tw(line("."))'[J

line 265: autocmd InsertEnter *.markdown call vimwiki#tbl#reset_tw(line("."))[J

line 266:     endif[J

line 267:     if vimwiki#vars#get_global('folding') =~? ':quick$'[J

calling function vimwiki#vars#get_global[J('folding')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning ''[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 268:       " from http://vim.wikia.com/wiki/Keep_folds_closed_while_inserting_text[J

line 269:       " Don't screw up folds when inserting text that might affect them, until[J

line 270:       " leaving insert mode. Foldmethod is local to the window. Protect against[J

line 271:       " screwing up folding when switching between windows.[J

line 273:       exe 'autocmd InsertEnter *'.s:ext.' if !exists("w:last_fdm") | let w:last_fdm=&foldmethod'. ' | setlocal foldmethod=manual | endif'[J

line 275:       exe 'autocmd InsertLeave,WinLeave *'.s:ext.' if exists("w:last_fdm") |'. 'let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif'[J

line 276:     endif[J

line 277:   endfor[J

line 257:   for s:ext in s:known_extensions[J

line 258:     exe 'autocmd BufNewFile,BufRead *'.s:ext.' call s:setup_new_wiki_buffer()'[J

line 258: autocmd BufNewFile,BufRead *.md call s:setup_new_wiki_buffer()[J

line 259:     exe 'autocmd BufEnter *'.s:ext.' call s:setup_buffer_enter()'[J

line 259: autocmd BufEnter *.md call s:setup_buffer_enter()[J

line 260:     exe 'autocmd BufLeave *'.s:ext.' call s:setup_buffer_leave()'[J

line 260: autocmd BufLeave *.md call s:setup_buffer_leave()[J

line 261:     " Format tables when exit from insert mode. Do not use textwidth to[J

line 262:     " autowrap tables.[J

line 263:     if vimwiki#vars#get_global('table_auto_fmt')[J

calling function vimwiki#vars#get_global[J('table_auto_fmt')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning #1[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 264:       exe 'autocmd InsertLeave *'.s:ext.' call vimwiki#tbl#format(line("."))'[J

line 264: autocmd InsertLeave *.md call vimwiki#tbl#format(line("."))[J

line 265:       exe 'autocmd InsertEnter *'.s:ext.' call vimwiki#tbl#reset_tw(line("."))'[J

line 265: autocmd InsertEnter *.md call vimwiki#tbl#reset_tw(line("."))[J

line 266:     endif[J

line 267:     if vimwiki#vars#get_global('folding') =~? ':quick$'[J

calling function vimwiki#vars#get_global[J('folding')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning ''[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 268:       " from http://vim.wikia.com/wiki/Keep_folds_closed_while_inserting_text[J

line 269:       " Don't screw up folds when inserting text that might affect them, until[J

line 270:       " leaving insert mode. Foldmethod is local to the window. Protect against[J

line 271:       " screwing up folding when switching between windows.[J

line 273:       exe 'autocmd InsertEnter *'.s:ext.' if !exists("w:last_fdm") | let w:last_fdm=&foldmethod'. ' | setlocal foldmethod=manual | endif'[J

line 275:       exe 'autocmd InsertLeave,WinLeave *'.s:ext.' if exists("w:last_fdm") |'. 'let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif'[J

line 276:     endif[J

line 277:   endfor[J

line 257:   for s:ext in s:known_extensions[J

line 258:     exe 'autocmd BufNewFile,BufRead *'.s:ext.' call s:setup_new_wiki_buffer()'[J

line 258: autocmd BufNewFile,BufRead *.rmd call s:setup_new_wiki_buffer()[J

line 259:     exe 'autocmd BufEnter *'.s:ext.' call s:setup_buffer_enter()'[J

line 259: autocmd BufEnter *.rmd call s:setup_buffer_enter()[J

line 260:     exe 'autocmd BufLeave *'.s:ext.' call s:setup_buffer_leave()'[J

line 260: autocmd BufLeave *.rmd call s:setup_buffer_leave()[J

line 261:     " Format tables when exit from insert mode. Do not use textwidth to[J

line 262:     " autowrap tables.[J

line 263:     if vimwiki#vars#get_global('table_auto_fmt')[J

calling function vimwiki#vars#get_global[J('table_auto_fmt')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning #1[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 264:       exe 'autocmd InsertLeave *'.s:ext.' call vimwiki#tbl#format(line("."))'[J

line 264: autocmd InsertLeave *.rmd call vimwiki#tbl#format(line("."))[J

line 265:       exe 'autocmd InsertEnter *'.s:ext.' call vimwiki#tbl#reset_tw(line("."))'[J

line 265: autocmd InsertEnter *.rmd call vimwiki#tbl#reset_tw(line("."))[J

line 266:     endif[J

line 267:     if vimwiki#vars#get_global('folding') =~? ':quick$'[J

calling function vimwiki#vars#get_global[J('folding')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning ''[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 268:       " from http://vim.wikia.com/wiki/Keep_folds_closed_while_inserting_text[J

line 269:       " Don't screw up folds when inserting text that might affect them, until[J

line 270:       " leaving insert mode. Foldmethod is local to the window. Protect against[J

line 271:       " screwing up folding when switching between windows.[J

line 273:       exe 'autocmd InsertEnter *'.s:ext.' if !exists("w:last_fdm") | let w:last_fdm=&foldmethod'. ' | setlocal foldmethod=manual | endif'[J

line 275:       exe 'autocmd InsertLeave,WinLeave *'.s:ext.' if exists("w:last_fdm") |'. 'let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif'[J

line 276:     endif[J

line 277:   endfor[J

line 257:   for s:ext in s:known_extensions[J

line 258:     exe 'autocmd BufNewFile,BufRead *'.s:ext.' call s:setup_new_wiki_buffer()'[J

line 258: autocmd BufNewFile,BufRead *.Rmd call s:setup_new_wiki_buffer()[J

line 259:     exe 'autocmd BufEnter *'.s:ext.' call s:setup_buffer_enter()'[J

line 259: autocmd BufEnter *.Rmd call s:setup_buffer_enter()[J

line 260:     exe 'autocmd BufLeave *'.s:ext.' call s:setup_buffer_leave()'[J

line 260: autocmd BufLeave *.Rmd call s:setup_buffer_leave()[J

line 261:     " Format tables when exit from insert mode. Do not use textwidth to[J

line 262:     " autowrap tables.[J

line 263:     if vimwiki#vars#get_global('table_auto_fmt')[J

calling function vimwiki#vars#get_global[J('table_auto_fmt')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning #1[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 264:       exe 'autocmd InsertLeave *'.s:ext.' call vimwiki#tbl#format(line("."))'[J

line 264: autocmd InsertLeave *.Rmd call vimwiki#tbl#format(line("."))[J

line 265:       exe 'autocmd InsertEnter *'.s:ext.' call vimwiki#tbl#reset_tw(line("."))'[J

line 265: autocmd InsertEnter *.Rmd call vimwiki#tbl#reset_tw(line("."))[J

line 266:     endif[J

line 267:     if vimwiki#vars#get_global('folding') =~? ':quick$'[J

calling function vimwiki#vars#get_global[J('folding')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning ''[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 268:       " from http://vim.wikia.com/wiki/Keep_folds_closed_while_inserting_text[J

line 269:       " Don't screw up folds when inserting text that might affect them, until[J

line 270:       " leaving insert mode. Foldmethod is local to the window. Protect against[J

line 271:       " screwing up folding when switching between windows.[J

line 273:       exe 'autocmd InsertEnter *'.s:ext.' if !exists("w:last_fdm") | let w:last_fdm=&foldmethod'. ' | setlocal foldmethod=manual | endif'[J

line 275:       exe 'autocmd InsertLeave,WinLeave *'.s:ext.' if exists("w:last_fdm") |'. 'let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif'[J

line 276:     endif[J

line 277:   endfor[J

line 257:   for s:ext in s:known_extensions[J

line 258:     exe 'autocmd BufNewFile,BufRead *'.s:ext.' call s:setup_new_wiki_buffer()'[J

line 258: autocmd BufNewFile,BufRead *.mdown call s:setup_new_wiki_buffer()[J

line 259:     exe 'autocmd BufEnter *'.s:ext.' call s:setup_buffer_enter()'[J

line 259: autocmd BufEnter *.mdown call s:setup_buffer_enter()[J

line 260:     exe 'autocmd BufLeave *'.s:ext.' call s:setup_buffer_leave()'[J

line 260: autocmd BufLeave *.mdown call s:setup_buffer_leave()[J

line 261:     " Format tables when exit from insert mode. Do not use textwidth to[J

line 262:     " autowrap tables.[J

line 263:     if vimwiki#vars#get_global('table_auto_fmt')[J

calling function vimwiki#vars#get_global[J('table_auto_fmt')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning #1[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 264:       exe 'autocmd InsertLeave *'.s:ext.' call vimwiki#tbl#format(line("."))'[J

line 264: autocmd InsertLeave *.mdown call vimwiki#tbl#format(line("."))[J

line 265:       exe 'autocmd InsertEnter *'.s:ext.' call vimwiki#tbl#reset_tw(line("."))'[J

line 265: autocmd InsertEnter *.mdown call vimwiki#tbl#reset_tw(line("."))[J

line 266:     endif[J

line 267:     if vimwiki#vars#get_global('folding') =~? ':quick$'[J

calling function vimwiki#vars#get_global[J('folding')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning ''[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 268:       " from http://vim.wikia.com/wiki/Keep_folds_closed_while_inserting_text[J

line 269:       " Don't screw up folds when inserting text that might affect them, until[J

line 270:       " leaving insert mode. Foldmethod is local to the window. Protect against[J

line 271:       " screwing up folding when switching between windows.[J

line 273:       exe 'autocmd InsertEnter *'.s:ext.' if !exists("w:last_fdm") | let w:last_fdm=&foldmethod'. ' | setlocal foldmethod=manual | endif'[J

line 275:       exe 'autocmd InsertLeave,WinLeave *'.s:ext.' if exists("w:last_fdm") |'. 'let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif'[J

line 276:     endif[J

line 277:   endfor[J

line 257:   for s:ext in s:known_extensions[J

line 258:     exe 'autocmd BufNewFile,BufRead *'.s:ext.' call s:setup_new_wiki_buffer()'[J

line 259:     exe 'autocmd BufEnter *'.s:ext.' call s:setup_buffer_enter()'[J

line 260:     exe 'autocmd BufLeave *'.s:ext.' call s:setup_buffer_leave()'[J

line 261:     " Format tables when exit from insert mode. Do not use textwidth to[J

line 262:     " autowrap tables.[J

line 263:     if vimwiki#vars#get_global('table_auto_fmt')[J

line 264:       exe 'autocmd InsertLeave *'.s:ext.' call vimwiki#tbl#format(line("."))'[J

line 265:       exe 'autocmd InsertEnter *'.s:ext.' call vimwiki#tbl#reset_tw(line("."))'[J

line 266:     endif[J

line 267:     if vimwiki#vars#get_global('folding') =~? ':quick$'[J

line 268:       " from http://vim.wikia.com/wiki/Keep_folds_closed_while_inserting_text[J

line 269:       " Don't screw up folds when inserting text that might affect them, until[J

line 270:       " leaving insert mode. Foldmethod is local to the window. Protect against[J

line 271:       " screwing up folding when switching between windows.[J

line 273:       exe 'autocmd InsertEnter *'.s:ext.' if !exists("w:last_fdm") | let w:last_fdm=&foldmethod'. ' | setlocal foldmethod=manual | endif'[J

line 275:       exe 'autocmd InsertLeave,WinLeave *'.s:ext.' if exists("w:last_fdm") |'. 'let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif'[J

line 276:     endif[J

line 277:   endfor[J

line 278: augroup END[J

line 279: [J

line 280: [J

line 281: [J

line 282: command! VimwikiUISelect call vimwiki#base#ui_select()[J

line 283: " why not using <count> instead of v:count1?[J

line 284: " See https://github.com/vimwiki-backup/vimwiki/issues/324[J

line 286: command! -count=1 VimwikiIndex call vimwiki#base#goto_index(v:count1)[J

line 288: command! -count=1 VimwikiTabIndex call vimwiki#base#goto_index(v:count1, 1)[J

line 289: [J

line 291: command! -count=1 VimwikiDiaryIndex call vimwiki#diary#goto_diary_index(v:count1)[J

line 293: command! -count=1 VimwikiMakeDiaryNote call vimwiki#diary#make_note(v:count)[J

line 295: command! -count=1 VimwikiTabMakeDiaryNote call vimwiki#diary#make_note(v:count, 1)[J

line 298: command! -count=1 VimwikiMakeYesterdayDiaryNote call vimwiki#diary#make_note(v:count, 0, vimwiki#diary#diary_date_link(localtime() - 60*60*24))[J

line 301: command! -count=1 VimwikiMakeTomorrowDiaryNote call vimwiki#diary#make_note(v:count, 0, vimwiki#diary#diary_date_link(localtime() + 60*60*24))[J

line 302: [J

line 304: command! VimwikiDiaryGenerateLinks call vimwiki#diary#generate_diary_section()[J

line 305: [J

line 306: command! VimwikiShowVersion call s:get_version()[J

line 307: [J

line 308: [J

line 309: [J

line 310: let s:map_prefix = vimwiki#vars#get_global('map_prefix')[J

calling function vimwiki#vars#get_global[J('map_prefix')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning '<Leader>w'[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 311: [J

line 312: if !hasmapto('<Plug>VimwikiIndex')[J

line 313:   exe 'nmap <silent><unique> '.s:map_prefix.'w <Plug>VimwikiIndex'[J

line 313: nmap <silent><unique> <Leader>ww <Plug>VimwikiIndex[J

line 314: endif[J

line 315: nnoremap <unique><script> <Plug>VimwikiIndex :VimwikiIndex<CR>[J

line 316: [J

line 317: if !hasmapto('<Plug>VimwikiTabIndex')[J

line 318:   exe 'nmap <silent><unique> '.s:map_prefix.'t <Plug>VimwikiTabIndex'[J

line 318: nmap <silent><unique> <Leader>wt <Plug>VimwikiTabIndex[J

line 319: endif[J

line 320: nnoremap <unique><script> <Plug>VimwikiTabIndex :VimwikiTabIndex<CR>[J

line 321: [J

line 322: if !hasmapto('<Plug>VimwikiUISelect')[J

line 323:   exe 'nmap <silent><unique> '.s:map_prefix.'s <Plug>VimwikiUISelect'[J

line 323: nmap <silent><unique> <Leader>ws <Plug>VimwikiUISelect[J

line 324: endif[J

line 325: nnoremap <unique><script> <Plug>VimwikiUISelect :VimwikiUISelect<CR>[J

line 326: [J

line 327: if !hasmapto('<Plug>VimwikiDiaryIndex')[J

line 328:   exe 'nmap <silent><unique> '.s:map_prefix.'i <Plug>VimwikiDiaryIndex'[J

line 328: nmap <silent><unique> <Leader>wi <Plug>VimwikiDiaryIndex[J

line 329: endif[J

line 330: nnoremap <unique><script> <Plug>VimwikiDiaryIndex :VimwikiDiaryIndex<CR>[J

line 331: [J

line 332: if !hasmapto('<Plug>VimwikiDiaryGenerateLinks')[J

line 333:   exe 'nmap <silent><unique> '.s:map_prefix.'<Leader>i <Plug>VimwikiDiaryGenerateLinks'[J

line 333: nmap <silent><unique> <Leader>w<Leader>i <Plug>VimwikiDiaryGenerateLinks[J

line 334: endif[J

line 335: nnoremap <unique><script> <Plug>VimwikiDiaryGenerateLinks :VimwikiDiaryGenerateLinks<CR>[J

line 336: [J

line 337: if !hasmapto('<Plug>VimwikiMakeDiaryNote')[J

line 338:   exe 'nmap <silent><unique> '.s:map_prefix.'<Leader>w <Plug>VimwikiMakeDiaryNote'[J

line 338: nmap <silent><unique> <Leader>w<Leader>w <Plug>VimwikiMakeDiaryNote[J

line 339: endif[J

line 340: nnoremap <unique><script> <Plug>VimwikiMakeDiaryNote :VimwikiMakeDiaryNote<CR>[J

line 341: [J

line 342: if !hasmapto('<Plug>VimwikiTabMakeDiaryNote')[J

line 343:   exe 'nmap <silent><unique> '.s:map_prefix.'<Leader>t <Plug>VimwikiTabMakeDiaryNote'[J

line 343: nmap <silent><unique> <Leader>w<Leader>t <Plug>VimwikiTabMakeDiaryNote[J

line 344: endif[J

line 346: nnoremap <unique><script> <Plug>VimwikiTabMakeDiaryNote :VimwikiTabMakeDiaryNote<CR>[J

line 347: [J

line 348: if !hasmapto('<Plug>VimwikiMakeYesterdayDiaryNote')[J

line 349:   exe 'nmap <silent><unique> '.s:map_prefix.'<Leader>y <Plug>VimwikiMakeYesterdayDiaryNote'[J

line 349: nmap <silent><unique> <Leader>w<Leader>y <Plug>VimwikiMakeYesterdayDiaryNote[J

line 350: endif[J

line 352: nnoremap <unique><script> <Plug>VimwikiMakeYesterdayDiaryNote :VimwikiMakeYesterdayDiaryNote<CR>[J

line 353: [J

line 354: if !hasmapto('<Plug>VimwikiMakeTomorrowDiaryNote')[J

line 355:   exe 'nmap <silent><unique> '.s:map_prefix.'<Leader>m <Plug>VimwikiMakeTomorrowDiaryNote'[J

line 355: nmap <silent><unique> <Leader>w<Leader>m <Plug>VimwikiMakeTomorrowDiaryNote[J

line 356: endif[J

line 358: nnoremap <unique><script> <Plug>VimwikiMakeTomorrowDiaryNote :VimwikiMakeTomorrowDiaryNote<CR>[J

line 359: [J

line 360: [J

line 361: [J

line 362: [J

line 363: function! s:build_menu(topmenu)[J

line 373: [J

line 374: function! s:build_table_menu(topmenu)[J

line 383: [J

line 384: [J

line 385: if !empty(vimwiki#vars#get_global('menu'))[J

calling function vimwiki#vars#get_global[J('menu')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning 'Vimwiki'[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 386:   call s:build_menu(vimwiki#vars#get_global('menu'))[J

calling function vimwiki#vars#get_global[J('menu')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning 'Vimwiki'[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

calling function <SNR>20_build_menu[J('Vimwiki')

line 1:   for idx in range(vimwiki#vars#number_of_wikis())[J

calling function <SNR>20_build_menu[1]..vimwiki#vars#number_of_wikis[J()

line 1:   return len(g:vimwiki_wikilocal_vars) - 1[J

function <SNR>20_build_menu[1]..vimwiki#vars#number_of_wikis returning #1[J

continuing in function <SNR>20_build_menu[J

line 2:     let norm_path = fnamemodify(vimwiki#vars#get_wikilocal('path', idx), ':h:t')[J

calling function <SNR>20_build_menu[2]..vimwiki#vars#get_wikilocal[J('path', 0)

line 1:   if a:0[J

line 2:     return g:vimwiki_wikilocal_vars[a:1][a:key][J

function <SNR>20_build_menu[2]..vimwiki#vars#get_wikilocal returning '/Users/ygarrot/vimwiki/'[J

continuing in function <SNR>20_build_menu[J

line 3:     let norm_path = escape(norm_path, '\ \.')[J

line 4:     execute 'menu '.a:topmenu.'.Open\ index.'.norm_path. ' :call vimwiki#base#goto_index('.(idx+1).')<CR>'[J

line 4: menu Vimwiki.Open\ index.vimwiki :call vimwiki#base#goto_index(1)<CR>[J

line 6:     execute 'menu '.a:topmenu.'.Open/Create\ diary\ note.'.norm_path. ' :call vimwiki#diary#make_note('.(idx+1).')<CR>'[J

line 6: menu Vimwiki.Open/Create\ diary\ note.vimwiki :call vimwiki#diary#make_note(1)<CR>[J

line 8:   endfor[J

line 1:   for idx in range(vimwiki#vars#number_of_wikis())[J

line 2:     let norm_path = fnamemodify(vimwiki#vars#get_wikilocal('path', idx), ':h:t')[J

line 3:     let norm_path = escape(norm_path, '\ \.')[J

line 4:     execute 'menu '.a:topmenu.'.Open\ index.'.norm_path. ' :call vimwiki#base#goto_index('.(idx+1).')<CR>'[J

line 6:     execute 'menu '.a:topmenu.'.Open/Create\ diary\ note.'.norm_path. ' :call vimwiki#diary#make_note('.(idx+1).')<CR>'[J

line 8:   endfor[J

function <SNR>20_build_menu returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 387:   call s:build_table_menu(vimwiki#vars#get_global('menu'))[J

calling function vimwiki#vars#get_global[J('menu')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning 'Vimwiki'[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

calling function <SNR>20_build_table_menu[J('Vimwiki')

line 1:   exe 'menu '.a:topmenu.'.-Sep- :'[J

line 1: menu Vimwiki.-Sep- :[J

line 2:   exe 'menu '.a:topmenu.'.Table.Create\ (enter\ cols\ rows) :VimwikiTable '[J

line 2: menu Vimwiki.Table.Create\ (enter\ cols\ rows) :VimwikiTable [J

line 3:   exe 'nmenu '.a:topmenu.'.Table.Format<tab>gqq gqq'[J

line 3: nmenu Vimwiki.Table.Format<tab>gqq gqq[J

line 4:   exe 'nmenu '.a:topmenu.'.Table.Move\ column\ left<tab><A-Left> :VimwikiTableMoveColumnLeft<CR>'[J

line 4: nmenu Vimwiki.Table.Move\ column\ left<tab><A-Left> :VimwikiTableMoveColumnLeft<CR>[J

line 5:   exe 'nmenu '.a:topmenu. '.Table.Move\ column\ right<tab><A-Right> :VimwikiTableMoveColumnRight<CR>'[J

line 5: nmenu Vimwiki.Table.Move\ column\ right<tab><A-Right> :VimwikiTableMoveColumnRight<CR>[J

line 7:   exe 'nmenu disable '.a:topmenu.'.Table'[J

line 7: nmenu disable Vimwiki.Table[J

function <SNR>20_build_table_menu returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 388: endif[J

line 389: [J

line 390: [J

line 391: " Hook for calendar.vim[J

line 392: if vimwiki#vars#get_global('use_calendar')[J

calling function vimwiki#vars#get_global[J('use_calendar')

line 1:   return g:vimwiki_global_vars[a:key][J

function vimwiki#vars#get_global returning #1[J

continuing in /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J

line 393:   let g:calendar_action = 'vimwiki#diary#calendar_action'[J

line 394:   let g:calendar_sign = 'vimwiki#diary#calendar_sign'[J

line 395: endif[J

line 396: [J

line 397: [J

line 398: let &cpo = s:old_cpo[J

finished sourcing /Users/ygarrot/.vim/plugged/vimwiki/plugin/vimwiki.vim[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-airline/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/vim-airline/plugin/airline.vim"[J
line 1: " MIT License. Copyright (c) 2013-2019 Bailey Ling, Christian Brabandt et al.[J

line 2: " vim: et ts=2 sts=2 sw=2[J

line 3: [J

line 4: scriptencoding utf-8[J

line 5: [J

line 6: if &cp || v:version < 702 || (exists('g:loaded_airline') && g:loaded_airline)[J

line 7:   finish[J

line 8: endif[J

line 9: let g:loaded_airline = 1[J

line 10: [J

line 11: let s:airline_initialized = 0[J

line 12: function! s:init()[J

line 46: [J

line 47: let s:active_winnr = -1[J

line 48: function! s:on_window_changed(event)[J

line 73: [J

line 74: function! s:on_cursor_moved()[J

line 80: [J

line 81: function! s:on_colorscheme_changed()[J

line 93: [J

line 94: function! airline#cmdwinenter(...)[J

Searching for "autoload/airline.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/autoload/airline.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/autoload/airline.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/autoload/airline.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/autoload/airline.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/autoload/airline.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/autoload/airline.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/autoload/airline.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/autoload/airline.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/autoload/airline.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-airline/autoload)[J
fchdir() to previous dir[J
line 94: sourcing "/Users/ygarrot/.vim/plugged/vim-airline/autoload/airline.vim"[J
line 1: " MIT License. Copyright (c) 2013-2019 Bailey Ling et al.[J

line 2: " vim: et ts=2 sts=2 sw=2[J

line 3: [J

line 4: scriptencoding utf-8[J

line 5: [J

line 6: let g:airline_statusline_funcrefs = get(g:, 'airline_statusline_funcrefs', [])[J

line 7: [J

line 8: let s:sections = ['a','b','c','gutter','x','y','z', 'error', 'warning'][J

line 9: let s:inactive_funcrefs = [][J

line 10: let s:contexts = {}[J

line 13: let s:core_funcrefs = [ function('airline#extensions#apply'), function('airline#extensions#default#apply') ][J

line 14: [J

line 15: [J

line 16: function! airline#add_statusline_func(name)[J

line 19: [J

line 20: function! airline#add_statusline_funcref(function)[J

line 27: [J

line 28: function! airline#remove_statusline_func(name)[J

line 34: [J

line 35: function! airline#add_inactive_statusline_func(name)[J

line 38: [J

line 39: function! airline#load_theme()[J

line 57: [J

line 58: " Load an airline theme[J

line 59: function! airline#switch_theme(name, ...)[J

line 101: [J

line 102: " Try to load the right theme for the current colorscheme[J

line 103: function! airline#switch_matching_theme()[J

line 125: [J

line 126: " Update the statusline[J

line 127: function! airline#update_statusline()[J

line 143: [J

line 144: " Function to be called to make all statuslines inactive[J

line 145: " Triggered on FocusLost autocommand[J

line 146: function! airline#update_statusline_focuslost()[J

line 154: [J

line 155: " Function to draw inactive statuslines for inactive windows[J

line 156: function! airline#update_statusline_inactive(range)[J

line 174: [J

line 175: " Gather output from all funcrefs which will later be returned by the[J

line 176: " airline#statusline() function[J

line 177: function! s:invoke_funcrefs(context, funcrefs)[J

line 187: [J

line 188: " Main statusline function per window[J

line 189: " will be set to the statusline option[J

line 190: function! airline#statusline(winnr)[J

line 197: [J

line 198: " Check if mode has changed[J

line 199: function! airline#check_mode(winnr)[J

line 272: [J

line 273: function! airline#update_tabline()[J

line 278: [J

line 279: function! airline#mode_changed()[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-airline/autoload/airline.vim[J
continuing in /Users/ygarrot/.vim/plugged/vim-airline/plugin/airline.vim[J
line 97: [J

line 98: function! s:airline_toggle()[J

line 183: [J

line 184: function! s:get_airline_themes(a, l, p)[J

line 187: [J

line 188: function! s:airline_theme(...)[J

line 205: [J

line 206: function! s:airline_refresh(...)[J

line 221: [J

line 222: function! s:FocusGainedHandler(timer)[J

line 229: [J

line 230: function! s:airline_extensions()[J

line 252: [J

line 253: function! s:rand(max) abort[J

line 268: [J

line 269: function! s:random_theme() abort[J

line 273: [J

line 274: command! -bar -nargs=? -complete=customlist,<sid>get_airline_themes AirlineTheme call <sid>airline_theme(<f-args>)[J

line 275: command! -bar AirlineToggleWhitespace call airline#extensions#whitespace#toggle()[J

line 276: command! -bar AirlineToggle  call s:airline_toggle()[J

line 277: command! -bar -bang AirlineRefresh call s:airline_refresh(<q-bang>)[J

line 278: command! AirlineExtensions   call s:airline_extensions()[J

line 279: [J

line 280: call airline#init#bootstrap()[J

Searching for "autoload/airline/init.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/autoload/airline/init.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/autoload/airline/init.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/autoload/airline/init.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/autoload/airline/init.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/autoload/airline/init.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/autoload/airline/init.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/autoload/airline/init.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/autoload/airline/init.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/autoload/airline/init.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-airline/autoload/airline)[J
fchdir() to previous dir[J
line 280: sourcing "/Users/ygarrot/.vim/plugged/vim-airline/autoload/airline/init.vim"[J
line 1: " MIT License. Copyright (c) 2013-2019 Bailey Ling et al.[J

line 2: " vim: et ts=2 sts=2 sw=2[J

line 3: [J

line 4: scriptencoding utf-8[J

line 5: [J

line 6: function! s:check_defined(variable, default)[J

line 11: [J

line 12: let s:loaded = 0[J

line 13: function! airline#init#bootstrap()[J

line 179: [J

line 180: function! airline#init#gui_mode()[J

line 183: [J

line 184: function! airline#init#sections()[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-airline/autoload/airline/init.vim[J
continuing in /Users/ygarrot/.vim/plugged/vim-airline/plugin/airline.vim[J
calling function airline#init#bootstrap[J()

line 1:   if s:loaded[J

line 2:     return[J

line 3:   endif[J

line 4:   let s:loaded = 1[J

line 5: [J

line 6:   let g:airline#init#bootstrapping = 1[J

line 7: [J

line 8:   let g:airline#init#vim_async = (v:version >= 800 && has('job'))[J

line 9:   let g:airline#init#is_windows = has('win32') || has('win64')[J

line 10: [J

line 11:   call s:check_defined('g:airline_detect_modified', 1)[J

calling function airline#init#bootstrap[11]..<SNR>25_check_defined[J('g:airline_detect_modified', 1)

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[11]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 12:   call s:check_defined('g:airline_detect_paste', 1)[J

calling function airline#init#bootstrap[12]..<SNR>25_check_defined[J('g:airline_detect_paste', 1)

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[12]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 13:   call s:check_defined('g:airline_detect_crypt', 1)[J

calling function airline#init#bootstrap[13]..<SNR>25_check_defined[J('g:airline_detect_crypt', 1)

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[13]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 14:   call s:check_defined('g:airline_detect_spell', 1)[J

calling function airline#init#bootstrap[14]..<SNR>25_check_defined[J('g:airline_detect_spell', 1)

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[14]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 15:   call s:check_defined('g:airline_detect_spelllang', 1)[J

calling function airline#init#bootstrap[15]..<SNR>25_check_defined[J('g:airline_detect_spelllang', 1)

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[15]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 16:   call s:check_defined('g:airline_detect_iminsert', 0)[J

calling function airline#init#bootstrap[16]..<SNR>25_check_defined[J('g:airline_detect_iminsert', 0)

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[16]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 17:   call s:check_defined('g:airline_inactive_collapse', 1)[J

calling function airline#init#bootstrap[17]..<SNR>25_check_defined[J('g:airline_inactive_collapse', 1)

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[17]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 18:   call s:check_defined('g:airline_exclude_filenames', ['DebuggerWatch','DebuggerStack','DebuggerStatus'])[J

calling function airline#init#bootstrap[18]..<SNR>25_check_defined[J('g:airline_exclude_filenames', ['DebuggerWatch', 'DebuggerStack', 'DebuggerStatus'])

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[18]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 19:   call s:check_defined('g:airline_exclude_filetypes', [])[J

calling function airline#init#bootstrap[19]..<SNR>25_check_defined[J('g:airline_exclude_filetypes', [])

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[19]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 20:   call s:check_defined('g:airline_exclude_preview', 0)[J

calling function airline#init#bootstrap[20]..<SNR>25_check_defined[J('g:airline_exclude_preview', 0)

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[20]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 21:   call s:check_defined('g:airline_gui_mode', airline#init#gui_mode())[J

calling function airline#init#bootstrap[21]..airline#init#gui_mode[J()

line 1:   return has('gui_running') || (has("termguicolors") && &termguicolors == 1) ?  'gui' : 'cterm'[J

function airline#init#bootstrap[21]..airline#init#gui_mode returning 'cterm'[J

continuing in function airline#init#bootstrap[J

calling function airline#init#bootstrap[21]..<SNR>25_check_defined[J('g:airline_gui_mode', 'cterm')

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[21]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 22: [J

line 23:   call s:check_defined('g:airline_mode_map', {})[J

calling function airline#init#bootstrap[23]..<SNR>25_check_defined[J('g:airline_mode_map', {})

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[23]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 24:   call extend(g:airline_mode_map, { '__' : '------', 'c'  : 'COMMAND', 'i'  : 'INSERT', 'ic' : 'INSERT COMPL', 'ix' : 'INSERT COMPL', 'multi' : 'MULTI', 'n'  : 'NORMAL', 'ni' : '(INSERT)', 'no' : 'OP PENDING', 'R'  : 'REPLACE', 'Rv' : 'V REPLACE', 's'  : 'SELECT', 'S'  : 'S-LINE', '^S' : 'S-BLOCK', 't'  : 'TERMINAL', 'v'  : 'VISUAL', 'V'  : 'V-LINE', '^V' : 'V-BLOCK', }, 'keep')[J

line 44: [J

line 45:   call s:check_defined('g:airline_theme_map', {})[J

calling function airline#init#bootstrap[45]..<SNR>25_check_defined[J('g:airline_theme_map', {})

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[45]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 46:   call extend(g:airline_theme_map, { 'default': 'dark', '\CTomorrow': 'tomorrow', 'base16': 'base16', 'mo[l|n]okai': 'molokai', 'wombat': 'wombat', 'zenburn': 'zenburn', 'solarized': 'solarized', 'flattened': 'solarized', '\CNeoSolarized': 'solarized', }, 'keep')[J

line 57: [J

line 58:   call s:check_defined('g:airline_symbols', {})[J

calling function airline#init#bootstrap[58]..<SNR>25_check_defined[J('g:airline_symbols', {})

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[58]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 59:   " First define the symbols,[J

line 60:   " that are common in Powerline/Unicode/ASCII mode,[J

line 61:   " then add specific symbols for either mode[J

line 62:   call extend(g:airline_symbols, { 'paste': 'PASTE', 'spell': 'SPELL', 'modified': '+', 'space': ' ', 'keymap': 'Keymap:', 'ellipsis': '...'  }, 'keep')[J

line 70: [J

line 71:   if get(g:, 'airline_powerline_fonts', 0)[J

line 72:     " Symbols for Powerline terminals[J

line 73:     call s:check_defined('g:airline_left_sep', "\ue0b0")      " [J

line 74:     call s:check_defined('g:airline_left_alt_sep', "\ue0b1")  " [J

line 75:     call s:check_defined('g:airline_right_sep', "\ue0b2")     " [J

line 76:     call s:check_defined('g:airline_right_alt_sep', "\ue0b3") " [J

line 77:     " ro=, ws=☲, lnr=☰, mlnr=, br=, nx=Ɇ, crypt=🔒, dirty=⚡[J

line 78:     call extend(g:airline_symbols, { 'readonly': "\ue0a2", 'whitespace': "\u2632", 'linenr': "\u2630 ", 'maxlinenr': " \ue0a1", 'branch': "\ue0a0", 'notexists': "\u0246", 'dirty': "\u26a1", 'crypt': nr2char(0x1F512), }, 'keep')[J

line 88:   elseif &encoding==?'utf-8' && !get(g:, "airline_symbols_ascii", 0)[J

line 89:     " Symbols for Unicode terminals[J

line 90:     call s:check_defined('g:airline_left_sep', "")[J

calling function airline#init#bootstrap[90]..<SNR>25_check_defined[J('g:airline_left_sep', '')

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[90]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 91:     call s:check_defined('g:airline_left_alt_sep', "")[J

calling function airline#init#bootstrap[91]..<SNR>25_check_defined[J('g:airline_left_alt_sep', '')

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[91]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 92:     call s:check_defined('g:airline_right_sep', "")[J

calling function airline#init#bootstrap[92]..<SNR>25_check_defined[J('g:airline_right_sep', '')

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[92]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 93:     call s:check_defined('g:airline_right_alt_sep', "")[J

calling function airline#init#bootstrap[93]..<SNR>25_check_defined[J('g:airline_right_alt_sep', '')

line 1:   if !exists(a:variable)[J

line 2:     let {a:variable} = a:default[J

line 3:   endif[J

function airline#init#bootstrap[93]..<SNR>25_check_defined returning #0[J

continuing in function airline#init#bootstrap[J

line 94:     " ro=⊝, ws=☲, lnr=☰, mlnr=㏑, br=ᚠ, nx=Ɇ, crypt=🔒[J

line 95:     call extend(g:airline_symbols, { 'readonly': "\u229D", 'whitespace': "\u2632", 'linenr': "\u2630 ", 'maxlinenr': " \u33D1", 'branch': "\u16A0", 'notexists': "\u0246", 'crypt': nr2char(0x1F512), 'dirty': '!', }, 'keep')[J

line 105:   else[J

line 106:     " Symbols for ASCII terminals[J

line 107:     call s:check_defined('g:airline_left_sep', "")[J

line 108:     call s:check_defined('g:airline_left_alt_sep', "")[J

line 109:     call s:check_defined('g:airline_right_sep', "")[J

line 110:     call s:check_defined('g:airline_right_alt_sep', "")[J

line 111:     call extend(g:airline_symbols, { 'readonly': 'RO', 'whitespace': '!', 'linenr': 'ln ', 'maxlinenr': ' :', 'branch': '', 'notexists': '?', 'crypt': 'cr', 'dirty': '!', }, 'keep')[J

line 121:   endif[J

line 122: [J

line 123:   call airline#parts#define('mode', { 'function': 'airline#parts#mode', 'accent': 'bold', })[J

Searching for "autoload/airline/parts.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/autoload/airline/parts.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/autoload/airline/parts.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/autoload/airline/parts.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/autoload/airline/parts.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/autoload/airline/parts.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/autoload/airline/parts.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/autoload/airline/parts.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/autoload/airline/parts.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/autoload/airline/parts.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-airline/autoload/airline)[J
fchdir() to previous dir[J
line 123: sourcing "/Users/ygarrot/.vim/plugged/vim-airline/autoload/airline/parts.vim"[J
line 1: " MIT License. Copyright (c) 2013-2019 Bailey Ling et al.[J

line 2: " vim: et ts=2 sts=2 sw=2[J

line 3: [J

line 4: scriptencoding utf-8[J

line 5: [J

line 6: let s:parts = {}[J

line 7: [J

line 8: " PUBLIC API {{{[J

line 9: [J

line 10: function! airline#parts#define(key, config)[J

line 18: [J

line 19: function! airline#parts#define_function(key, name)[J

line 22: [J

line 23: function! airline#parts#define_text(key, text)[J

line 26: [J

line 27: function! airline#parts#define_raw(key, raw)[J

line 30: [J

line 31: function! airline#parts#define_minwidth(key, width)[J

line 34: [J

line 35: function! airline#parts#define_condition(key, predicate)[J

line 38: [J

line 39: function! airline#parts#define_accent(key, accent)[J

line 42: [J

line 43: function! airline#parts#define_empty(keys)[J

line 48: [J

line 49: function! airline#parts#get(key)[J

line 52: [J

line 53: " }}}[J

line 54: [J

line 55: function! airline#parts#mode()[J

line 58: [J

line 59: function! airline#parts#crypt()[J

line 62: [J

line 63: function! airline#parts#paste()[J

line 66: [J

line 67: function! airline#parts#spell()[J

line 81: [J

line 82: function! airline#parts#iminsert()[J

line 88: [J

line 89: function! airline#parts#readonly()[J

line 101: [J

line 102: function! airline#parts#filetype()[J

line 107: [J

line 108: function! airline#parts#ffenc()[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-airline/autoload/airline/parts.vim[J
continuing in function airline#init#bootstrap[J
calling function airline#init#bootstrap[123]..airline#parts#define[J('mode', {'function': 'airline#parts#mode', 'accent': 'bold'})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[123]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[J

line 127:   call airline#parts#define_function('iminsert', 'airline#parts#iminsert')[J

calling function airline#init#bootstrap[127]..airline#parts#define_function[J('iminsert', 'airline#parts#iminsert')

line 1:   call airline#parts#define(a:key, { 'function': a:name })[J

calling function airline#init#bootstrap[127]..airline#parts#define_function[1]..airline#parts#define[J('iminsert', {'function': 'airline#parts#iminsert'})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[127]..airline#parts#define_function[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[127]..airline#parts#define_function[J

function airline#init#bootstrap[127]..airline#parts#define_function returning #0[J

continuing in function airline#init#bootstrap[J

line 128:   call airline#parts#define_function('paste', 'airline#parts#paste')[J

calling function airline#init#bootstrap[128]..airline#parts#define_function[J('paste', 'airline#parts#paste')

line 1:   call airline#parts#define(a:key, { 'function': a:name })[J

calling function airline#init#bootstrap[128]..airline#parts#define_function[1]..airline#parts#define[J('paste', {'function': 'airline#parts#paste'})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[128]..airline#parts#define_function[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[128]..airline#parts#define_function[J

function airline#init#bootstrap[128]..airline#parts#define_function returning #0[J

continuing in function airline#init#bootstrap[J

line 129:   call airline#parts#define_function('crypt', 'airline#parts#crypt')[J

calling function airline#init#bootstrap[129]..airline#parts#define_function[J('crypt', 'airline#parts#crypt')

line 1:   call airline#parts#define(a:key, { 'function': a:name })[J

calling function airline#init#bootstrap[129]..airline#parts#define_function[1]..airline#parts#define[J('crypt', {'function': 'airline#parts#crypt'})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[129]..airline#parts#define_function[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[129]..airline#parts#define_function[J

function airline#init#bootstrap[129]..airline#parts#define_function returning #0[J

continuing in function airline#init#bootstrap[J

line 130:   call airline#parts#define_function('spell', 'airline#parts#spell')[J

calling function airline#init#bootstrap[130]..airline#parts#define_function[J('spell', 'airline#parts#spell')

line 1:   call airline#parts#define(a:key, { 'function': a:name })[J

calling function airline#init#bootstrap[130]..airline#parts#define_function[1]..airline#parts#define[J('spell', {'function': 'airline#parts#spell'})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[130]..airline#parts#define_function[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[130]..airline#parts#define_function[J

function airline#init#bootstrap[130]..airline#parts#define_function returning #0[J

continuing in function airline#init#bootstrap[J

line 131:   call airline#parts#define_function('filetype', 'airline#parts#filetype')[J

calling function airline#init#bootstrap[131]..airline#parts#define_function[J('filetype', 'airline#parts#filetype')

line 1:   call airline#parts#define(a:key, { 'function': a:name })[J

calling function airline#init#bootstrap[131]..airline#parts#define_function[1]..airline#parts#define[J('filetype', {'function': 'airline#parts#filetype'})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[131]..airline#parts#define_function[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[131]..airline#parts#define_function[J

function airline#init#bootstrap[131]..airline#parts#define_function returning #0[J

continuing in function airline#init#bootstrap[J

line 132:   call airline#parts#define('readonly', { 'function': 'airline#parts#readonly', 'accent': 'red', })[J

calling function airline#init#bootstrap[132]..airline#parts#define[J('readonly', {'function': 'airline#parts#readonly', 'accent': 'red'})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[132]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[J

line 136:   call airline#parts#define_raw('file', '%f%m')[J

calling function airline#init#bootstrap[136]..airline#parts#define_raw[J('file', '%f%m')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[136]..airline#parts#define_raw[1]..airline#parts#define[J('file', {'raw': '%f%m'})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[136]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[136]..airline#parts#define_raw[J

function airline#init#bootstrap[136]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[J

line 137:   call airline#parts#define_raw('path', '%F%m')[J

calling function airline#init#bootstrap[137]..airline#parts#define_raw[J('path', '%F%m')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[137]..airline#parts#define_raw[1]..airline#parts#define[J('path', {'raw': '%F%m'})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[137]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[137]..airline#parts#define_raw[J

function airline#init#bootstrap[137]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[J

line 138:   call airline#parts#define('linenr', { 'raw': '%{g:airline_symbols.linenr}%4l', 'accent': 'bold'})[J

calling function airline#init#bootstrap[138]..airline#parts#define[J('linenr', {'accent': 'bold', 'raw': '%{g:airline_symbols.linenr}%4l'})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[138]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[J

line 141:   call airline#parts#define('maxlinenr', { 'raw': '/%L%{g:airline_symbols.maxlinenr}', 'accent': 'bold'})[J

calling function airline#init#bootstrap[141]..airline#parts#define[J('maxlinenr', {'accent': 'bold', 'raw': '/%L%{g:airline_symbols.maxlinenr}'})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[141]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[J

line 144:   call airline#parts#define_function('ffenc', 'airline#parts#ffenc')[J

calling function airline#init#bootstrap[144]..airline#parts#define_function[J('ffenc', 'airline#parts#ffenc')

line 1:   call airline#parts#define(a:key, { 'function': a:name })[J

calling function airline#init#bootstrap[144]..airline#parts#define_function[1]..airline#parts#define[J('ffenc', {'function': 'airline#parts#ffenc'})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[144]..airline#parts#define_function[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[144]..airline#parts#define_function[J

function airline#init#bootstrap[144]..airline#parts#define_function returning #0[J

continuing in function airline#init#bootstrap[J

line 145:   call airline#parts#define('hunks', { 'raw': '', 'minwidth': 100})[J

calling function airline#init#bootstrap[145]..airline#parts#define[J('hunks', {'minwidth': 100, 'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[145]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[J

line 148:   call airline#parts#define('branch', { 'raw': '', 'minwidth': 80})[J

calling function airline#init#bootstrap[148]..airline#parts#define[J('branch', {'minwidth': 80, 'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[148]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[J

line 151:   call airline#parts#define_empty(['obsession', 'tagbar', 'syntastic-warn', 'syntastic-err', 'eclim', 'whitespace','windowswap', 'ycm_error_count', 'ycm_warning_count', 'neomake_error_count', 'neomake_warning_count', 'ale_error_count', 'ale_warning_count', 'languageclient_error_count', 'languageclient_warning_count', 'coc_warning_count', 'coc_error_count', 'vista'])[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[J(['obsession', 'tagbar', 'syntastic-wa...ning_count', 'coc_error_count', 'vista'])

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('obsession', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('obsession', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('tagbar', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('tagbar', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('syntastic-warn', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('syntastic-warn', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('syntastic-err', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('syntastic-err', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('eclim', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('eclim', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('whitespace', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('whitespace', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('windowswap', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('windowswap', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('ycm_error_count', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('ycm_error_count', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('ycm_warning_count', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('ycm_warning_count', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('neomake_error_count', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('neomake_error_count', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('neomake_warning_count', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('neomake_warning_count', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('ale_error_count', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('ale_error_count', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('ale_warning_count', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('ale_warning_count', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('languageclient_error_count', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('languageclient_error_count', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('languageclient_warning_count', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('languageclient_warning_count', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('coc_warning_count', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('coc_warning_count', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('coc_error_count', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('coc_error_count', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J('vista', '')

line 1:   call airline#parts#define(a:key, { 'raw': a:raw })[J

calling function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define[J('vista', {'raw': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw[J

function airline#init#bootstrap[151]..airline#parts#define_empty[2]..airline#parts#define_raw returning #0[J

continuing in function airline#init#bootstrap[151]..airline#parts#define_empty[J

line 3:   endfor[J

line 1:   for key in a:keys[J

line 2:     call airline#parts#define_raw(key, '')[J

line 3:   endfor[J

function airline#init#bootstrap[151]..airline#parts#define_empty returning #0[J

continuing in function airline#init#bootstrap[J

line 157:   call airline#parts#define_text('bookmark', '')[J

calling function airline#init#bootstrap[157]..airline#parts#define_text[J('bookmark', '')

line 1:   call airline#parts#define(a:key, { 'text': a:text })[J

calling function airline#init#bootstrap[157]..airline#parts#define_text[1]..airline#parts#define[J('bookmark', {'text': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[157]..airline#parts#define_text[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[157]..airline#parts#define_text[J

function airline#init#bootstrap[157]..airline#parts#define_text returning #0[J

continuing in function airline#init#bootstrap[J

line 158:   call airline#parts#define_text('capslock', '')[J

calling function airline#init#bootstrap[158]..airline#parts#define_text[J('capslock', '')

line 1:   call airline#parts#define(a:key, { 'text': a:text })[J

calling function airline#init#bootstrap[158]..airline#parts#define_text[1]..airline#parts#define[J('capslock', {'text': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[158]..airline#parts#define_text[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[158]..airline#parts#define_text[J

function airline#init#bootstrap[158]..airline#parts#define_text returning #0[J

continuing in function airline#init#bootstrap[J

line 159:   call airline#parts#define_text('gutentags', '')[J

calling function airline#init#bootstrap[159]..airline#parts#define_text[J('gutentags', '')

line 1:   call airline#parts#define(a:key, { 'text': a:text })[J

calling function airline#init#bootstrap[159]..airline#parts#define_text[1]..airline#parts#define[J('gutentags', {'text': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[159]..airline#parts#define_text[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[159]..airline#parts#define_text[J

function airline#init#bootstrap[159]..airline#parts#define_text returning #0[J

continuing in function airline#init#bootstrap[J

line 160:   call airline#parts#define_text('grepper', '')[J

calling function airline#init#bootstrap[160]..airline#parts#define_text[J('grepper', '')

line 1:   call airline#parts#define(a:key, { 'text': a:text })[J

calling function airline#init#bootstrap[160]..airline#parts#define_text[1]..airline#parts#define[J('grepper', {'text': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[160]..airline#parts#define_text[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[160]..airline#parts#define_text[J

function airline#init#bootstrap[160]..airline#parts#define_text returning #0[J

continuing in function airline#init#bootstrap[J

line 161:   call airline#parts#define_text('xkblayout', '')[J

calling function airline#init#bootstrap[161]..airline#parts#define_text[J('xkblayout', '')

line 1:   call airline#parts#define(a:key, { 'text': a:text })[J

calling function airline#init#bootstrap[161]..airline#parts#define_text[1]..airline#parts#define[J('xkblayout', {'text': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[161]..airline#parts#define_text[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[161]..airline#parts#define_text[J

function airline#init#bootstrap[161]..airline#parts#define_text returning #0[J

continuing in function airline#init#bootstrap[J

line 162:   call airline#parts#define_text('keymap', '')[J

calling function airline#init#bootstrap[162]..airline#parts#define_text[J('keymap', '')

line 1:   call airline#parts#define(a:key, { 'text': a:text })[J

calling function airline#init#bootstrap[162]..airline#parts#define_text[1]..airline#parts#define[J('keymap', {'text': ''})

line 1:   let s:parts[a:key] = get(s:parts, a:key, {})[J

line 2:   if exists('g:airline#init#bootstrapping')[J

line 3:     call extend(s:parts[a:key], a:config, 'keep')[J

line 4:   else[J

line 5:     call extend(s:parts[a:key], a:config, 'force')[J

line 6:   endif[J

function airline#init#bootstrap[162]..airline#parts#define_text[1]..airline#parts#define returning #0[J

continuing in function airline#init#bootstrap[162]..airline#parts#define_text[J

function airline#init#bootstrap[162]..airline#parts#define_text returning #0[J

continuing in function airline#init#bootstrap[J

line 163: [J

line 164:   unlet g:airline#init#bootstrapping[J

function airline#init#bootstrap returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vim-airline/plugin/airline.vim[J

line 281: call s:airline_toggle()[J

calling function <SNR>23_airline_toggle[J()

line 1:   if exists("#airline")[J

line 2:     augroup airline[J

line 3:       au![J

line 4:     augroup END[J

line 5:     augroup! airline[J

line 6: [J

line 7:     if exists("s:stl")[J

line 8:       let &stl = s:stl[J

line 9:     endif[J

line 10:     if exists("s:tal")[J

line 11:       let [&tal, &showtabline] = s:tal[J

line 12:     endif[J

line 13:     call airline#highlighter#reset_hlcache()[J

line 14: [J

line 15:     call airline#util#doautocmd('AirlineToggledOff')[J

line 16:   else[J

line 17:     let s:stl = &statusline[J

line 18:     let s:tal = [&tabline, &showtabline][J

line 19:     augroup airline[J

line 20:       autocmd![J

line 21: [J

line 22:       autocmd CmdwinEnter * call airline#add_statusline_func('airline#cmdwinenter') | call <sid>on_window_changed('CmdwinEnter')[J

line 25:       autocmd CmdwinLeave * call airline#remove_statusline_func('airline#cmdwinenter')[J

line 26: [J

line 27:       autocmd GUIEnter,ColorScheme * call <sid>on_colorscheme_changed()[J

line 28:       if exists("##OptionSet")[J

line 29:         " Make sure that g_airline_gui_mode is refreshed[J

line 30:         autocmd OptionSet termguicolors call <sid>on_colorscheme_changed()[J

line 31:       endif[J

line 32:       " Set all statuslines to inactive[J

line 33:       autocmd FocusLost * call airline#update_statusline_focuslost()[J

line 34:       " Refresh airline for :syntax off[J

line 35:       autocmd SourcePre */syntax/syntax.vim call airline#extensions#tabline#buffers#invalidate()[J

line 37:       autocmd VimEnter * call <sid>on_window_changed('VimEnter')[J

line 38:       autocmd WinEnter * call <sid>on_window_changed('WinEnter')[J

line 39:       autocmd FileType * call <sid>on_window_changed('FileType')[J

line 40:       autocmd BufWinEnter * call <sid>on_window_changed('BufWinEnter')[J

line 41:       autocmd BufUnload * call <sid>on_window_changed('BufUnload')[J

line 42:       if exists('##CompleteDone')[J

line 43:         autocmd CompleteDone * call <sid>on_window_changed('CompleteDone')[J

line 44:       endif[J

line 45:       " non-trivial number of external plugins use eventignore=all, so we need to account for that[J

line 46:       autocmd CursorMoved * call <sid>on_cursor_moved()[J

line 47: [J

line 48:       autocmd VimResized * unlet! w:airline_lastmode | :call <sid>airline_refresh()[J

line 49:       if exists('*timer_start') && exists('*funcref')[J

line 50:         " do not trigger FocusGained on startup, it might erase the intro screen (see #1817)[J

line 51:         " needs funcref() (needs 7.4.2137) and timers (7.4.1578)[J

line 52:         let Handler=funcref('<sid>FocusGainedHandler')[J

line 53:         let s:timer=timer_start(5000, Handler)[J

line 54:       else[J

line 55:         autocmd FocusGained * unlet! w:airline_lastmode | :call <sid>airline_refresh()[J

line 56:       endif[J

line 57: [J

line 58:       if exists("##TerminalOpen")[J

line 59:         " Using the same function with the TermOpen autocommand[J

line 60:         " breaks for Neovim see #1828, looks like a neovim bug.[J

line 61:         autocmd TerminalOpen * :call airline#load_theme() " reload current theme for Terminal, forces the terminal extension to be loaded[J

line 62:       endif[J

line 63:       autocmd TabEnter * :unlet! w:airline_lastmode | let w:airline_active=1[J

line 64:       autocmd BufWritePost */autoload/airline/themes/*.vim exec 'source '.split(globpath(&rtp, 'autoload/airline/themes/'.g:airline_theme.'.vim', 1), "\n")[0] | call airline#load_theme()[J

line 67:       autocmd User AirlineModeChanged nested call airline#mode_changed()[J

line 68: [J

line 69:       if get(g:, 'airline_statusline_ontop', 0)[J

line 70:         " Force update of tabline more often[J

line 71:         autocmd InsertEnter,InsertLeave,CursorMovedI * :call airline#update_tabline()[J

line 72:       endif[J

line 73:     augroup END[J

line 74: [J

line 75:     if &laststatus < 2[J

line 76:       set laststatus=2[J

line 77:     endif[J

line 78:     if s:airline_initialized[J

line 79:       call s:on_window_changed('Init')[J

line 80:     endif[J

line 81: [J

line 82:     call airline#util#doautocmd('AirlineToggledOn')[J

Searching for "autoload/airline/util.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/autoload/airline/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/autoload/airline/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/autoload/airline/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/autoload/airline/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/autoload/airline/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/autoload/airline/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/autoload/airline/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/autoload/airline/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/autoload/airline/util.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-airline/autoload/airline)[J
fchdir() to previous dir[J
line 82: sourcing "/Users/ygarrot/.vim/plugged/vim-airline/autoload/airline/util.vim"[J
line 1: " MIT License. Copyright (c) 2013-2019 Bailey Ling Christian Brabandt et al.[J

line 2: " vim: et ts=2 sts=2 sw=2[J

line 3: [J

line 4: scriptencoding utf-8[J

line 5: [J

line 6: call airline#init#bootstrap()[J

calling function airline#init#bootstrap[J()

line 1:   if s:loaded[J

line 2:     return[J

function airline#init#bootstrap returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vim-airline/autoload/airline/util.vim[J

line 7: [J

line 8: " couple of static variables. Those should not change within a session, thus[J

line 9: " can be initialized here as "static"[J

line 10: let s:spc = g:airline_symbols.space[J

line 11: let s:nomodeline = (v:version > 703 || (v:version == 703 && has("patch438"))) ? '<nomodeline>' : ''[J

line 12: let s:has_strchars = exists('*strchars')[J

line 13: let s:has_strcharpart = exists('*strcharpart')[J

line 14: [J

line 15: " TODO: Try to cache winwidth(0) function[J

line 16: " e.g. store winwidth per window and access that, only update it, if the size[J

line 17: " actually changed.[J

line 18: function! airline#util#winwidth(...)[J

line 26: [J

line 27: function! airline#util#shorten(text, winwidth, minwidth, ...)[J

line 40: [J

line 41: function! airline#util#wrap(text, minwidth)[J

line 47: [J

line 48: function! airline#util#append(text, minwidth)[J

line 55: [J

line 56: function! airline#util#warning(msg)[J

line 61: [J

line 62: function! airline#util#prepend(text, minwidth)[J

line 68: [J

line 69: if v:version >= 704[J

line 70:   function! airline#util#getwinvar(winnr, key, def)[J

line 73: else[J

line 74:   function! airline#util#getwinvar(winnr, key, def)[J

line 78: endif[J

line 79: [J

line 80: if v:version >= 704[J

line 81:   function! airline#util#exec_funcrefs(list, ...)[J

line 90: else[J

line 91:   function! airline#util#exec_funcrefs(list, ...)[J

line 103: endif[J

line 104: [J

line 105: " Compatibility wrapper for strchars, in case this vim version does not[J

line 106: " have it natively[J

line 107: function! airline#util#strchars(str)[J

line 114: [J

line 115: function! airline#util#strcharpart(...)[J

line 123: [J

line 124: function! airline#util#ignore_buf(name)[J

line 130: [J

line 131: function! airline#util#has_fugitive()[J

line 137: [J

line 138: function! airline#util#has_lawrencium()[J

line 144: [J

line 145: function! airline#util#has_vcscommand()[J

line 151: [J

line 152: function! airline#util#has_custom_scm()[J

line 155: [J

line 156: function! airline#util#doautocmd(event)[J

line 159: [J

line 160: function! airline#util#themes(match)[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-airline/autoload/airline/util.vim[J
continuing in function <SNR>23_airline_toggle[J
calling function <SNR>23_airline_toggle[82]..airline#util#doautocmd[J('AirlineToggledOn')

line 1:   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)[J

line 1: silent doautocmd <nomodeline> User AirlineToggledOn[J

function <SNR>23_airline_toggle[82]..airline#util#doautocmd returning #0[J

continuing in function <SNR>23_airline_toggle[J

line 83:   endif[J

function <SNR>23_airline_toggle returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vim-airline/plugin/airline.vim[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-airline/plugin/airline.vim[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-commentary/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/vim-commentary/plugin/commentary.vim"[J
line 1: " commentary.vim - Comment stuff out[J

line 2: " Maintainer:   Tim Pope <http://tpo.pe/>[J

line 3: " Version:      1.3[J

line 4: " GetLatestVimScripts: 3695 1 :AutoInstall: commentary.vim[J

line 5: [J

line 6: if exists("g:loaded_commentary") || v:version < 700[J

line 7:   finish[J

line 8: endif[J

line 9: let g:loaded_commentary = 1[J

line 10: [J

line 11: function! s:surroundings() abort[J

line 15: [J

line 16: function! s:strip_white_space(l,r,line) abort[J

line 26: [J

line 27: function! s:go(...) abort[J

line 70: [J

line 71: function! s:textobject(inner) abort[J

line 91: [J

line 92: command! -range -bar Commentary call s:go(<line1>,<line2>)[J

line 93: xnoremap <expr>   <Plug>Commentary     <SID>go()[J

line 94: nnoremap <expr>   <Plug>Commentary     <SID>go()[J

line 95: nnoremap <expr>   <Plug>CommentaryLine <SID>go() . '_'[J

line 96: onoremap <silent> <Plug>Commentary        :<C-U>call <SID>textobject(get(v:, 'operator', '') ==# 'c')<CR>[J

line 97: nnoremap <silent> <Plug>ChangeCommentary c:<C-U>call <SID>textobject(1)<CR>[J

line 98: nmap <silent> <Plug>CommentaryUndo :echoerr "Change your <Plug>CommentaryUndo map to <Plug>Commentary<Plug>Commentary"<CR>[J

line 99: [J

line 100: if !hasmapto('<Plug>Commentary') || maparg('gc','n') ==# ''[J

line 101:   xmap gc  <Plug>Commentary[J

line 102:   nmap gc  <Plug>Commentary[J

line 103:   omap gc  <Plug>Commentary[J

line 104:   nmap gcc <Plug>CommentaryLine[J

line 105:   if maparg('c','n') ==# '' && !exists('v:operator')[J

line 106:     nmap cgc <Plug>ChangeCommentary[J

line 107:   endif[J

line 108:   nmap gcu <Plug>Commentary<Plug>Commentary[J

line 109: endif[J

line 110: [J

line 111: " vim:set et sw=2:[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-commentary/plugin/commentary.vim[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-startify/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/vim-startify/plugin/startify.vim"[J
line 1: " vim: et sw=2 sts=2[J

line 2: [J

line 3: " Plugin:      https://github.com/mhinz/vim-startify[J

line 4: " Description: A fancy start screen for Vim.[J

line 5: " Maintainer:  Marco Hinz <http://github.com/mhinz>[J

line 6: [J

line 7: if exists('g:loaded_startify') || &cp[J

line 8:   finish[J

line 9: endif[J

line 10: let g:loaded_startify = 1[J

line 11: let g:startify_locked = 0[J

line 12: [J

line 13: if !get(g:, 'startify_disable_at_vimenter') && (!has('nvim') || has('nvim-0.3.5'))[J

line 14:   " Only for Nvim v0.3.5+: https://github.com/neovim/neovim/issues/9885[J

line 15:   set shortmess+=I[J

line 16: endif[J

line 17: [J

line 18: augroup startify[J

line 19:   autocmd VimEnter    * nested call s:on_vimenter()[J

line 20:   autocmd VimLeavePre * nested call s:on_vimleavepre()[J

line 21:   autocmd QuickFixCmdPre  *vimgrep* let g:startify_locked = 1[J

line 22:   autocmd QuickFixCmdPost *vimgrep* let g:startify_locked = 0[J

line 23: augroup END[J

line 24: [J

line 25: function! s:update_oldfiles(file)[J

line 35: [J

line 36: function! s:on_vimenter()[J

line 51: [J

line 52: function! s:on_vimleavepre()[J

line 59: [J

line 60: command! -nargs=? -bar -bang -complete=customlist,startify#session_list SLoad   call startify#session_load(<bang>0, <f-args>)[J

line 61: command! -nargs=? -bar -bang -complete=customlist,startify#session_list SSave   call startify#session_save(<bang>0, <f-args>)[J

line 62: command! -nargs=? -bar -bang -complete=customlist,startify#session_list SDelete call startify#session_delete(<bang>0, <f-args>)[J

line 63: command! -nargs=0 -bar SClose call startify#session_close()[J

line 64: command! -nargs=0 -bar Startify call startify#insane_in_the_membrane(0)[J

line 65: command! -nargs=0 -bar StartifyDebug call startify#debug()[J

line 66: [J

line 67: nnoremap <silent><plug>(startify-open-buffers) :<c-u>call startify#open_buffers()<cr>[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-startify/plugin/startify.vim[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-highlightedyank/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/vim-highlightedyank/plugin/highlightedyank.vim"[J
line 1: " highlighted-yank: Make the yanked region apparent![J

line 2: " Last Change: 15-Mar-2018.[J

line 3: " Maintainer : Masaaki Nakamura <mckn@outlook.com>[J

line 4: [J

line 5: " License    : NYSL[J

line 6: "              Japanese <http://www.kmonos.net/nysl/>[J

line 7: "              English (Unofficial) <http://www.kmonos.net/nysl/index.en.html>[J

line 8: if exists("g:loaded_highlightedyank")[J

line 9:   finish[J

line 10: endif[J

line 11: let g:loaded_highlightedyank = 1[J

line 12: [J

line 13: " highlight group[J

line 14: function! s:default_highlight() abort[J

line 17: call s:default_highlight()[J

calling function <SNR>30_default_highlight[J()

line 1:   highlight default link HighlightedyankRegion IncSearch[J

function <SNR>30_default_highlight returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vim-highlightedyank/plugin/highlightedyank.vim[J

line 18: augroup highlightedyank-event-ColorScheme[J

line 19:   autocmd![J

line 20:   autocmd ColorScheme * call s:default_highlight()[J

line 21: augroup END[J

line 22: [J

line 23: if exists('##TextYankPost') && !hasmapto('<Plug>(highlightedyank)') && !exists('g:highlightedyank_disable_autocmd')[J

line 24:   augroup highlightedyank[J

line 25:     autocmd![J

line 26:     autocmd TextYankPost * call highlightedyank#debounce()[J

line 27:   augroup END[J

line 28: [J

line 29:   " commands[J

line 30:   command! -nargs=0 -bar HighlightedyankOn     call highlightedyank#on()[J

line 31:   command! -nargs=0 -bar HighlightedyankOff    call highlightedyank#off()[J

line 32:   command! -nargs=0 -bar HighlightedyankToggle call highlightedyank#toggle()[J

line 33: else[J

line 34:   function! s:keymap() abort[J

line 47:   call s:keymap()[J

calling function <SNR>30_keymap[J()

line 1:     if stridx(&cpoptions, 'y') < 0[J

line 2:       nnoremap <silent> <Plug>(highlightedyank) :<C-u>call highlightedyank#obsolete#highlightedyank#yank('n')<CR>[J

line 3:       xnoremap <silent> <Plug>(highlightedyank) :<C-u>call highlightedyank#obsolete#highlightedyank#yank('x')<CR>[J

line 4:       onoremap          <Plug>(highlightedyank) y[J

line 5:     else[J

line 6:       noremap  <silent> <Plug>(highlightedyank-g@) g@[J

line 7:       noremap  <expr>   <Plug>(highlightedyank-setoperatorfunc) highlightedyank#obsolete#highlightedyank#setoperatorfunc()[J

line 8:       nmap     <silent> <Plug>(highlightedyank) <Plug>(highlightedyank-setoperatorfunc)<Plug>(highlightedyank-g@)[J

line 9:       xmap     <silent> <Plug>(highlightedyank) <Plug>(highlightedyank-setoperatorfunc)<Plug>(highlightedyank-g@)[J

line 10:       onoremap          <Plug>(highlightedyank) g@[J

line 11:     endif[J

function <SNR>30_keymap returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vim-highlightedyank/plugin/highlightedyank.vim[J

line 48: [J

line 49:   if exists('##OptionSet')[J

line 50:     augroup highlightedyank-event-OptionSet[J

line 51:       autocmd![J

line 52:       autocmd OptionSet cpoptions call s:keymap()[J

line 53:     augroup END[J

line 54:   endif[J

line 55: [J

line 56:   " commands[J

line 57:   command! -nargs=0 -bar HighlightedyankOn     call highlightedyank#obsolete#highlightedyank#on()[J

line 58:   command! -nargs=0 -bar HighlightedyankOff    call highlightedyank#obsolete#highlightedyank#off()[J

line 59:   command! -nargs=0 -bar HighlightedyankToggle call highlightedyank#obsolete#highlightedyank#toggle()[J

line 60: endif[J

line 61: [J

finished sourcing /Users/ygarrot/.vim/plugged/vim-highlightedyank/plugin/highlightedyank.vim[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/autoloclist.vim"[J
line 1: if exists('g:loaded_syntastic_notifier_autoloclist') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/autoloclist.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/balloons.vim"[J
line 1: if exists('g:loaded_syntastic_notifier_balloons') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/balloons.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/checker.vim"[J
line 1: if exists('g:loaded_syntastic_checker') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/checker.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/cursor.vim"[J
line 1: if exists('g:loaded_syntastic_notifier_cursor') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/cursor.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/highlighting.vim"[J
line 1: if exists('g:loaded_syntastic_notifier_highlighting') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/highlighting.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/loclist.vim"[J
line 1: if exists('g:loaded_syntastic_loclist') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/loclist.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/modemap.vim"[J
line 1: if exists('g:loaded_syntastic_modemap') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/modemap.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/notifiers.vim"[J
line 1: if exists('g:loaded_syntastic_notifiers') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/notifiers.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/registry.vim"[J
line 1: if exists('g:loaded_syntastic_registry') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/registry.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/signs.vim"[J
line 1: if exists('g:loaded_syntastic_notifier_signs') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/signs.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim"[J
line 1: "============================================================================[J

line 2: "File:        syntastic.vim[J

line 3: "Description: Vim plugin for on the fly syntax checking.[J

line 4: "License:     This program is free software. It comes without any warranty,[J

line 5: "             to the extent permitted by applicable law. You can redistribute[J

line 6: "             it and/or modify it under the terms of the Do What The Fuck You[J

line 7: "             Want To Public License, Version 2, as published by Sam Hocevar.[J

line 8: "             See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 9: "[J

line 10: "============================================================================[J

line 11: [J

line 12: if exists('g:loaded_syntastic_plugin') || &compatible[J

line 13:     finish[J

line 14: endif[J

line 15: let g:loaded_syntastic_plugin = 1[J

line 16: [J

line 17: if has('reltime')[J

line 18:     let g:_SYNTASTIC_START = reltime()[J

line 19:     lockvar! g:_SYNTASTIC_START[J

line 20: endif[J

line 21: [J

line 22: let g:_SYNTASTIC_VERSION = '3.9.0-44'[J

line 23: lockvar g:_SYNTASTIC_VERSION[J

line 24: [J

line 25: " Sanity checks {{{1[J

line 26: [J

line 27: if v:version < 700 || (v:version == 700 && !has('patch175'))[J

line 28:     call syntastic#log#error('need Vim version 7.0.175 or later')[J

line 29:     finish[J

line 30: endif[J

line 31: [J

line 41: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'statusline', 'user_commands', ][J

line 42:     if !has(s:feature)[J

line 43:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)[J

line 44:         finish[J

line 45:     endif[J

line 46: endfor[J

line 41: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'statusline', 'user_commands', ][J

line 42:     if !has(s:feature)[J

line 43:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)[J

line 44:         finish[J

line 45:     endif[J

line 46: endfor[J

line 41: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'statusline', 'user_commands', ][J

line 42:     if !has(s:feature)[J

line 43:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)[J

line 44:         finish[J

line 45:     endif[J

line 46: endfor[J

line 41: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'statusline', 'user_commands', ][J

line 42:     if !has(s:feature)[J

line 43:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)[J

line 44:         finish[J

line 45:     endif[J

line 46: endfor[J

line 41: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'statusline', 'user_commands', ][J

line 42:     if !has(s:feature)[J

line 43:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)[J

line 44:         finish[J

line 45:     endif[J

line 46: endfor[J

line 41: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'statusline', 'user_commands', ][J

line 42:     if !has(s:feature)[J

line 43:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)[J

line 44:         finish[J

line 45:     endif[J

line 46: endfor[J

line 41: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'statusline', 'user_commands', ][J

line 42:     if !has(s:feature)[J

line 43:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)[J

line 44:         finish[J

line 45:     endif[J

line 46: endfor[J

line 41: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'statusline', 'user_commands', ][J

line 42:     if !has(s:feature)[J

line 43:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)[J

line 44:         finish[J

line 45:     endif[J

line 46: endfor[J

line 41: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'statusline', 'user_commands', ][J

line 42:     if !has(s:feature)[J

line 43:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)[J

line 44:         finish[J

line 45:     endif[J

line 46: endfor[J

line 47: [J

line 48: let s:_running_windows = syntastic#util#isRunningWindows()[J

Searching for "autoload/syntastic/util.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/autoload/syntastic/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/autoload/syntastic/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/autoload/syntastic/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/autoload/syntastic/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/autoload/syntastic/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/autoload/syntastic/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/autoload/syntastic/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/autoload/syntastic/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/autoload/syntastic/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/autoload/syntastic/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/autoload/syntastic/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/autoload/syntastic/util.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/autoload/syntastic/util.vim"[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/autoload/syntastic)[J
fchdir() to previous dir[J
line 48: sourcing "/Users/ygarrot/.vim/plugged/syntastic/autoload/syntastic/util.vim"[J
line 1: if exists('g:loaded_syntastic_util_autoload') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_syntastic_util_autoload = 1[J

line 5: [J

line 6: let s:save_cpo = &cpo[J

line 7: set cpo&vim[J

line 8: [J

line 9: " Public functions {{{1[J

line 10: [J

line 11: function! syntastic#util#isRunningWindows() abort " {{{2[J

line 14: [J

line 15: function! syntastic#util#DevNull() abort " {{{2[J

line 21: [J

line 22: " Get directory separator[J

line 23: function! syntastic#util#Slash() abort " {{{2[J

line 26: [J

line 27: function! syntastic#util#CygwinPath(path) abort " {{{2[J

line 30: [J

line 31: function! syntastic#util#system(command) abort " {{{2[J

line 71: [J

line 72: " Create a temporary directory[J

line 73: function! syntastic#util#tmpdir() abort " {{{2[J

line 106: [J

line 107: " Recursively remove a directory[J

line 108: function! syntastic#util#rmrf(what) abort " {{{2[J

line 120: [J

line 121: function! syntastic#util#getbufvar(buf, name, ...) abort " {{{2[J

line 124: [J

line 125: " Search the first 5 lines of the file for a magic number and return a map[J

line 126: " containing the args and the executable[J

line 127: "[J

line 128: " e.g.[J

line 129: "[J

line 130: " #!/usr/bin/perl -f -bar[J

line 131: "[J

line 132: " returns[J

line 133: "[J

line 134: " {'exe': '/usr/bin/perl', 'args': ['-f', '-bar']}[J

line 135: function! syntastic#util#parseShebang(buf) abort " {{{2[J

line 148: [J

line 149: " Get the value of a Vim variable.  Allow buffer variables to override global ones.[J

line 150: function! syntastic#util#bufRawVar(buf, name, ...) abort " {{{2[J

line 153: [J

line 154: " Get the value of a syntastic variable.  Allow buffer variables to override global ones.[J

line 155: function! syntastic#util#bufVar(buf, name, ...) abort " {{{2[J

line 158: [J

line 159: " Get the value of a Vim variable.  Allow local variables to override global ones.[J

line 160: function! syntastic#util#rawVar(name, ...) abort " {{{2[J

line 163: [J

line 164: " Get the value of a syntastic variable.  Allow local variables to override global ones.[J

line 165: function! syntastic#util#var(name, ...) abort " {{{2[J

line 168: [J

line 169: " Parse a version string.  Return an array of version components.[J

line 170: function! syntastic#util#parseVersion(version, ...) abort " {{{2[J

line 173: [J

line 174: " Verify that the 'installed' version is at least the 'required' version.[J

line 175: "[J

line 176: " 'installed' and 'required' must be arrays. If they have different lengths,[J

line 177: " the "missing" elements will be assumed to be 0 for the purposes of checking.[J

line 178: "[J

line 179: " See http://semver.org for info about version numbers.[J

line 180: function! syntastic#util#versionIsAtLeast(installed, required) abort " {{{2[J

line 183: [J

line 184: " Almost lexicographic comparison of two lists of integers. :) If lists[J

line 185: " have different lengths, the "missing" elements are assumed to be 0.[J

line 186: function! syntastic#util#compareLexi(a, b) abort " {{{2[J

line 197: [J

line 198: function! syntastic#util#screenWidth(str, tabstop) abort " {{{2[J

line 207: [J

line 208: " Print as much of a:msg as possible without "Press Enter" prompt appearing[J

line 209: function! syntastic#util#wideMsg(msg) abort " {{{2[J

line 231: [J

line 232: " Check whether a buffer is loaded, listed, and not hidden[J

line 233: function! syntastic#util#bufIsActive(buffer) abort " {{{2[J

line 250: [J

line 251: " Start in directory a:where and walk up the parent folders until it finds a[J

line 252: " file named a:what; return path to that file[J

line 253: function! syntastic#util#findFileInParent(what, where) abort " {{{2[J

line 260: [J

line 261: " Start in directory a:where and walk up the parent folders until it finds a[J

line 262: " file matching a:what; return path to that file[J

line 263: function! syntastic#util#findGlobInParent(what, where) abort " {{{2[J

line 298: [J

line 299: " Returns the buffer number of a filename[J

line 300: " @vimlint(EVL104, 1, l:old_shellslash)[J

line 301: function! syntastic#util#fname2buf(fname) abort " {{{2[J

line 333: " @vimlint(EVL104, 0, l:old_shellslash)[J

line 334: [J

line 335: " Returns unique elements in a list[J

line 336: function! syntastic#util#unique(list) abort " {{{2[J

line 348: [J

line 349: " A less noisy shellescape()[J

line 350: function! syntastic#util#shescape(string) abort " {{{2[J

line 353: [J

line 354: " A less noisy shellescape(expand())[J

line 355: function! syntastic#util#shexpand(string, ...) abort " {{{2[J

line 358: [J

line 359: " Escape arguments[J

line 360: function! syntastic#util#argsescape(opt) abort " {{{2[J

line 369: [J

line 370: " Decode XML entities[J

line 371: function! syntastic#util#decodeXMLEntities(string) abort " {{{2[J

line 380: [J

line 381: function! syntastic#util#redraw(full) abort " {{{2[J

line 388: [J

line 389: function! syntastic#util#dictFilter(errors, filter) abort " {{{2[J

line 399: [J

line 400: " Return a [seconds, fractions] list of strings, representing the[J

line 401: " (hopefully high resolution) time since program start[J

line 402: function! syntastic#util#stamp() abort " {{{2[J

line 405: [J

line 406: function! syntastic#util#setLastTick(buf) abort " {{{2[J

line 409: [J

line 410: " Add unique IDs to windows[J

line 411: function! syntastic#util#setWids() abort " {{{2[J

line 421: [J

line 422: function! syntastic#util#str2float(val) abort " {{{2[J

line 425: [J

line 426: function! syntastic#util#float2str(val) abort " {{{2[J

line 429: [J

line 430: " Crude printf()-like width formatter.  Handles wide characters.[J

line 431: function! syntastic#util#wformat(format, str) abort " {{{2[J

line 484: [J

line 485: " }}}1[J

line 486: [J

line 487: " Private functions {{{1[J

line 488: [J

line 489: function! s:_translateFilter(filters) abort " {{{2[J

line 504: [J

line 505: function! s:_translateElement(key, term) abort " {{{2[J

line 542: [J

line 543: " strwidth() was added in Vim 7.3; if it doesn't exist, we use strlen()[J

line 544: " and hope for the best :)[J

line 545: let s:_width = function(exists('*strwidth') ? 'strwidth' : 'strlen')[J

line 546: lockvar s:_width[J

line 547: [J

line 548: " @vimlint(EVL103, 1, a:flags)[J

line 549: function! s:_delete_dumb(what, flags) abort " {{{2[J

line 563: " @vimlint(EVL103, 0, a:flags)[J

line 564: [J

line 565: " delete(dir, 'rf') was added in Vim 7.4.1107, but it didn't become usable until 7.4.1128[J

line 566: let s:_delete = function(v:version > 704 || (v:version == 704 && has('patch1128')) ? 'delete' : 's:_delete_dumb')[J

line 567: lockvar s:_delete[J

line 568: [J

line 569: function! s:_rmrf(what) abort " {{{2[J

line 593: [J

line 594: let s:_str2float = function(exists('*str2float') ? 'str2float' : 'str2nr')[J

line 595: lockvar s:_str2float[J

line 596: [J

line 597: function! s:_float2str_smart(val) abort " {{{2[J

line 600: [J

line 601: function! s:_float2str_dumb(val) abort " {{{2[J

line 604: [J

line 605: let s:_float2str = function(has('float') ? 's:_float2str_smart' : 's:_float2str_dumb')[J

line 606: lockvar s:_float2str[J

line 607: [J

line 608: function! s:_getbufvar_dumb(buf, name, ...) abort " {{{2[J

line 616: [J

line 617: let s:_getbufvar = function(v:version > 703 || (v:version == 703 && has('patch831')) ? 'getbufvar' : 's:_getbufvar_dumb')[J

line 618: lockvar s:_getbufvar[J

line 619: [J

line 620: function! s:_fuzz_dumb() abort " {{{2[J

line 623: [J

line 624: let s:_fuzz = function(exists('*getpid') ? 'getpid' : 's:_fuzz_dumb')[J

line 625: lockvar s:_fuzz[J

line 626: [J

line 627: " }}}1[J

line 628: [J

line 629: let s:_wid_base = 'syntastic_' . s:_fuzz() . '_' . reltimestr(g:_SYNTASTIC_START) . '_'[J

line 630: let s:_wid_pool = 0[J

line 631: [J

line 632: let &cpo = s:save_cpo[J

line 633: unlet s:save_cpo[J

line 634: [J

line 635: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/autoload/syntastic/util.vim[J
continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J
calling function syntastic#util#isRunningWindows[J()

line 1:     return has('win16') || has('win32') || has('win64')[J

function syntastic#util#isRunningWindows returning #0[J

continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J

line 49: lockvar s:_running_windows[J

line 50: [J

line 51: if !exists('g:syntastic_shell')[J

line 52:     let g:syntastic_shell = &shell[J

line 53: endif[J

line 54: [J

line 55: if s:_running_windows[J

line 56:     let g:_SYNTASTIC_UNAME = 'Windows'[J

line 57: elseif executable('uname')[J

line 58:     try[J

line 59:         let g:_SYNTASTIC_UNAME = split(syntastic#util#system('uname'), "\n")[0][J

calling function syntastic#util#system[J('uname')

line 1:     let old_shell = &shell[J

line 2:     let old_lc_messages = $LC_MESSAGES[J

line 3:     let old_lc_all = $LC_ALL[J

line 4: [J

line 5:     let &shell = syntastic#util#var('shell')[J

calling function syntastic#util#system[5]..syntastic#util#var[J('shell')

line 1:     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)[J

calling function syntastic#util#system[5]..syntastic#util#var[1]..syntastic#util#rawVar[J('syntastic_shell')

line 1:     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))[J

function syntastic#util#system[5]..syntastic#util#var[1]..syntastic#util#rawVar returning '/bin/zsh'[J

continuing in function syntastic#util#system[5]..syntastic#util#var[J

function syntastic#util#system[5]..syntastic#util#var returning '/bin/zsh'[J

continuing in function syntastic#util#system[J

line 6:     let $LC_MESSAGES = 'C'[J

line 7:     let $LC_ALL = ''[J

line 8: [J

line 9:     let crashed = 0[J

line 10:     let cmd_start = reltime()[J

line 11:     try[J

line 12:         let out = system(a:command)[J

Calling shell to execute: "(uname) > /var/folders/zz/zyxvpxvq6csfxvn_n0002zlh000qww/T/vwkQJqg/0"[J
[?12l[?25h
line 13:     catch[?25l[J

line 14:         let crashed = 1[J

line 15:         call syntastic#log#error('exception running system(' . string(a:command) . '): ' . v:exception)[J

line 16:         if syntastic#util#isRunningWindows()[J

line 17:             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))[J

line 18:         else[J

line 19:             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))[J

line 20:             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))[J

line 21:         endif[J

line 22:         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '$PATH = ' . string($PATH))[J

line 23:         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))[J

line 24:         call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)[J

line 25:         let out = ''[J

line 26:     endtry[J

line 27:     let cmd_time = split(reltimestr(reltime(cmd_start)))[0][J

line 28: [J

line 29:     let $LC_ALL = old_lc_all[J

line 30:     let $LC_MESSAGES = old_lc_messages[J

line 31: [J

line 32:     let &shell = old_shell[J

line 33: [J

line 34:     if !crashed && exists('g:_SYNTASTIC_DEBUG_TRACE')[J

line 35:         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'system: command run in ' . cmd_time . 's')[J

line 36:     endif[J

line 37: [J

line 38:     return out[J

function syntastic#util#system returning 'Darwin^@'[J

continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J

line 60:     catch /\m^Vim\%((\a\+)\)\=:E484/[J

line 61:         call syntastic#log#error("can't run external programs (misconfigured shell options?)")[J

line 62:         finish[J

line 63:     catch /\m^Vim\%((\a\+)\)\=:E684/[J

line 64:         let g:_SYNTASTIC_UNAME = 'Unknown'[J

line 65:     endtry[J

line 66: else[J

line 67:     let g:_SYNTASTIC_UNAME = 'Unknown'[J

line 68: endif[J

line 69: lockvar g:_SYNTASTIC_UNAME[J

line 70: [J

line 71: " XXX Ugly hack to make g:_SYNTASTIC_UNAME available to :SyntasticInfo without[J

line 72: " polluting session namespaces[J

line 77: let g:syntastic_version = g:_SYNTASTIC_VERSION . ' (Vim ' . v:version . (has('nvim') ? ', Neovim' : '') . ', ' . g:_SYNTASTIC_UNAME . (has('gui') ? ', GUI' : '') . ')'[J

line 78: lockvar g:syntastic_version[J

line 79: [J

line 80: " }}}1[J

line 81: [J

line 82: " Defaults {{{1[J

line 83: [J

line 114: let g:_SYNTASTIC_DEFAULTS = { 'aggregate_errors':         0, 'always_populate_loc_list': 0, 'auto_jump':                0, 'auto_loc_list':            2, 'check_on_open':            0, 'check_on_wq':              1, 'cursor_columns':           1, 'debug':                    0, 'echo_current_error':       1, 'enable_balloons':          1, 'enable_highlighting':      1, 'enable_signs':             1, 'error_symbol':             '>>', 'exit_checks':              !(s:_running_windows && syntastic#util#var('shell', &shell) =~? '\m\<cmd\.exe$'), 'filetype_map':             {}, 'full_redraws':             !(has('gui_running') || has('gui_macvim')), 'id_checkers':              1, 'ignore_extensions':        '\c\v^([gx]?z|lzma|bz2)$', 'ignore_files':             [], 'loc_list_height':          10, 'nested_autocommands':      0, 'quiet_messages':           {}, 'reuse_loc_lists':          1, 'shell':                    &shell, 'sort_aggregated_errors':   1, 'stl_format':               '[Syntax: line:%F (%t)]',[J

line 115: lockvar! g:_SYNTASTIC_DEFAULTS[J

line 116: [J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 117: for s:key in keys(g:_SYNTASTIC_DEFAULTS)[J

line 118:     if !exists('g:syntastic_' . s:key)[J

line 119:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])[J

line 120:     endif[J

line 121: endfor[J

line 122: [J

line 123: if exists('g:syntastic_quiet_warnings')[J

line 124:     call syntastic#log#oneTimeWarn("variable g:syntastic_quiet_warnings is deprecated, please use let g:syntastic_quiet_messages = {'level': 'warnings'} instead")[J

line 125:     if g:syntastic_quiet_warnings[J

line 126:         let s:quiet_warnings = get(g:syntastic_quiet_messages, 'type', [])[J

line 127:         if type(s:quiet_warnings) != type([])[J

line 128:             let s:quiet_warnings = [s:quiet_warnings][J

line 129:         endif[J

line 130:         call add(s:quiet_warnings, 'warnings')[J

line 131:         let g:syntastic_quiet_messages['type'] = s:quiet_warnings[J

line 132:     endif[J

line 133: endif[J

line 134: [J

line 135: " }}}1[J

line 136: [J

line 137: " Debug {{{1[J

line 138: [J

line 147: let g:_SYNTASTIC_SHELL_OPTIONS = [ 'shell', 'shellcmdflag', 'shellpipe', 'shellquote', 'shellredir', 'shelltemp', 'shellxquote' ][J

line 152: for s:feature in [ 'autochdir', 'shellslash', 'shellxescape', ][J

line 153: [J

line 154:     if exists('+' . s:feature)[J

line 155:         call add(g:_SYNTASTIC_SHELL_OPTIONS, s:feature)[J

line 156:     endif[J

line 157: endfor[J

line 152: for s:feature in [ 'autochdir', 'shellslash', 'shellxescape', ][J

line 153: [J

line 154:     if exists('+' . s:feature)[J

line 155:         call add(g:_SYNTASTIC_SHELL_OPTIONS, s:feature)[J

line 156:     endif[J

line 157: endfor[J

line 152: for s:feature in [ 'autochdir', 'shellslash', 'shellxescape', ][J

line 153: [J

line 154:     if exists('+' . s:feature)[J

line 155:         call add(g:_SYNTASTIC_SHELL_OPTIONS, s:feature)[J

line 156:     endif[J

line 157: endfor[J

line 152: for s:feature in [ 'autochdir', 'shellslash', 'shellxescape', ][J

line 153: [J

line 154:     if exists('+' . s:feature)[J

line 155:         call add(g:_SYNTASTIC_SHELL_OPTIONS, s:feature)[J

line 156:     endif[J

line 157: endfor[J

line 158: lockvar! g:_SYNTASTIC_SHELL_OPTIONS[J

line 159: [J

line 160: " debug constants[J

line 161: let     g:_SYNTASTIC_DEBUG_TRACE         = 1[J

line 162: lockvar g:_SYNTASTIC_DEBUG_TRACE[J

line 163: let     g:_SYNTASTIC_DEBUG_LOCLIST       = 2[J

line 164: lockvar g:_SYNTASTIC_DEBUG_LOCLIST[J

line 165: let     g:_SYNTASTIC_DEBUG_NOTIFICATIONS = 4[J

line 166: lockvar g:_SYNTASTIC_DEBUG_NOTIFICATIONS[J

line 167: let     g:_SYNTASTIC_DEBUG_AUTOCOMMANDS  = 8[J

line 168: lockvar g:_SYNTASTIC_DEBUG_AUTOCOMMANDS[J

line 169: let     g:_SYNTASTIC_DEBUG_VARIABLES     = 16[J

line 170: lockvar g:_SYNTASTIC_DEBUG_VARIABLES[J

line 171: let     g:_SYNTASTIC_DEBUG_CHECKERS      = 32[J

line 172: lockvar g:_SYNTASTIC_DEBUG_CHECKERS[J

line 173: [J

line 174: " }}}1[J

line 175: [J

line 176: runtime! plugin/syntastic/*.vim[J

Searching for "plugin/syntastic/*.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
line 176: sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/autoloclist.vim"[J
line 1: if exists('g:loaded_syntastic_notifier_autoloclist') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_syntastic_notifier_autoloclist = 1[J

line 5: [J

line 6: let g:SyntasticAutoloclistNotifier = {}[J

line 7: [J

line 8: " Public methods {{{1[J

line 9: "[J

line 10: function! g:SyntasticAutoloclistNotifier.New() abort " {{{2[J

line 14: [J

line 15: function! g:SyntasticAutoloclistNotifier.refresh(loclist) abort " {{{2[J

line 19: [J

line 20: function! g:SyntasticAutoloclistNotifier.AutoToggle(loclist) abort " {{{2[J

line 52: [J

line 53: " }}}1[J

line 54: [J

line 55: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/autoloclist.vim[J
continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
line 176: sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/balloons.vim"[J
line 1: if exists('g:loaded_syntastic_notifier_balloons') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_syntastic_notifier_balloons = 1[J

line 5: [J

line 6: if !has('balloon_eval')[J

line 7:     let g:syntastic_enable_balloons = 0[J

line 8: endif[J

line 9: [J

line 10: let g:SyntasticBalloonsNotifier = {}[J

line 11: [J

line 12: " Public methods {{{1[J

line 13: [J

line 14: function! g:SyntasticBalloonsNotifier.New() abort " {{{2[J

line 18: [J

line 19: function! g:SyntasticBalloonsNotifier.enabled() abort " {{{2[J

line 22: [J

line 23: " Update the error balloons[J

line 24: function! g:SyntasticBalloonsNotifier.refresh(loclist) abort " {{{2[J

line 33: [J

line 34: " Reset the error balloons[J

line 35: " @vimlint(EVL103, 1, a:loclist)[J

line 36: function! g:SyntasticBalloonsNotifier.reset(loclist) abort " {{{2[J

line 43: " @vimlint(EVL103, 0, a:loclist)[J

line 44: [J

line 45: " }}}1[J

line 46: [J

line 47: " Private functions {{{1[J

line 48: [J

line 49: function! SyntasticBalloonsExprNotifier() abort " {{{2[J

line 55: [J

line 56: " }}}1[J

line 57: [J

line 58: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/balloons.vim[J
continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
line 176: sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/checker.vim"[J
line 1: if exists('g:loaded_syntastic_checker') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_syntastic_checker = 1[J

line 5: [J

line 6: let g:SyntasticChecker = {}[J

line 7: [J

line 8: " Public methods {{{1[J

line 9: [J

line 10: function! g:SyntasticChecker.New(args, ...) abort " {{{2[J

line 59: [J

line 60: function! g:SyntasticChecker.getFiletype() abort " {{{2[J

line 63: [J

line 64: function! g:SyntasticChecker.getName() abort " {{{2[J

line 67: [J

line 68: function! g:SyntasticChecker.getCName() abort " {{{2[J

line 71: [J

line 72: " Synchronise _exec with user's setting.  Force re-validation if needed.[J

line 73: "[J

line 74: " XXX: This function must be called at least once before calling either[J

line 75: " getExec() or getExecEscaped().  Normally isAvailable() does that for you[J

line 76: " automatically, but you should keep still this in mind if you change the[J

line 77: " current checker workflow.[J

line 78: function! g:SyntasticChecker.syncExec(...) abort " {{{2[J

line 88: [J

line 89: function! g:SyntasticChecker.getExec() abort " {{{2[J

line 92: [J

line 93: function! g:SyntasticChecker.getExecEscaped() abort " {{{2[J

line 96: [J

line 97: function! g:SyntasticChecker.getLocListRaw() abort " {{{2[J

line 140: [J

line 141: function! g:SyntasticChecker.getLocList() abort " {{{2[J

line 144: [J

line 145: function! g:SyntasticChecker.getVersion(...) abort " {{{2[J

line 162: [J

line 163: function! g:SyntasticChecker.setVersion(version) abort " {{{2[J

line 169: [J

line 170: function! g:SyntasticChecker.log(msg, ...) abort " {{{2[J

line 178: [J

line 179: function! g:SyntasticChecker.makeprgBuild(opts) abort " {{{2[J

line 191: [J

line 192: function! g:SyntasticChecker.isAvailable() abort " {{{2[J

line 204: [J

line 205: function! g:SyntasticChecker.isDisabled() abort " {{{2[J

line 208: [J

line 209: function! g:SyntasticChecker.wantSort() abort " {{{2[J

line 212: [J

line 213: " This method is no longer used by syntastic.  It's here only to maintain[J

line 214: " backwards compatibility with external checkers which might depend on it.[J

line 215: function! g:SyntasticChecker.setWantSort(val) abort " {{{2[J

line 220: [J

line 221: " }}}1[J

line 222: [J

line 223: " Private methods {{{1[J

line 224: [J

line 225: function! g:SyntasticChecker._quietMessages(errors) abort " {{{2[J

line 249: [J

line 250: function! g:SyntasticChecker._populateHighlightRegexes(errors) abort " {{{2[J

line 262: [J

line 263: function! g:SyntasticChecker._getOpt(opts, basename, name, default) abort " {{{2[J

line 271: [J

line 272: " }}}1[J

line 273: [J

line 274: " Private functions {{{1[J

line 275: [J

line 276: function! s:_isAvailableDefault() dict " {{{2[J

line 279: [J

line 280: " }}}1[J

line 281: [J

line 282: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/checker.vim[J
continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
line 176: sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/cursor.vim"[J
line 1: if exists('g:loaded_syntastic_notifier_cursor') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_syntastic_notifier_cursor = 1[J

line 5: [J

line 6: let g:SyntasticCursorNotifier = {}[J

line 7: [J

line 8: " Public methods {{{1[J

line 9: [J

line 10: function! g:SyntasticCursorNotifier.New() abort " {{{2[J

line 14: [J

line 15: function! g:SyntasticCursorNotifier.enabled() abort " {{{2[J

line 18: [J

line 19: function! g:SyntasticCursorNotifier.refresh(loclist) abort " {{{2[J

line 29: [J

line 30: " @vimlint(EVL103, 1, a:loclist)[J

line 31: function! g:SyntasticCursorNotifier.reset(loclist) abort " {{{2[J

line 37: " @vimlint(EVL103, 0, a:loclist)[J

line 38: [J

line 39: " }}}1[J

line 40: [J

line 41: " Private functions {{{1[J

line 42: [J

line 43: function! SyntasticRefreshCursor() abort " {{{2[J

line 91: [J

line 92: " }}}1[J

line 93: [J

line 94: " Utilities {{{1[J

line 95: [J

line 96: function! s:_is_same_index(line, old_line, column, idx, messages) abort " {{{2[J

line 115: [J

line 116: function! s:_find_index(column, messages) abort " {{{2[J

line 135: [J

line 136: " }}}1[J

line 137: [J

line 138: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/cursor.vim[J
continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
line 176: sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/highlighting.vim"[J
line 1: if exists('g:loaded_syntastic_notifier_highlighting') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_syntastic_notifier_highlighting = 1[J

line 5: [J

line 6: " Highlighting requires getmatches introduced in 7.1.040[J

line 7: let s:has_highlighting = v:version > 701 || (v:version == 701 && has('patch040'))[J

line 8: lockvar s:has_highlighting[J

line 9: [J

line 10: let g:SyntasticHighlightingNotifier = {}[J

line 11: [J

line 12: let s:setup_done = 0[J

line 13: [J

line 14: " Public methods {{{1[J

line 15: [J

line 16: function! g:SyntasticHighlightingNotifier.New() abort " {{{2[J

line 27: [J

line 28: function! g:SyntasticHighlightingNotifier.enabled() abort " {{{2[J

line 31: [J

line 32: " Sets error highlights in the current window[J

line 33: function! g:SyntasticHighlightingNotifier.refresh(loclist) abort " {{{2[J

line 61: [J

line 62: " Remove all error highlights from the window[J

line 63: " @vimlint(EVL103, 1, a:loclist)[J

line 64: function! g:SyntasticHighlightingNotifier.reset(loclist) abort " {{{2[J

line 70: " @vimlint(EVL103, 0, a:loclist)[J

line 71: [J

line 72: " }}}1[J

line 73: [J

line 74: " Private methods {{{1[J

line 75: [J

line 76: " One time setup: define our own highlighting[J

line 77: function! g:SyntasticHighlightingNotifier._setup() abort " {{{2[J

line 93: [J

line 94: function! g:SyntasticHighlightingNotifier._reset() abort " {{{2[J

line 101: [J

line 102: " }}}1[J

line 103: [J

line 104: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/highlighting.vim[J
continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
line 176: sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/loclist.vim"[J
line 1: if exists('g:loaded_syntastic_loclist') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_syntastic_loclist = 1[J

line 5: [J

line 6: let g:SyntasticLoclist = {}[J

line 7: [J

line 8: " Public methods {{{1[J

line 9: [J

line 10: function! g:SyntasticLoclist.New(rawLoclist) abort " {{{2[J

line 29: [J

line 30: function! g:SyntasticLoclist.current(...) abort " {{{2[J

line 39: [J

line 40: function! g:SyntasticLoclist.extend(other) abort " {{{2[J

line 43: [J

line 44: function! g:SyntasticLoclist.sort() abort " {{{2[J

line 55: [J

line 56: function! g:SyntasticLoclist.isEmpty() abort " {{{2[J

line 59: [J

line 60: function! g:SyntasticLoclist.isNewerThan(stamp) abort " {{{2[J

line 67: [J

line 68: function! g:SyntasticLoclist.copyRaw() abort " {{{2[J

line 71: [J

line 72: function! g:SyntasticLoclist.getRaw() abort " {{{2[J

line 75: [J

line 76: function! g:SyntasticLoclist.getBuffers() abort " {{{2[J

line 79: [J

line 80: function! g:SyntasticLoclist.getCursorColumns() abort " {{{2[J

line 83: [J

line 84: function! g:SyntasticLoclist.getStatuslineFlag() abort " {{{2[J

line 138: [J

line 139: function! g:SyntasticLoclist.getFirstError(...) abort " {{{2[J

line 153: [J

line 154: function! g:SyntasticLoclist.getName() abort " {{{2[J

line 157: [J

line 158: function! g:SyntasticLoclist.setName(name) abort " {{{2[J

line 161: [J

line 162: function! g:SyntasticLoclist.getOwner() abort " {{{2[J

line 165: [J

line 166: function! g:SyntasticLoclist.setOwner(buffer) abort " {{{2[J

line 169: [J

line 170: function! g:SyntasticLoclist.deploy() abort " {{{2[J

line 176: [J

line 177: function! g:SyntasticLoclist.destroy() abort " {{{2[J

line 182: [J

line 183: function! g:SyntasticLoclist.decorate(tag) abort " {{{2[J

line 188: [J

line 189: function! g:SyntasticLoclist.balloons() abort " {{{2[J

line 211: [J

line 212: function! g:SyntasticLoclist.errors() abort " {{{2[J

line 218: [J

line 219: function! g:SyntasticLoclist.warnings() abort " {{{2[J

line 225: [J

line 226: " Legacy function.  Syntastic no longer calls it, but we keep it[J

line 227: " around because other plugins (f.i. powerline) depend on it.[J

line 228: function! g:SyntasticLoclist.hasErrorsOrWarningsToDisplay() abort " {{{2[J

line 231: [J

line 232: " cache used by EchoCurrentError()[J

line 233: function! g:SyntasticLoclist.messages(buf) abort " {{{2[J

line 277: [J

line 278: "Filter the list and return new native loclist[J

line 279: "e.g.[J

line 280: "  .filter({'bufnr': 10, 'type': 'e'})[J

line 281: "[J

line 282: "would return all errors for buffer 10.[J

line 283: "[J

line 284: "Note that all string comparisons are done with ==?[J

line 285: function! g:SyntasticLoclist.filter(filters) abort " {{{2[J

line 291: [J

line 292: function! g:SyntasticLoclist.setloclist(new) abort " {{{2[J

line 310: [J

line 311: "display the cached errors for this buf in the location list[J

line 312: function! g:SyntasticLoclist.show() abort " {{{2[J

line 342: [J

line 343: " }}}1[J

line 344: [J

line 345: " Public functions {{{1[J

line 346: [J

line 347: function! SyntasticLoclistHide() abort " {{{2[J

line 351: [J

line 352: " }}}1[J

line 353: [J

line 354: " Utilities {{{1[J

line 355: [J

line 356: function! s:_translate(key, val) abort " {{{2[J

line 359: [J

line 360: function! s:_set_screen_column(item) abort " {{{2[J

line 376: [J

line 377: function! s:_remove_shadowed_items(errors) abort " {{{2[J

line 408: [J

line 409: function! s:_compare_error_items_by_columns(a, b) abort " {{{2[J

line 426: [J

line 427: function! s:_compare_error_items_by_lines(a, b) abort " {{{2[J

line 442: [J

line 443: " }}}1[J

line 444: [J

line 445: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/loclist.vim[J
continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
line 176: sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/modemap.vim"[J
line 1: if exists('g:loaded_syntastic_modemap') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_syntastic_modemap = 1[J

line 5: [J

line 6: let g:SyntasticModeMap = {}[J

line 7: [J

line 8: " Public methods {{{1[J

line 9: [J

line 10: function! g:SyntasticModeMap.Instance() abort " {{{2[J

line 18: [J

line 19: function! g:SyntasticModeMap.synch() abort " {{{2[J

line 30: [J

line 31: function! g:SyntasticModeMap.allowsAutoChecking(filetype) abort " {{{2[J

line 41: [J

line 42: function! g:SyntasticModeMap.doAutoChecking(buf) abort " {{{2[J

line 50: [J

line 51: function! g:SyntasticModeMap.isPassive() abort " {{{2[J

line 54: [J

line 55: function! g:SyntasticModeMap.toggleMode() abort " {{{2[J

line 70: [J

line 71: function! g:SyntasticModeMap.echoMode() abort " {{{2[J

line 74: [J

line 75: function! g:SyntasticModeMap.modeInfo(filetypes) abort " {{{2[J

line 103: [J

line 104: " }}}1[J

line 105: [J

line 106: " Private methods {{{1[J

line 107: [J

line 108: function! g:SyntasticModeMap._isOneFiletypeActive(filetypes) abort " {{{2[J

line 111: [J

line 112: function! g:SyntasticModeMap._noFiletypesArePassive(filetypes) abort " {{{2[J

line 115: [J

line 116: " }}}1[J

line 117: [J

line 118: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/modemap.vim[J
continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
line 176: sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/notifiers.vim"[J
line 1: if exists('g:loaded_syntastic_notifiers') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_syntastic_notifiers = 1[J

line 5: [J

line 6: let g:SyntasticNotifiers = {}[J

line 7: [J

line 8: let s:_NOTIFIER_TYPES = ['signs', 'balloons', 'highlighting', 'cursor', 'autoloclist'][J

line 9: lockvar! s:_NOTIFIER_TYPES[J

line 10: [J

line 11: let s:_PERSISTENT_NOTIFIERS = ['signs', 'balloons'][J

line 12: lockvar! s:_PERSISTENT_NOTIFIERS[J

line 13: [J

line 14: " Public methods {{{1[J

line 15: [J

line 16: function! g:SyntasticNotifiers.Instance() abort " {{{2[J

line 24: [J

line 25: function! g:SyntasticNotifiers.refresh(loclist) abort " {{{2[J

line 50: [J

line 51: function! g:SyntasticNotifiers.reset(loclist) abort " {{{2[J

line 69: [J

line 70: " }}}1[J

line 71: [J

line 72: " Private methods {{{1[J

line 73: [J

line 74: function! g:SyntasticNotifiers._initNotifiers() abort " {{{2[J

line 83: [J

line 84: " }}}1[J

line 85: [J

line 86: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/notifiers.vim[J
continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
line 176: sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/registry.vim"[J
line 1: if exists('g:loaded_syntastic_registry') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_syntastic_registry = 1[J

line 5: [J

line 6: " Initialisation {{{1[J

line 7: [J

line 120: let s:_DEFAULT_CHECKERS = { 'actionscript':  ['mxmlc'], 'ada':           ['gcc'], 'ansible':       ['ansible_lint'], 'apiblueprint':  ['drafter'], 'applescript':   ['osacompile'], 'asciidoc':      ['asciidoc'], 'asl':           ['iasl'], 'asm':           ['gcc'], 'bro':           ['bro'], 'bemhtml':       ['bemhtmllint'], 'c':             ['gcc'], 'cabal':         ['cabal'], 'chef':          ['foodcritic'], 'cmake':         ['cmakelint'], 'co':            ['coco'], 'cobol':         ['cobc'], 'coffee':        ['coffee', 'coffeelint'], 'coq':           ['coqtop'], 'cpp':           ['gcc'], 'cs':            ['mcs'], 'css':           ['csslint'], 'cucumber':      ['cucumber'], 'cuda':          ['nvcc'], 'd':             ['dmd'], 'dart':          ['dartanalyzer'], 'docbk':         ['xmllint'], 'dockerfile':    ['dockerfile_lint'], 'dustjs':        ['swiffer'], 'elixir':        [], 'erlang':        ['escript'], 'eruby':         ['ruby'], 'fortran':       ['gfortran'], 'glsl':          ['cgc'], 'go':      [J

line 121: lockvar! s:_DEFAULT_CHECKERS[J

line 122: [J

line 133: let s:_DEFAULT_FILETYPE_MAP = { 'gentoo-metadata': 'xml', 'groff': 'nroff', 'lhaskell': 'haskell', 'litcoffee': 'coffee', 'mail': 'text', 'mkd': 'markdown', 'pe-puppet': 'puppet', 'sgml': 'docbk', 'sgmllnx': 'docbk', }[J

line 134: lockvar! s:_DEFAULT_FILETYPE_MAP[J

line 135: [J

line 144: let s:_ECLIM_TYPES = [ 'c', 'cpp', 'html', 'java', 'php', 'python', 'ruby', ][J

line 145: lockvar! s:_ECLIM_TYPES[J

line 146: [J

line 152: let s:_YCM_TYPES = [ 'c', 'cpp', 'objc', 'objcpp', ][J

line 153: lockvar! s:_YCM_TYPES[J

line 154: [J

line 155: let g:SyntasticRegistry = {}[J

line 156: [J

line 157: " }}}1[J

line 158: [J

line 159: " Public methods {{{1[J

line 160: [J

line 161: " Note: Handling of filetype aliases: all public methods take aliases as[J

line 162: " parameters, all private methods take normalized filetypes.  Public methods[J

line 163: " are thus supposed to normalize filetypes before calling private methods.[J

line 164: [J

line 165: function! g:SyntasticRegistry.Instance() abort " {{{2[J

line 173: [J

line 174: function! g:SyntasticRegistry.CreateAndRegisterChecker(args) abort " {{{2[J

line 192: [J

line 193: " Given a list of checker names hints_list, return a map name --> checker.[J

line 194: " If hints_list is empty, user settings are are used instead. Checkers are[J

line 195: " not checked for availability (that is, the corresponding IsAvailable() are[J

line 196: " not run).[J

line 197: function! g:SyntasticRegistry.getCheckers(ftalias, hints_list) abort " {{{2[J

line 232: [J

line 233: " Same as getCheckers(), but keep only the available checkers.  This runs the[J

line 234: " corresponding IsAvailable() functions for all checkers.[J

line 235: function! g:SyntasticRegistry.getCheckersAvailable(ftalias, hints_list) abort " {{{2[J

line 238: [J

line 239: " Same as getCheckers(), but keep only the checkers that are available and[J

line 240: " disabled.  This runs the corresponding IsAvailable() functions for all checkers.[J

line 241: function! g:SyntasticRegistry.getCheckersDisabled(ftalias, hints_list) abort " {{{2[J

line 244: [J

line 245: function! g:SyntasticRegistry.getKnownFiletypes() abort " {{{2[J

line 260: [J

line 261: function! g:SyntasticRegistry.getNamesOfAvailableCheckers(ftalias) abort " {{{2[J

line 266: [J

line 267: function! g:SyntasticRegistry.resolveFiletypes(ftalias) abort " {{{2[J

line 270: [J

line 271: function! g:SyntasticRegistry.echoInfoFor(ftalias_list) abort " {{{2[J

line 331: [J

line 332: " }}}1[J

line 333: [J

line 334: " Private methods {{{1[J

line 335: [J

line 336: function! g:SyntasticRegistry._registerChecker(checker) abort " {{{2[J

line 349: [J

line 350: function! g:SyntasticRegistry._findChecker(cname) abort " {{{2[J

line 361: [J

line 362: function! g:SyntasticRegistry._filterCheckersByName(cnames) abort " {{{2[J

line 365: [J

line 366: function! g:SyntasticRegistry._loadCheckersFor(filetype, force) abort " {{{2[J

line 377: [J

line 378: " Check for obsolete variable g:syntastic_<filetype>_checker[J

line 379: function! g:SyntasticRegistry._sanityCheck(filetype) abort " {{{2[J

line 395: [J

line 396: " }}}1[J

line 397: [J

line 398: " Utilities {{{1[J

line 399: [J

line 400: "resolve filetype aliases, and replace - with _ otherwise we cant name[J

line 401: "syntax checker functions legally for filetypes like "gentoo-metadata"[J

line 402: function! s:_normalise_filetype(ftalias) abort " {{{2[J

line 408: [J

line 409: function! s:_disabled_by_eclim(filetype) abort " {{{2[J

line 418: [J

line 419: function! s:_disabled_by_ycm(filetype) abort " {{{2[J

line 422: [J

line 423: function! s:_compare_checker_names(a, b) abort " {{{2[J

line 442: [J

line 443: " }}}1[J

line 444: [J

line 445: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/registry.vim[J
continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J
chdir(/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic)[J
fchdir() to previous dir[J
line 176: sourcing "/Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/signs.vim"[J
line 1: if exists('g:loaded_syntastic_notifier_signs') || !exists('g:loaded_syntastic_plugin')[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_syntastic_notifier_signs = 1[J

line 5: [J

line 6: " Initialisation {{{1[J

line 7: [J

line 8: " start counting sign ids at 5000, start here to hopefully avoid conflicting[J

line 9: " with any other code that places signs (not sure if this precaution is[J

line 10: " actually needed)[J

line 11: let s:first_sign_id = 5000[J

line 12: let s:next_sign_id = s:first_sign_id[J

line 13: [J

line 14: let g:SyntasticSignsNotifier = {}[J

line 15: [J

line 16: let s:setup_done = 0[J

line 17: [J

line 18: " }}}1[J

line 19: [J

line 20: " Public methods {{{1[J

line 21: [J

line 22: function! g:SyntasticSignsNotifier.New() abort " {{{2[J

line 26: [J

line 27: function! g:SyntasticSignsNotifier.enabled() abort " {{{2[J

line 30: [J

line 31: function! g:SyntasticSignsNotifier.refresh(loclist) abort " {{{2[J

line 46: [J

line 47: " }}}1[J

line 48: [J

line 49: " Private methods {{{1[J

line 50: [J

line 51: " One time setup: define our own sign types and highlighting[J

line 52: function! g:SyntasticSignsNotifier._setup() abort " {{{2[J

line 84: [J

line 85: " Place signs by all syntax errors in the buffer[J

line 86: function! g:SyntasticSignsNotifier._signErrors(loclist) abort " {{{2[J

line 117: [J

line 118: " Remove the signs with the given ids from this buffer[J

line 119: function! g:SyntasticSignsNotifier._removeSigns(ids) abort " {{{2[J

line 127: [J

line 128: " Get all the ids of the SyntaxError signs in the buffer[J

line 129: function! g:SyntasticSignsNotifier._bufSignIds() abort " {{{2[J

line 135: [J

line 136: " }}}1[J

line 137: [J

line 138: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic/signs.vim[J
continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/plugin/syntastic/*.vim"[J
Searching for "/usr/share/vim/vimfiles/plugin/syntastic/*.vim"[J
Searching for "/usr/share/vim/vim74/plugin/syntastic/*.vim"[J
Searching for "/usr/share/vim/vimfiles/after/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.vim/after/plugin/syntastic/*.vim"[J
Searching for "/Users/ygarrot/.opam/default/share/merlin/vim/plugin/syntastic/*.vim"[J
line 177: [J

line 178: let s:registry = g:SyntasticRegistry.Instance()[J

calling function 79[J()

line 1:     if !exists('s:SyntasticRegistryInstance')[J

line 2:         let s:SyntasticRegistryInstance = copy(self)[J

line 3:         let s:SyntasticRegistryInstance._checkerMap = {}[J

line 4:     endif[J

line 5: [J

line 6:     return s:SyntasticRegistryInstance[J

function 79 returning {'_filterCheckersByName': function('9...n('84'), '_findChecker': function('89')}[J

continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J

line 179: let s:notifiers = g:SyntasticNotifiers.Instance()[J

calling function 75[J()

line 1:     if !exists('s:SyntasticNotifiersInstance')[J

line 2:         let s:SyntasticNotifiersInstance = copy(self)[J

line 3:         call s:SyntasticNotifiersInstance._initNotifiers()[J

calling function 75[3]..78[J()

line 1:     let self._notifier = {}[J

line 2:     for type in s:_NOTIFIER_TYPES[J

line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')[J

line 4:         let self._notifier[type] = g:{class}.New()[J

calling function 75[3]..78[4]..93[J()

line 1:     let newObj = copy(self)[J

line 2:     return newObj[J

function 75[3]..78[4]..93 returning {'_signErrors': function('97'), '_buf...nction('93'), 'refresh': function('95')}[J

continuing in function 75[3]..78[J

line 5:     endfor[J

line 2:     for type in s:_NOTIFIER_TYPES[J

line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')[J

line 4:         let self._notifier[type] = g:{class}.New()[J

calling function 75[3]..78[4]..4[J()

line 1:     let newObj = copy(self)[J

line 2:     return newObj[J

function 75[3]..78[4]..4 returning {'enabled': function('5'), 'reset': f...function('4'), 'refresh': function('6')}[J

continuing in function 75[3]..78[J

line 5:     endfor[J

line 2:     for type in s:_NOTIFIER_TYPES[J

line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')[J

line 4:         let self._notifier[type] = g:{class}.New()[J

calling function 75[3]..78[4]..32[J()

line 1:     let newObj = copy(self)[J

line 2: [J

line 3:     if !s:setup_done[J

line 4:         call self._setup()[J

calling function 75[3]..78[4]..32[4]..36[J()

line 1:     if s:has_highlighting[J

line 2:         if !hlexists('SyntasticError')[J

line 3:             highlight link SyntasticError SpellBad[J

line 4:         endif[J

line 5:         if !hlexists('SyntasticWarning')[J

line 6:             highlight link SyntasticWarning SpellCap[J

line 7:         endif[J

line 8:         if !hlexists('SyntasticStyleError')[J

line 9:             highlight link SyntasticStyleError SyntasticError[J

line 10:         endif[J

line 11:         if !hlexists('SyntasticStyleWarning')[J

line 12:             highlight link SyntasticStyleWarning SyntasticWarning[J

line 13:         endif[J

line 14:     endif[J

function 75[3]..78[4]..32[4]..36 returning #0[J

continuing in function 75[3]..78[4]..32[J

line 5:         let s:setup_done = 1[J

line 6:         lockvar s:setup_done[J

line 7:     endif[J

line 8: [J

line 9:     return newObj[J

function 75[3]..78[4]..32 returning {'_reset': function('37'), 'enabled':...nction('32'), 'refresh': function('34')}[J

continuing in function 75[3]..78[J

line 5:     endfor[J

line 2:     for type in s:_NOTIFIER_TYPES[J

line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')[J

line 4:         let self._notifier[type] = g:{class}.New()[J

calling function 75[3]..78[4]..28[J()

line 1:     let newObj = copy(self)[J

line 2:     return newObj[J

function 75[3]..78[4]..28 returning {'enabled': function('29'), 'reset': ...nction('28'), 'refresh': function('30')}[J

continuing in function 75[3]..78[J

line 5:     endfor[J

line 2:     for type in s:_NOTIFIER_TYPES[J

line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')[J

line 4:         let self._notifier[type] = g:{class}.New()[J

calling function 75[3]..78[4]..1[J()

line 1:     let newObj = copy(self)[J

line 2:     return newObj[J

function 75[3]..78[4]..1 returning {'AutoToggle': function('3'), 'New': function('1'), 'refresh': function('2')}[J

continuing in function 75[3]..78[J

line 5:     endfor[J

line 2:     for type in s:_NOTIFIER_TYPES[J

line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')[J

line 4:         let self._notifier[type] = g:{class}.New()[J

line 5:     endfor[J

line 6: [J

line 7:     let self._enabled_types = copy(s:_NOTIFIER_TYPES)[J

function 75[3]..78 returning #0[J

continuing in function 75[J

line 4:     endif[J

line 5: [J

line 6:     return s:SyntasticNotifiersInstance[J

function 75 returning {'_notifier': {'signs': {'_signErrors...nction('77'), 'refresh': function('76')}[J

continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J

line 180: let s:modemap = g:SyntasticModeMap.Instance()[J

calling function 65[J()

line 1:     if !exists('s:SyntasticModeMapInstance')[J

line 2:         let s:SyntasticModeMapInstance = copy(self)[J

line 3:         call s:SyntasticModeMapInstance.synch()[J

calling function 65[3]..66[J()

line 1:     if exists('g:syntastic_mode_map')[J

line 2:         let self._mode = get(g:syntastic_mode_map, 'mode', 'active')[J

line 3:         let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))[J

line 4:         let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))[J

line 5:     else[J

line 6:         let self._mode = 'active'[J

line 7:         let self._activeFiletypes = [][J

line 8:         let self._passiveFiletypes = [][J

line 9:     endif[J

function 65[3]..66 returning #0[J

continuing in function 65[J

line 4:     endif[J

line 5: [J

line 6:     return s:SyntasticModeMapInstance[J

function 65 returning {'_activeFiletypes': [], '_mode': 'ac... '_isOneFiletypeActive': function('73')}[J

continuing in /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J

line 181: [J

line 182: let s:_check_stack = [][J

line 183: let s:_quit_pre = [][J

line 184: [J

line 185: " Commands {{{1[J

line 186: [J

line 187: " @vimlint(EVL103, 1, a:cursorPos)[J

line 188: " @vimlint(EVL103, 1, a:cmdLine)[J

line 189: " @vimlint(EVL103, 1, a:argLead)[J

line 190: function! s:CompleteCheckerName(argLead, cmdLine, cursorPos) abort " {{{2[J

line 206: " @vimlint(EVL103, 0, a:cursorPos)[J

line 207: " @vimlint(EVL103, 0, a:cmdLine)[J

line 208: " @vimlint(EVL103, 0, a:argLead)[J

line 209: [J

line 210: [J

line 211: " @vimlint(EVL103, 1, a:cursorPos)[J

line 212: " @vimlint(EVL103, 1, a:cmdLine)[J

line 213: " @vimlint(EVL103, 1, a:argLead)[J

line 214: function! s:CompleteFiletypes(argLead, cmdLine, cursorPos) abort " {{{2[J

line 217: " @vimlint(EVL103, 0, a:cursorPos)[J

line 218: " @vimlint(EVL103, 0, a:cmdLine)[J

line 219: " @vimlint(EVL103, 0, a:argLead)[J

line 220: [J

line 221: command! -bar -nargs=* -complete=custom,s:CompleteCheckerName SyntasticCheck call SyntasticCheck(<f-args>)[J

line 222: command! -bar -nargs=? -complete=custom,s:CompleteFiletypes   SyntasticInfo  call SyntasticInfo(<f-args>)[J

line 223: command! -bar Errors              call SyntasticErrors()[J

line 224: command! -bar SyntasticReset      call SyntasticReset()[J

line 225: command! -bar SyntasticToggleMode call SyntasticToggleMode()[J

line 226: command! -bar SyntasticSetLoclist call SyntasticSetLoclist()[J

line 227: [J

line 228: command! SyntasticJavacEditClasspath runtime! syntax_checkers/java/*.vim | SyntasticJavacEditClasspath[J

line 229: command! SyntasticJavacEditConfig    runtime! syntax_checkers/java/*.vim | SyntasticJavacEditConfig[J

line 230: [J

line 231: " }}}1[J

line 232: [J

line 233: " Public API {{{1[J

line 234: [J

line 235: function! SyntasticCheck(...) abort " {{{2[J

line 239: [J

line 240: function! SyntasticInfo(...) abort " {{{2[J

line 247: [J

line 248: function! SyntasticErrors() abort " {{{2[J

line 251: [J

line 252: function! SyntasticReset() abort " {{{2[J

line 256: [J

line 257: function! SyntasticToggleMode() abort " {{{2[J

line 263: [J

line 264: function! SyntasticSetLoclist() abort " {{{2[J

line 267: [J

line 268: " }}}1[J

line 269: [J

line 270: " Autocommands {{{1[J

line 271: [J

line 272: augroup syntastic[J

line 273:     autocmd![J

line 274:     autocmd VimEnter    * call s:VimEnterHook()[J

line 275:     autocmd BufEnter    * call s:BufEnterHook(expand('<afile>', 1))[J

line 276:     autocmd BufWinEnter * call s:BufWinEnterHook(expand('<afile>', 1))[J

line 277: augroup END[J

line 278: [J

line 279: if g:syntastic_nested_autocommands[J

line 280:     augroup syntastic[J

line 281:         autocmd BufReadPost  * nested call s:BufReadPostHook(expand('<afile>', 1))[J

line 282:         autocmd BufWritePost * nested call s:BufWritePostHook(expand('<afile>', 1))[J

line 283:     augroup END[J

line 284: else[J

line 285:     augroup syntastic[J

line 286:         autocmd BufReadPost  * call s:BufReadPostHook(expand('<afile>', 1))[J

line 287:         autocmd BufWritePost * call s:BufWritePostHook(expand('<afile>', 1))[J

line 288:     augroup END[J

line 289: endif[J

line 290: [J

line 291: if exists('##QuitPre')[J

line 292:     " QuitPre was added in Vim 7.3.544[J

line 293:     augroup syntastic[J

line 294:         autocmd QuitPre * call s:QuitPreHook(expand('<afile>', 1))[J

line 295:     augroup END[J

line 296: endif[J

line 297: [J

line 298: function! s:BufReadPostHook(fname) abort " {{{2[J

line 308: [J

line 309: function! s:BufWritePostHook(fname) abort " {{{2[J

line 315: [J

line 316: function! s:BufEnterHook(fname) abort " {{{2[J

line 342: [J

line 343: function! s:BufWinEnterHook(fname) abort " {{{2[J

line 355: [J

line 356: function! s:VimEnterHook() abort " {{{2[J

line 366: [J

line 367: function! s:QuitPreHook(fname) abort " {{{2[J

line 380: [J

line 381: " }}}1[J

line 382: [J

line 383: " Main {{{1[J

line 384: [J

line 385: "refresh and redraw all the error info for this buf when saving or reading[J

line 386: function! s:UpdateErrors(buf, auto_invoked, checker_names) abort " {{{2[J

line 442: [J

line 443: "clear the loc list for the buffer[J

line 444: function! s:ClearCache(buf) abort " {{{2[J

line 449: [J

line 450: "detect and cache all syntax errors in this buffer[J

line 451: function! s:CacheErrors(buf, checker_names) abort " {{{2[J

line 546: [J

line 547: "Emulates the :lmake command. Sets up the make environment according to the[J

line 548: "options given, runs make, resets the environment, returns the location list[J

line 549: "[J

line 550: "a:options can contain the following keys:[J

line 551: "    'makeprg'[J

line 552: "    'errorformat'[J

line 553: "[J

line 554: "The corresponding options are set for the duration of the function call. They[J

line 555: "are set with :let, so dont escape spaces.[J

line 556: "[J

line 557: "a:options may also contain:[J

line 558: "   'defaults' - a dict containing default values for the returned errors[J

line 559: "   'subtype' - all errors will be assigned the given subtype[J

line 560: "   'preprocess' - a function to be applied to the error file before parsing errors[J

line 561: "   'postprocess' - a list of functions to be applied to the error list[J

line 562: "   'cwd' - change directory to the given path before running the checker[J

line 563: "   'env' - environment variables to set before running the checker[J

line 564: "   'returns' - a list of valid exit codes for the checker[J

line 565: " @vimlint(EVL102, 1, l:env_save)[J

line 566: function! SyntasticMake(options) abort " {{{2[J

line 688: " @vimlint(EVL102, 0, l:env_save)[J

line 689: [J

line 690: "return a string representing the state of buffer according to[J

line 691: "g:syntastic_stl_format[J

line 692: "[J

line 693: "return '' if no errors are cached for the buffer[J

line 694: function! SyntasticStatuslineFlag() abort " {{{2[J

line 697: [J

line 698: " }}}1[J

line 699: [J

line 700: " Utilities {{{1[J

line 701: [J

line 702: function! s:_ignore_file(filename) abort " {{{2[J

line 711: [J

line 712: function! s:_is_quitting(buf) abort " {{{2[J

line 725: [J

line 726: " Skip running in special buffers[J

line 727: function! s:_skip_file(buf) abort " {{{2[J

line 738: [J

line 739: " Explain why checks will be skipped for the current file[J

line 740: function! s:_explain_skip(filetypes) abort " {{{2[J

line 775: [J

line 776: " Take a list of errors and add default values to them from a:options[J

line 777: function! s:_add_to_errors(errors, options) abort " {{{2[J

line 788: [J

line 789: function! s:_os_name() abort " {{{2[J

line 792: [J

line 793: " }}}1[J

line 794: [J

line 795: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/ygarrot/.vim/plugged/syntastic/plugin/syntastic.vim[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-fugitive/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/vim-fugitive/plugin/fugitive.vim"[J
line 1: " fugitive.vim - A Git wrapper so awesome, it should be illegal[J

line 2: " Maintainer:   Tim Pope <http://tpo.pe/>[J

line 3: " Version:      3.0[J

line 4: " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim[J

line 5: [J

line 6: if exists('g:loaded_fugitive')[J

line 7:   finish[J

line 8: endif[J

line 9: let g:loaded_fugitive = 1[J

line 10: [J

line 11: function! FugitiveGitDir(...) abort[J

line 29: [J

line 30: " FugitiveReal() takes a fugitive:// URL and returns the corresponding path in[J

line 31: " the work tree.  This may be useful to get a cleaner path for inclusion in[J

line 32: " the statusline, for example.  Note that the file and its parent directories[J

line 33: " are not guaranteed to exist.[J

line 34: "[J

line 35: " This is intended as an abstract API to be used on any "virtual" path.  For a[J

line 36: " buffer named foo://bar, check for a function named FooReal(), and if it[J

line 37: " exists, call FooReal("foo://bar").[J

line 38: function! FugitiveReal(...) abort[J

line 48: [J

line 49: " FugitiveFind() takes a Fugitive object and returns the appropriate Vim[J

line 50: " buffer name.  You can use this to generate Fugitive URLs ("HEAD:README") or[J

line 51: " to get the absolute path to a file in the Git dir (".git/HEAD"), the common[J

line 52: " dir (".git/config"), or the work tree (":(top)Makefile").[J

line 53: "[J

line 54: " An optional second argument provides the Git dir, or the buffer number of a[J

line 55: " buffer with a Git dir.  The default is the current buffer.[J

line 56: function! FugitiveFind(...) abort[J

line 59: [J

line 60: function! FugitivePath(...) abort[J

line 67: [J

line 68: " FugitiveParse() takes a fugitive:// URL and returns a 2 element list[J

line 69: " containing the Git dir and an object name ("commit:file").  It's effectively[J

line 70: " then inverse of FugitiveFind().[J

line 71: function! FugitiveParse(...) abort[J

line 83: [J

line 84: " FugitivePrepare() constructs a Git command string which can be executed with[J

line 85: " functions like system() and commands like :!.  Integer arguments will be[J

line 86: " treated as buffer numbers, and the appropriate relative path inserted in[J

line 87: " their place.[J

line 88: "[J

line 89: " If the first argument is a string that looks like a path or an empty string,[J

line 90: " it will be used as the Git dir.  If it's a buffer number, the Git dir for[J

line 91: " that buffer will be used.  The default is the current buffer.[J

line 92: function! FugitivePrepare(...) abort[J

line 95: [J

line 96: function! FugitiveConfig(...) abort[J

line 105: [J

line 106: function! FugitiveRemoteUrl(...) abort[J

line 109: [J

line 110: function! FugitiveHead(...) abort[J

line 117: [J

line 118: function! FugitiveStatusline(...) abort[J

line 124: [J

line 125: function! FugitiveCommonDir(...) abort[J

line 132: [J

line 133: function! FugitiveWorkTree(...) abort[J

line 136: [J

line 137: function! FugitiveIsGitDir(path) abort[J

line 143: [J

line 144: let s:worktree_for_dir = {}[J

line 145: let s:dir_for_worktree = {}[J

line 146: function! s:Tree(path) abort[J

line 179: [J

line 180: function! FugitiveExtractGitDir(path) abort[J

line 234: [J

line 235: function! FugitiveDetect(path) abort[J

line 249: [J

line 250: function! FugitiveVimPath(path) abort[J

line 257: [J

line 258: function! FugitiveGitPath(path) abort[J

line 261: [J

line 262: function! s:Slash(path) abort[J

line 269: [J

line 270: function! s:ProjectionistDetect() abort[J

line 287: [J

line 303: let g:io_fugitive = { 'simplify': function('fugitive#simplify'), 'resolve': function('fugitive#resolve'), 'getftime': function('fugitive#getftime'), 'getfsize': function('fugitive#getfsize'), 'getftype': function('fugitive#getftype'), 'filereadable': function('fugitive#filereadable'), 'filewritable': function('fugitive#filewritable'), 'isdirectory': function('fugitive#isdirectory'), 'getfperm': function('fugitive#getfperm'), 'setfperm': function('fugitive#setfperm'), 'readfile': function('fugitive#readfile'), 'writefile': function('fugitive#writefile'), 'glob': function('fugitive#glob'), 'delete': function('fugitive#delete'), 'Real': function('FugitiveReal')}[J

line 304: [J

line 305: augroup fugitive[J

line 306:   autocmd![J

line 307: [J

line 308:   autocmd BufNewFile,BufReadPost * call FugitiveDetect(expand('<amatch>:p'))[J

line 309:   autocmd FileType           netrw call FugitiveDetect(fnamemodify(get(b:, 'netrw_curdir', expand('<amatch>')), ':p'))[J

line 310: [J

line 315:   autocmd FileType git if len(FugitiveGitDir()) |   call fugitive#MapJumps() |   call fugitive#MapCfile() | endif[J

line 319:   autocmd FileType gitcommit if len(FugitiveGitDir()) |   call fugitive#MapCfile('fugitive#MessageCfile()') | endif[J

line 323:   autocmd FileType fugitive if len(FugitiveGitDir()) |   call fugitive#MapCfile('fugitive#StatusCfile()') | endif[J

line 330:   autocmd FileType gitrebase let &l:include = '^\%(pick\|squash\|edit\|reword\|fixup\|drop\|[pserfd]\)\>' | if len(FugitiveGitDir()) |   let &l:includeexpr = 'v:fname =~# ''^\x\{4,\}$'' ? FugitiveFind(v:fname) : ' .   (len(&l:includeexpr) ? &l:includeexpr : 'v:fname') | endif | let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|setl inex= inc='[J

line 331: [J

line 343:   autocmd BufReadCmd index{,.lock} if FugitiveIsGitDir(expand('<amatch>:p:h')) |   let b:git_dir = s:Slash(expand('<amatch>:p:h')) |   exe fugitive#BufReadStatus() | elseif filereadable(expand('<amatch>')) |   silent doautocmd BufReadPre |   keepalt read <amatch> |   1delete_ |   silent doautocmd BufReadPost | else |   silent doautocmd BufNewFile | endif[J

line 344: [J

line 348:   autocmd BufReadCmd    fugitive://*//*             exe fugitive#BufReadCmd() | if &path =~# '^\.\%(,\|$\)' |   let &l:path = substitute(&path, '^\.,\=', '', '') | endif[J

line 349:   autocmd BufWriteCmd   fugitive://*//[0-3]/*       exe fugitive#BufWriteCmd()[J

line 350:   autocmd FileReadCmd   fugitive://*//*             exe fugitive#FileReadCmd()[J

line 351:   autocmd FileWriteCmd  fugitive://*//[0-3]/*       exe fugitive#FileWriteCmd()[J

line 352:   if exists('##SourceCmd')[J

line 353:     autocmd SourceCmd     fugitive://*//*    nested exe fugitive#SourceCmd()[J

line 354:   endif[J

line 355: [J

line 356:   autocmd User Flags call Hoist('buffer', function('FugitiveStatusline'))[J

line 357: [J

line 358:   autocmd User ProjectionistDetect call s:ProjectionistDetect()[J

line 359: augroup END[J

line 360: [J

line 361: let s:addr_other = has('patch-8.1.560') ? '-addr=other' : ''[J

line 362: let s:addr_tabs  = has('patch-7.4.542') ? '-addr=tabs' : ''[J

line 363: let s:addr_wins  = has('patch-7.4.542') ? '-addr=windows' : ''[J

line 364: exe 'command! -bang -nargs=? -range=-1' s:addr_other '-complete=customlist,fugitive#Complete G   exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'[J

line 364: command! -bang -nargs=? -range=-1  -complete=customlist,fugitive#Complete G   exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)[J

line 365: exe 'command! -bang -nargs=? -range=-1' s:addr_other '-complete=customlist,fugitive#Complete Git exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'[J

line 365: command! -bang -nargs=? -range=-1  -complete=customlist,fugitive#Complete Git exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)[J

line 366: [J

line 367: exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Gcd  exe fugitive#Cd(<q-args>, 0)"[J

line 367: command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Gcd  exe fugitive#Cd(<q-args>, 0)[J

line 368: exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Glcd exe fugitive#Cd(<q-args>, 1)"[J

line 368: command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Glcd exe fugitive#Cd(<q-args>, 1)[J

line 369: [J

line 370: exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Ggrep  exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "grep " . <q-args>)'[J

line 370: command! -bang -nargs=? -range=-1 -addr=windows -complete=customlist,fugitive#GrepComplete Ggrep  exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "grep " . <q-args>)[J

line 371: exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Gcgrep exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "grep " . <q-args>)'[J

line 371: command! -bang -nargs=? -range=-1 -addr=windows -complete=customlist,fugitive#GrepComplete Gcgrep exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "grep " . <q-args>)[J

line 372: exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Glgrep exe fugitive#Command(0, <count> > 0 ? <count> : 0, +"<range>", <bang>0, "<mods>", "grep " . <q-args>)'[J

line 372: command! -bang -nargs=? -range=-1 -addr=windows -complete=customlist,fugitive#GrepComplete Glgrep exe fugitive#Command(0, <count> > 0 ? <count> : 0, +"<range>", <bang>0, "<mods>", "grep " . <q-args>)[J

line 373: [J

line 374: exe 'command! -bang -nargs=? -range=-1' s:addr_other '-complete=customlist,fugitive#LogComplete Glog  :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "")'[J

line 374: command! -bang -nargs=? -range=-1  -complete=customlist,fugitive#LogComplete Glog  :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "")[J

line 375: exe 'command! -bang -nargs=? -range=-1' s:addr_other '-complete=customlist,fugitive#LogComplete Gclog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")'[J

line 375: command! -bang -nargs=? -range=-1  -complete=customlist,fugitive#LogComplete Gclog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")[J

line 376: exe 'command! -bang -nargs=? -range=-1' s:addr_other '-complete=customlist,fugitive#LogComplete Gllog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")'[J

line 376: command! -bang -nargs=? -range=-1  -complete=customlist,fugitive#LogComplete Gllog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")[J

line 377: [J

line 378: exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#CompleteObject Ge       exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>, [<f-args>])'[J

line 378: command! -bar -bang -nargs=*                          -complete=customlist,fugitive#CompleteObject Ge       exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>, [<f-args>])[J

line 379: exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#CompleteObject Gedit    exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>, [<f-args>])'[J

line 379: command! -bar -bang -nargs=*                          -complete=customlist,fugitive#CompleteObject Gedit    exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>, [<f-args>])[J

line 380: exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#ReadComplete   Gpedit   exe fugitive#Open("pedit", <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 380: command! -bar -bang -nargs=*                          -complete=customlist,fugitive#ReadComplete   Gpedit   exe fugitive#Open("pedit", <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 381: exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#ReadComplete   Gsplit   exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "split" : "edit"), <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 381: command! -bar -bang -nargs=* -range=-1  -complete=customlist,fugitive#ReadComplete   Gsplit   exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "split" : "edit"), <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 382: exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#ReadComplete   Gvsplit  exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "vsplit" : "edit!"), <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 382: command! -bar -bang -nargs=* -range=-1  -complete=customlist,fugitive#ReadComplete   Gvsplit  exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "vsplit" : "edit!"), <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 383: exe 'command! -bar -bang -nargs=* -range=-1' s:addr_tabs  '-complete=customlist,fugitive#ReadComplete   Gtabedit exe fugitive#Open((<count> >= 0 ? <count> : "")."tabedit", <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 383: command! -bar -bang -nargs=* -range=-1 -addr=tabs -complete=customlist,fugitive#ReadComplete   Gtabedit exe fugitive#Open((<count> >= 0 ? <count> : "")."tabedit", <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 384: [J

line 385: if exists(':Gr') != 2[J

line 386:   exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gr     exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 386: command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gr     exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 387: endif[J

line 388: exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gread    exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 388: command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gread    exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 389: [J

line 390: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gdiffsplit  exe fugitive#Diffsplit(1, <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 390: command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gdiffsplit  exe fugitive#Diffsplit(1, <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 391: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Ghdiffsplit exe fugitive#Diffsplit(0, <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 391: command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Ghdiffsplit exe fugitive#Diffsplit(0, <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 392: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gvdiffsplit exe fugitive#Diffsplit(0, <bang>0, "vert <mods>", <q-args>, [<f-args>])'[J

line 392: command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gvdiffsplit exe fugitive#Diffsplit(0, <bang>0, "vert <mods>", <q-args>, [<f-args>])[J

line 393: [J

line 394: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gw     exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 394: command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gw     exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 395: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gwrite exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 395: command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gwrite exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 396: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gwq    exe fugitive#WqCommand(   <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 396: command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gwq    exe fugitive#WqCommand(   <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 397: [J

line 398: exe 'command! -bar -bang -nargs=0 -complete=customlist,fugitive#CompleteObject Gremove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 398: command! -bar -bang -nargs=0 -complete=customlist,fugitive#CompleteObject Gremove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 399: exe 'command! -bar -bang -nargs=0 -complete=customlist,fugitive#CompleteObject Gdelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 399: command! -bar -bang -nargs=0 -complete=customlist,fugitive#CompleteObject Gdelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 400: exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject Gmove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 400: command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject Gmove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 401: exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete Grename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 401: command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete Grename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 402: [J

line 403: exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'[J

line 403: command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])[J

line 404: [J

line 405: if get(g:, 'fugitive_no_maps')[J

line 406:   finish[J

line 407: endif[J

line 408: [J

line 409: let s:nowait = v:version >= 704 ? '<nowait>' : ''[J

line 410: [J

line 411: function! s:Map(mode, lhs, rhs, ...) abort[J

line 436: [J

line 437: call s:Map('c', '<C-R><C-G>', 'fnameescape(fugitive#Object(@%))', '<expr>')[J

calling function <SNR>43_Map[J('c', '<C-R><C-G>', 'fnameescape(fugitive#Object(@%))', '<expr>')

line 1:   for mode in split(a:mode, '\zs')[J

line 2:     let flags = (a:0 ? a:1 : '') . (a:rhs =~# '<Plug>' ? '' : '<script>')[J

line 3:     let head = a:lhs[J

line 4:     let tail = ''[J

line 5:     let keys = get(g:, mode.'remap', {})[J

line 6:     if type(keys) == type([])[J

line 7:       return[J

line 8:     endif[J

line 9:     while !empty(head)[J

line 10:       if has_key(keys, head)[J

line 11:         let head = keys[head][J

line 12:         if empty(head)[J

line 13:           return[J

line 14:         endif[J

line 15:         break[J

line 16:       endif[J

line 17:       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail[J

line 18:       let head = substitute(head, '<[^<>]*>$\|.$', '', '')[J

line 19:     endwhile[J

line 9:     while !empty(head)[J

line 10:       if has_key(keys, head)[J

line 11:         let head = keys[head][J

line 12:         if empty(head)[J

line 13:           return[J

line 14:         endif[J

line 15:         break[J

line 16:       endif[J

line 17:       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail[J

line 18:       let head = substitute(head, '<[^<>]*>$\|.$', '', '')[J

line 19:     endwhile[J

line 9:     while !empty(head)[J

line 10:       if has_key(keys, head)[J

line 11:         let head = keys[head][J

line 12:         if empty(head)[J

line 13:           return[J

line 14:         endif[J

line 15:         break[J

line 16:       endif[J

line 17:       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail[J

line 18:       let head = substitute(head, '<[^<>]*>$\|.$', '', '')[J

line 19:     endwhile[J

line 20:     if flags !~# '<unique>' || empty(mapcheck(head.tail, mode))[J

line 21:       exe mode.'map' s:nowait flags head.tail a:rhs[J

line 21: cmap <nowait> <expr><script> <C-R><C-G> fnameescape(fugitive#Object(@%))[J

line 22:     endif[J

line 23:   endfor[J

line 1:   for mode in split(a:mode, '\zs')[J

line 2:     let flags = (a:0 ? a:1 : '') . (a:rhs =~# '<Plug>' ? '' : '<script>')[J

line 3:     let head = a:lhs[J

line 4:     let tail = ''[J

line 5:     let keys = get(g:, mode.'remap', {})[J

line 6:     if type(keys) == type([])[J

line 7:       return[J

line 8:     endif[J

line 9:     while !empty(head)[J

line 10:       if has_key(keys, head)[J

line 11:         let head = keys[head][J

line 12:         if empty(head)[J

line 13:           return[J

line 14:         endif[J

line 15:         break[J

line 16:       endif[J

line 17:       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail[J

line 18:       let head = substitute(head, '<[^<>]*>$\|.$', '', '')[J

line 19:     endwhile[J

line 20:     if flags !~# '<unique>' || empty(mapcheck(head.tail, mode))[J

line 21:       exe mode.'map' s:nowait flags head.tail a:rhs[J

line 22:     endif[J

line 23:   endfor[J

function <SNR>43_Map returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vim-fugitive/plugin/fugitive.vim[J

line 438: call s:Map('n', 'y<C-G>', ':<C-U>call setreg(v:register, fugitive#Object(@%))<CR>', '<silent>')[J

calling function <SNR>43_Map[J('n', 'y<C-G>', ':<C-U>call setreg(v:register, fugitive#Object(@%))<CR>', '<silent>')

line 1:   for mode in split(a:mode, '\zs')[J

line 2:     let flags = (a:0 ? a:1 : '') . (a:rhs =~# '<Plug>' ? '' : '<script>')[J

line 3:     let head = a:lhs[J

line 4:     let tail = ''[J

line 5:     let keys = get(g:, mode.'remap', {})[J

line 6:     if type(keys) == type([])[J

line 7:       return[J

line 8:     endif[J

line 9:     while !empty(head)[J

line 10:       if has_key(keys, head)[J

line 11:         let head = keys[head][J

line 12:         if empty(head)[J

line 13:           return[J

line 14:         endif[J

line 15:         break[J

line 16:       endif[J

line 17:       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail[J

line 18:       let head = substitute(head, '<[^<>]*>$\|.$', '', '')[J

line 19:     endwhile[J

line 9:     while !empty(head)[J

line 10:       if has_key(keys, head)[J

line 11:         let head = keys[head][J

line 12:         if empty(head)[J

line 13:           return[J

line 14:         endif[J

line 15:         break[J

line 16:       endif[J

line 17:       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail[J

line 18:       let head = substitute(head, '<[^<>]*>$\|.$', '', '')[J

line 19:     endwhile[J

line 9:     while !empty(head)[J

line 10:       if has_key(keys, head)[J

line 11:         let head = keys[head][J

line 12:         if empty(head)[J

line 13:           return[J

line 14:         endif[J

line 15:         break[J

line 16:       endif[J

line 17:       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail[J

line 18:       let head = substitute(head, '<[^<>]*>$\|.$', '', '')[J

line 19:     endwhile[J

line 20:     if flags !~# '<unique>' || empty(mapcheck(head.tail, mode))[J

line 21:       exe mode.'map' s:nowait flags head.tail a:rhs[J

line 21: nmap <nowait> <silent><script> y<C-G> :<C-U>call setreg(v:register, fugitive#Object(@%))<CR>[J

line 22:     endif[J

line 23:   endfor[J

line 1:   for mode in split(a:mode, '\zs')[J

line 2:     let flags = (a:0 ? a:1 : '') . (a:rhs =~# '<Plug>' ? '' : '<script>')[J

line 3:     let head = a:lhs[J

line 4:     let tail = ''[J

line 5:     let keys = get(g:, mode.'remap', {})[J

line 6:     if type(keys) == type([])[J

line 7:       return[J

line 8:     endif[J

line 9:     while !empty(head)[J

line 10:       if has_key(keys, head)[J

line 11:         let head = keys[head][J

line 12:         if empty(head)[J

line 13:           return[J

line 14:         endif[J

line 15:         break[J

line 16:       endif[J

line 17:       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail[J

line 18:       let head = substitute(head, '<[^<>]*>$\|.$', '', '')[J

line 19:     endwhile[J

line 20:     if flags !~# '<unique>' || empty(mapcheck(head.tail, mode))[J

line 21:       exe mode.'map' s:nowait flags head.tail a:rhs[J

line 22:     endif[J

line 23:   endfor[J

function <SNR>43_Map returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vim-fugitive/plugin/fugitive.vim[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-fugitive/plugin/fugitive.vim[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/plugin/**/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/tlib_vim/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/tlib_vim/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/tlib_vim/plugin/02tlib.vim"[J
line 1: " @Author:      Tom Link (micathom AT gmail com?subject=[vim])[J

line 2: " @Created:     2007-04-10.[J

line 3: " @Last Change: 2019-04-09.[J

line 4: " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)[J

line 5: " @Revision:    836[J

line 6: " @Website:     http://www.vim.org/account/profile.php?user_id=4037[J

line 7: " GetLatestVimScripts: 1863 1 tlib.vim[J

line 8: " tlib.vim -- Some utility functions[J

line 9: [J

line 10: if &cp || exists("g:loaded_tlib")[J

line 11:     finish[J

line 12: endif[J

line 13: if v:version < 700 "{{{2[J

line 14:     echoerr "tlib requires Vim >= 7"[J

line 15:     finish[J

line 16: endif[J

line 17: let g:loaded_tlib = 127[J

line 18: [J

line 19: let s:save_cpo = &cpo[J

line 20: set cpo&vim[J

line 21: [J

line 22: [J

line 23: " :display: :TLet VAR = VALUE[J

line 24: " Set a variable only if it doesn't already exist.[J

line 25: " EXAMPLES: >[J

line 26: "   TLet foo = 1[J

line 27: "   TLet foo = 2[J

line 28: "   echo foo[J

line 29: "   => 1[J

line 30: command! -nargs=+ TLet if !exists(matchstr(<q-args>, '^[^=[:space:]]\+')) | exec 'let '. <q-args> | endif[J

line 31: [J

line 32: [J

line 33: " Open a scratch buffer (a buffer without a file).[J

line 34: "   TScratch  ... use split window[J

line 35: "   TScratch! ... use the whole frame[J

line 36: " This command takes an (inner) dictionary as optional argument.[J

line 37: " EXAMPLES: >[J

line 38: "   TScratch 'scratch': '__FOO__'[J

line 39: "   => Open a scratch buffer named __FOO__[J

line 40: command! -bar -nargs=* -bang TScratch call tlib#scratch#UseScratch({'scratch_split': empty('<bang>'), <args>})[J

line 41: [J

line 42: [J

line 43: " :display: :TVarArg VAR1, [VAR2, DEFAULT2] ...[J

line 44: " A convenience wrapper for |tlib#arg#Let|.[J

line 45: " EXAMPLES: >[J

line 46: "   function! Foo(...)[J

line 47: "       TVarArg ['a', 1], 'b'[J

line 48: "       echo 'a='. a[J

line 49: "       echo 'b='. b[J

line 50: "   endf[J

line 51: command! -nargs=+ TVarArg exec tlib#arg#Let([<args>])[J

line 52: [J

line 53: [J

line 54: " :display: :TBrowseOutput COMMAND[J

line 55: " Ever wondered how to efficiently browse the output of a command [J

line 56: " without redirecting it to a file? This command takes a command as [J

line 57: " argument and presents the output via |tlib#input#List()| so that you [J

line 58: " can easily search for a keyword (e.g. the name of a variable or [J

line 59: " function) and the like.[J

line 60: "[J

line 61: " If you press enter, the selected line will be copied to the command [J

line 62: " line. Press ESC to cancel browsing.[J

line 63: "[J

line 64: " EXAMPLES: >[J

line 65: "   TBrowseOutput 20verb TeaseTheCulprit[J

line 66: command! -nargs=1 -complete=command TBrowseOutput call tlib#cmd#BrowseOutput(<q-args>)[J

line 67: [J

line 68: [J

line 69: " :display: :TBrowseScriptnames[J

line 70: " List all sourced script names (the output of ':scriptnames').[J

line 71: "[J

line 72: " When you press enter, the selected script will be opened in the current[J

line 73: " window. Press ESC to cancel.[J

line 74: "[J

line 75: " EXAMPLES: >[J

line 76: "   TBrowseScriptnames [J

line 77: command! -nargs=0 -complete=command TBrowseScriptnames call tlib#cmd#TBrowseScriptnames()[J

line 78: [J

line 79: [J

line 80: " :display: :Texecqfl CMD[J

line 81: " Run CMD and display the quickfix list.[J

line 82: command! -nargs=1 Texecqfl <args> | call tlib#qfl#QflList(getqflist())[J

line 83: [J

line 84: [J

line 85: " :display: :Texecloc CMD[J

line 86: " Run CMD and display the quickfix list.[J

line 87: command! -nargs=1 Texecloc <args> | call tlib#qfl#QflList(getloclist(0))[J

line 88: [J

line 89: [J

line 90: " :display: :Tlibtrace GUARD, VAR1, VAR2...[J

line 91: " Do nothing unless |tlib#trace#Enable()| was called.[J

line 92: " [J

line 93: " When |:Tlibtraceset| or |tlib#trace#Enable()| were called:[J

line 94: "[J

line 95: " If GUARD is a number that evaluates to true or if it is a string that [J

line 96: " matches a |regexp|, which was added using Tlibtrace! (with '!'), [J

line 97: " display the values of VAR1, VAR2 ...[J

line 98: command! -nargs=+ -bang Tlibtrace :[J

line 99: [J

line 100: [J

line 101: " :Tlibtraceset[!] [--file=FILE] +RX1 -RX2...[J

line 102: " If |tlib#trace#Enable()| was called: With the optional <bang>, users [J

line 103: " can add and remove GUARDs (actually a |regexp|) that should be traced.[J

line 104: "[J

line 105: " If no `+` or `-` is prepended, assume `+`.[J

line 106: "[J

line 107: " With the optional bang '!', reset any options.[J

line 108: command! -nargs=+ -bang Tlibtraceset call tlib#trace#Set(tlib#arg#GetOpts([<f-args>], {'short': 0}), !empty("<bang>"))[J

line 109: [J

line 110: [J

line 111: " :display: :Tlibtrace ASSERTION[J

line 112: command! -nargs=+ -bang Tlibassert :[J

line 113: [J

line 114: " :display: :Tlibtype val, 'type', ...[J

line 115: command! -nargs=+ Tlibtype :[J

line 116: [J

line 117: [J

line 118: " Browse the current |quickfix| list.[J

line 119: command! -bar Tbrowseqfl call tlib#qfl#Browse()[J

line 120: [J

line 121: " Browse the current |location-list|.[J

line 122: command! -bar Tbrowseloc call tlib#loclist#Browse()[J

line 123: [J

line 124: [J

line 125: let &cpo = s:save_cpo[J

line 126: unlet s:save_cpo[J

finished sourcing /Users/ygarrot/.vim/plugged/tlib_vim/plugin/02tlib.vim[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-snipmate/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/vim-snipmate/plugin/snipMate.vim"[J
line 1: " File:          snipMate.vim[J

line 2: " Description:   snipMate.vim implements some of TextMate's snippets features in[J

line 3: "                Vim. A snippet is a piece of often-typed text that you can[J

line 4: "                insert into your document using a trigger word followed by a "<tab>".[J

line 5: "[J

line 6: "                For more help see snipMate.txt; you can do this by using:[J

line 7: "                :helptags ~/.vim/doc[J

line 8: "                :h SnipMate[J

line 9: [J

line 10: if exists('loaded_snips') || &cp || version < 700[J

line 11: ^Ifinish[J

line 12: endif[J

line 13: let loaded_snips = 1[J

line 14: [J

line 15: " Save and reset 'cpo'[J

line 16: let s:save_cpo = &cpo[J

line 17: set cpo&vim[J

line 18: [J

line 19: try[J

line 20: ^Icall funcref#Function('')[J

Searching for "autoload/funcref.vim" in "/Users/ygarrot/.vim,/Users/ygarrot/.vim/plugged/vim-dirvish/,/Users/ygarrot/.vim/plugged/space-vim-dark/,/Users/ygarrot/.vim/plugged/vim-surround/,/Users/ygarrot/.vim/plugged/goyo.vim/,/Users/ygarrot/.vim/plugged/i3-vim-syntax/,/Users/ygarrot/.vim/plugged/vimagit/,/Users/ygarrot/.vim/plugged/vimwiki/,/Users/ygarrot/.vim/plugged/vim-airline/,/Users/ygarrot/.vim/plugged/vim-commentary/,/Users/ygarrot/.vim/plugged/vim-startify/,/Users/ygarrot/.vim/plugged/vim-highlightedyank/,/Users/ygarrot/.vim/plugged/syntastic/,/Users/ygarrot/.vim/plugged/vim-fugitive/,/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/,/Users/ygarrot/.vim/plugged/tlib_vim/,/Users/ygarrot/.vim/plugged/vim-snipmate/,/Users/ygarrot/.vim/plugged/vim-snippets/,/Users/ygarrot/.vim/plugged/gruvbox/,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/Users/ygarrot/.vim/plugged/vim-snipmate/after,/Users/ygarrot/.vim/after,/Users/ygarrot/.opam/default/share/merlin/vim"[J
Searching for "/Users/ygarrot/.vim/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-dirvish/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/space-vim-dark/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-surround/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/goyo.vim/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/i3-vim-syntax/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimagit/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vimwiki/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-airline/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-commentary/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-startify/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-highlightedyank/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/syntastic/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-fugitive/autoload/funcref.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/autoload/funcref.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/autoload)[J
fchdir() to previous dir[J
line 20: sourcing "/Users/ygarrot/.vim/plugged/vim-addon-mw-utils/autoload/funcref.vim"[J
line 1: " funcref.vim[J

line 2: " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)[J

line 3: " @Last Change: 2010-01-03.[J

line 4: " @Revision:    0.1.0[J

line 5: [J

line 6: " documentation see doc/funcref.txt[J

line 7: [J

line 8: " usage:[J

line 9: "  funcref#Function("filename#Function")[J

line 10: "  optionally pass arguments:[J

line 11: "  funcref#Function("filename#Function",{'args': [2]})[J

line 12: "  optionally define self:[J

line 13: "  funcref#Function("filename#Function",{'self': object})[J

line 14: function! funcref#Function(name,...)[J

line 19: [J

line 20: " args : same as used for call(f,[args], self)[J

line 21: " f must be either[J

line 22: "   - a string which can be evaled (use "return 'value'" to return a value)[J

line 23: "   - a Vim function reference created by function('..')[J

line 24: "   - a faked function reference created by funcref#Function(..)[J

line 25: "[J

line 26: " the last "self" argument can be overriden by the function reference[J

line 27: " You can pass arguments in a closure like style[J

line 28: function! funcref#Call(...)[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-addon-mw-utils/autoload/funcref.vim[J
continuing in /Users/ygarrot/.vim/plugged/vim-snipmate/plugin/snipMate.vim[J
calling function funcref#Function[J('')

line 1:   let d = a:0 > 0 ? a:1 : {}[J

line 2:   let d['faked_function_reference'] = a:name[J

line 3:   return d[J

function funcref#Function returning {'faked_function_reference': ''}[J

continuing in /Users/ygarrot/.vim/plugged/vim-snipmate/plugin/snipMate.vim[J

line 21: catch /.*/[J

line 22: ^Iechoe "you're missing vim-addon-mw-utils. See install instructions at ".expand('<sfile>:h:h').'/README.md'[J

line 23: endtry[J

line 24: [J

line 25: if (!exists('g:snipMateSources'))[J

line 26:   let g:snipMateSources = {}[J

line 27:   " Default source: get snippets based on runtimepath[J

line 28:   let g:snipMateSources['default'] = funcref#Function('snipMate#DefaultPool')[J

calling function funcref#Function[J('snipMate#DefaultPool')

line 1:   let d = a:0 > 0 ? a:1 : {}[J

line 2:   let d['faked_function_reference'] = a:name[J

line 3:   return d[J

function funcref#Function returning {'faked_function_reference': 'snipMate#DefaultPool'}[J

continuing in /Users/ygarrot/.vim/plugged/vim-snipmate/plugin/snipMate.vim[J

line 29: endif[J

line 30: [J

line 31: augroup SnipMateDetect[J

line 32: ^Iau BufRead,BufNewFile *.snippet,*.snippets setlocal filetype=snippets[J

line 37: ^Iau FileType snippets if expand('<afile>:e') =~# 'snippet$' | setlocal syntax=snippet | else | setlocal syntax=snippets | endif[J

line 38: augroup END[J

line 39: [J

line 40: inoremap <silent> <Plug>snipMateNextOrTrigger  <C-R>=snipMate#TriggerSnippet()<CR>[J

line 41: snoremap <silent> <Plug>snipMateNextOrTrigger  <Esc>a<C-R>=snipMate#TriggerSnippet()<CR>[J

line 42: inoremap <silent> <Plug>snipMateTrigger        <C-R>=snipMate#TriggerSnippet(1)<CR>[J

line 43: inoremap <silent> <Plug>snipMateBack           <C-R>=snipMate#BackwardsSnippet()<CR>[J

line 44: snoremap <silent> <Plug>snipMateBack           <Esc>a<C-R>=snipMate#BackwardsSnippet()<CR>[J

line 45: inoremap <silent> <Plug>snipMateShow           <C-R>=snipMate#ShowAvailableSnips()<CR>[J

line 46: xnoremap <silent> <Plug>snipMateVisual         :<C-U>call <SID>grab_visual()<CR>gv"_c[J

line 47: [J

line 48: " config variables[J

line 49: if !exists('g:snips_author')[J

line 50: ^Ilet g:snips_author = 'Me'[J

line 51: endif[J

line 52: if !exists('g:snipMate')[J

line 53: ^Ilet g:snipMate = {}[J

line 54: endif[J

line 55: [J

line 56: " SnipMate inserts this string when no snippet expansion can be done[J

line 58: let g:snipMate['no_match_completion_feedkeys_chars'] = get(g:snipMate, 'no_match_completion_feedkeys_chars', "\t")[J

line 59: [J

line 60: " Add default scope aliases, without overriding user settings[J

line 61: let g:snipMate.scope_aliases = get(g:snipMate, 'scope_aliases', {})[J

line 62: if exists('g:snipMate_no_default_aliases')[J

line 64: ^Iechom 'The g:snipMate_no_default_aliases option has been renamed.' 'See :h snipMate-options.'[J

line 65: endif[J

line 68: if (!exists('g:snipMate_no_default_aliases') || !g:snipMate_no_default_aliases) && (!exists('g:snipMate.no_default_aliases') || !g:snipMate.no_default_aliases)[J

line 70: ^Ilet g:snipMate.scope_aliases.objc = get(g:snipMate.scope_aliases, 'objc', 'c')[J

line 72: ^Ilet g:snipMate.scope_aliases.cpp = get(g:snipMate.scope_aliases, 'cpp', 'c')[J

line 74: ^Ilet g:snipMate.scope_aliases.cu = get(g:snipMate.scope_aliases, 'cu', 'c')[J

line 76: ^Ilet g:snipMate.scope_aliases.xhtml = get(g:snipMate.scope_aliases, 'xhtml', 'html')[J

line 78: ^Ilet g:snipMate.scope_aliases.html = get(g:snipMate.scope_aliases, 'html', 'javascript')[J

line 80: ^Ilet g:snipMate.scope_aliases.php = get(g:snipMate.scope_aliases, 'php', 'php,html,javascript')[J

line 82: ^Ilet g:snipMate.scope_aliases.ur = get(g:snipMate.scope_aliases, 'ur', 'html,javascript')[J

line 84: ^Ilet g:snipMate.scope_aliases.mxml = get(g:snipMate.scope_aliases, 'mxml', 'actionscript')[J

line 86: ^Ilet g:snipMate.scope_aliases.eruby = get(g:snipMate.scope_aliases, 'eruby', 'eruby-rails,html')[J

line 88: ^Ilet g:snipMate.scope_aliases.scss = get(g:snipMate.scope_aliases, 'scss', 'css')[J

line 90: ^Ilet g:snipMate.scope_aliases.less = get(g:snipMate.scope_aliases, 'less', 'css')[J

line 91: endif[J

line 92: [J

line 93: let g:snipMate['get_snippets'] = get(g:snipMate, 'get_snippets', funcref#Function("snipMate#GetSnippets"))[J

calling function funcref#Function[J('snipMate#GetSnippets')

line 1:   let d = a:0 > 0 ? a:1 : {}[J

line 2:   let d['faked_function_reference'] = a:name[J

line 3:   return d[J

function funcref#Function returning {'faked_function_reference': 'snipMate#GetSnippets'}[J

continuing in /Users/ygarrot/.vim/plugged/vim-snipmate/plugin/snipMate.vim[J

line 94: [J

line 95: " List of paths where snippets/ dirs are located[J

line 96: if exists('g:snipMate.snippet_dirs') && type(g:snipMate['snippet_dirs']) != type([])[J

line 97: ^Iechohl WarningMsg[J

line 98: ^Iechom "g:snipMate['snippet_dirs'] must be a List"[J

line 99: ^Iechohl None[J

line 100: endif[J

line 101: [J

line 102: " _ is default scope added always[J

line 103: "[J

line 104: " &ft honors multiple filetypes and syntax such as in set ft=html.javascript syntax=FOO[J

line 105: let g:snipMate['get_scopes'] = get(g:snipMate, 'get_scopes', funcref#Function('return split(&ft,"\\.")+[&syntax, "_"]'))[J

calling function funcref#Function[J('return split(&ft,"\\.")+[&syntax, "_"]')

line 1:   let d = a:0 > 0 ? a:1 : {}[J

line 2:   let d['faked_function_reference'] = a:name[J

line 3:   return d[J

function funcref#Function returning {'faked_function_reference': 'return split(&ft,"\\.")+[&syntax, "_"]'}[J

continuing in /Users/ygarrot/.vim/plugged/vim-snipmate/plugin/snipMate.vim[J

line 106: [J

line 107: " Modified from Luc Hermitte's function on StackOverflow[J

line 108: " <http://stackoverflow.com/a/1534347>[J

line 109: function! s:grab_visual() abort[J

line 118: [J

line 119: " TODO: Allow specifying an arbitrary snippets file[J

line 120: function! s:load_scopes(bang, ...) abort[J

line 126: [J

line 128: command! -bang -bar -nargs=+ SnipMateLoadScope call s:load_scopes(<bang>0, <f-args>)[J

line 129: [J

line 130: " Edit snippet files[J

line 131: command! SnipMateOpenSnippetFiles call snipMate#OpenSnippetFiles()[J

line 132: [J

line 133: " restore 'cpo'[J

line 134: let &cpo = s:save_cpo[J

line 135: [J

line 136: " vim:noet:sw=4:ts=4:ft=vim[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-snipmate/plugin/snipMate.vim[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snippets/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-snippets/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/vim-snippets/plugin/vimsnippets.vim"[J
line 1: if exists("b:done_vimsnippets")[J

line 2:    finish[J

line 3: endif[J

line 4: let b:done_vimsnippets = 1[J

line 5: [J

line 6: " Some variables need default value[J

line 7: if !exists("g:snips_author")[J

line 8:     let g:snips_author = "yourname"[J

line 9: endif[J

line 10: [J

line 11: if !exists("g:snips_email")[J

line 12:     let g:snips_email = "yourname@email.com"[J

line 13: endif[J

line 14: [J

line 15: if !exists("g:snips_github")[J

line 16:     let g:snips_github = "https://github.com/yourname"[J

line 17: endif[J

line 18: [J

line 19: " Expanding the path is not needed on Vim 7.4[J

line 20: if &cp || version >= 704[J

line 21:     finish[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-snippets/plugin/vimsnippets.vim[J
Searching for "/Users/ygarrot/.vim/plugged/gruvbox/plugin/**/*.vim"[J
Searching for "/usr/share/vim/vimfiles/plugin/**/*.vim"[J
Searching for "/usr/share/vim/vim74/plugin/**/*.vim"[J
chdir(/usr/share/vim/vim74/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim74/plugin/getscriptPlugin.vim"[J
line 1: " ---------------------------------------------------------------------[J

line 2: " getscriptPlugin.vim[J

line 3: "  Author:^ICharles E. Campbell[J

line 4: "  Date:^INov 29, 2013[J

line 5: "  Installing:^I:help glvs-install[J

line 6: "  Usage:^I:help glvs[J

line 7: "[J

line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim[J

line 9: "[J

line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let[J

line 11: " all the peoples praise Him."[J

line 12: " ---------------------------------------------------------------------[J

line 13: " Initialization:^I{{{1[J

line 14: " if you're sourcing this file, surely you can't be[J

line 15: " expecting vim to be in its vi-compatible mode[J

line 16: if exists("g:loaded_getscriptPlugin")[J

line 17:  finish[J

line 18: endif[J

line 19: if &cp[J

line 20:  if &verbose[J

line 21:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"[J

line 22:  endif[J

line 23:  finish[J

line 24: endif[J

line 25: let g:loaded_getscriptPlugin = "v36"[J

line 26: let s:keepcpo                = &cpo[J

line 27: set cpo&vim[J

line 28: [J

line 29: " ---------------------------------------------------------------------[J

line 30: "  Public Interface: {{{1[J

line 31: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()[J

line 32: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()[J

line 33: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()[J

line 34: [J

line 35: " ---------------------------------------------------------------------[J

line 36: " Restore Options: {{{1[J

line 37: let &cpo= s:keepcpo[J

line 38: unlet s:keepcpo[J

line 39: [J

line 40: " ---------------------------------------------------------------------[J

line 41: " vim: ts=8 sts=2 fdm=marker nowrap[J

finished sourcing /usr/share/vim/vim74/plugin/getscriptPlugin.vim[J
chdir(/usr/share/vim/vim74/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim74/plugin/gzip.vim"[J
line 1: " Vim plugin for editing compressed files.[J

line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2010 Mar 10[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded[J

line 7: " - when 'compatible' is set[J

line 8: " - some autocommands are already taking care of compressed files[J

line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")[J

line 10:   finish[J

line 11: endif[J

line 12: let loaded_gzip = 1[J

line 13: [J

line 14: augroup gzip[J

line 15:   " Remove all gzip autocommands[J

line 16:   au![J

line 17: [J

line 18:   " Enable editing of gzipped files.[J

line 19:   " The functions are defined in autoload/gzip.vim.[J

line 20:   "[J

line 21:   " Set binary mode before reading the file.[J

line 22:   " Use "gzip -d", gunzip isn't always available.[J

line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz setlocal bin[J

line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")[J

line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")[J

line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")[J

line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")[J

line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")[J

line 29:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")[J

line 30:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")[J

line 31:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")[J

line 32:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")[J

line 33:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")[J

line 34:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")[J

line 35:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")[J

line 36:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")[J

line 37:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")[J

line 38:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")[J

line 39:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")[J

line 40:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")[J

line 41:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")[J

line 42:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")[J

line 43:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")[J

line 44: augroup END[J

finished sourcing /usr/share/vim/vim74/plugin/gzip.vim[J
chdir(/usr/share/vim/vim74/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim74/plugin/logiPat.vim"[J
line 1: " LogiPat:[J

line 2: "   Author:  Charles E. Campbell[J

line 3: "   Date:    Mar 13, 2013[J

line 4: "   Version: 3[J

line 5: "   Purpose: to do Boolean-logic based regular expression pattern matching[J

line 6: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like most anything else that's free,[J

line 10: "               LogiPat.vim is provided *as is* and comes with no warranty[J

line 11: "               of any kind, either expressed or implied. By using this[J

line 12: "               plugin, you agree that in no event will the copyright[J

line 13: "               holder be liable for any damages resulting from the use[J

line 14: "               of this software.[J

line 15: "[J

line 16: "   Usage: {{{1[J

line 17: "       :LogiPat ...[J

line 18: "[J

line 19: "         Boolean logic supported:[J

line 20: "            () grouping operators[J

line 21: "            !  not the following pattern[J

line 22: "            |  logical or[J

line 23: "            &  logical and[J

line 24: "            "..pattern.."[J

line 25: "^IExample: {{{1[J

line 26: "^I^I:LogiPat !("january"|"february")[J

line 27: "^I^I  would match all strings not containing the strings january[J

line 28: "^I^I  or february[J

line 29: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim[J

line 30: "[J

line 31: "  Behold, you will conceive in your womb, and bring forth a son, {{{1[J

line 32: "  and will call his name Jesus. He will be great, and will be[J

line 33: "  called the Son of the Most High. The Lord God will give him the[J

line 34: "  throne of his father, David, and he will reign over the house of[J

line 35: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)[J

line 36: [J

line 37: " ---------------------------------------------------------------------[J

line 38: " Load Once: {{{1[J

line 39: if &cp || exists("loaded_logipat")[J

line 40:  finish[J

line 41: endif[J

line 42: let g:loaded_LogiPat = "v3"[J

line 43: let s:keepcpo        = &cpo[J

line 44: set cpo&vim[J

line 45: "DechoRemOn[J

line 46: [J

line 47: " ---------------------------------------------------------------------[J

line 48: " Public Interface: {{{1[J

line 49: com!        -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)[J

line 50: silent! com -nargs=* LP^I^I^I^Icall   LogiPat(<q-args>,1)[J

line 51: com!        -nargs=+ ELP^I^I^Iechomsg   LogiPat(<q-args>)[J

line 52: com!        -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"[J

line 53: silent! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"[J

line 54: [J

line 55: " =====================================================================[J

line 56: " Functions: {{{1[J

line 57: [J

line 58: " ---------------------------------------------------------------------[J

line 59: " LogiPat: this function interprets the boolean-logic pattern {{{2[J

line 60: fun! LogiPat(pat,...)[J

line 142: [J

line 143: " ---------------------------------------------------------------------[J

line 144: " s:String: Vim6.4 doesn't have string() {{{2[J

line 145: func! s:String(str)[J

line 148: [J

line 149: " ---------------------------------------------------------------------[J

line 150: " LP_PatPush: {{{2[J

line 151: fun! s:LP_PatPush(pat)[J

line 158: [J

line 159: " ---------------------------------------------------------------------[J

line 160: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2[J

line 161: fun! s:LP_PatPop(lookup)[J

line 174: [J

line 175: " ---------------------------------------------------------------------[J

line 176: " LP_OpPush: {{{2[J

line 177: fun! s:LP_OpPush(op)[J

line 228: [J

line 229: " ---------------------------------------------------------------------[J

line 230: " LP_Execute: execute operators from opstack using pattern stack {{{2[J

line 231: fun! s:LP_Execute(preclvl)[J

line 261: [J

line 262: " ---------------------------------------------------------------------[J

line 263: " LP_Not: writes a logical-not for a pattern {{{2[J

line 264: fun! s:LP_Not(pat)[J

line 275: [J

line 276: " ---------------------------------------------------------------------[J

line 277: " LP_Or: writes a logical-or branch using two patterns {{{2[J

line 278: fun! s:LP_Or(pat1,pat2)[J

line 284: [J

line 285: " ---------------------------------------------------------------------[J

line 286: " LP_And: writes a logical-and concat using two patterns {{{2[J

line 287: fun! s:LP_And(pat1,pat2)[J

line 293: [J

line 294: " ---------------------------------------------------------------------[J

line 295: " StackLook: {{{2[J

line 296: fun! s:StackLook(description)[J

line 330: [J

line 331: " ---------------------------------------------------------------------[J

line 332: "  Cleanup And Modeline: {{{1[J

line 333: let &cpo= s:keepcpo[J

line 334: unlet s:keepcpo[J

line 335: " vim: ts=4 fdm=marker[J

finished sourcing /usr/share/vim/vim74/plugin/logiPat.vim[J
chdir(/usr/share/vim/vim74/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim74/plugin/matchparen.vim"[J
line 1: " Vim plugin for showing matching parens[J

line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2014 Jul 19[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded (or disabled)[J

line 7: " - when 'compatible' is set[J

line 8: " - the "CursorMoved" autocmd event is not available.[J

line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")[J

line 10:   finish[J

line 11: endif[J

line 12: let g:loaded_matchparen = 1[J

line 13: [J

line 14: if !exists("g:matchparen_timeout")[J

line 15:   let g:matchparen_timeout = 300[J

line 16: endif[J

line 17: if !exists("g:matchparen_insert_timeout")[J

line 18:   let g:matchparen_insert_timeout = 60[J

line 19: endif[J

line 20: [J

line 21: augroup matchparen[J

line 22:   " Replace all matchparen autocommands[J

line 23:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()[J

line 24:   if exists('##TextChanged')[J

line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()[J

line 26:   endif[J

line 27: augroup END[J

line 28: [J

line 29: " Skip the rest if it was already done.[J

line 30: if exists("*s:Highlight_Matching_Pair")[J

line 31:   finish[J

line 32: endif[J

line 33: [J

line 34: let s:cpo_save = &cpo[J

line 35: set cpo-=C[J

line 36: [J

line 37: " The function that is invoked (very often) to define a ":match" highlighting[J

line 38: " for any matching paren.[J

line 39: function! s:Highlight_Matching_Pair()[J

line 182: [J

line 183: " Define commands that will disable and enable the plugin.[J

line 185: command! NoMatchParen windo silent! call matchdelete(3) | unlet! g:loaded_matchparen | au! matchparen[J

line 186: command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved[J

line 187: [J

line 188: let &cpo = s:cpo_save[J

line 189: unlet s:cpo_save[J

finished sourcing /usr/share/vim/vim74/plugin/matchparen.vim[J
chdir(/usr/share/vim/vim74/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim74/plugin/netrwPlugin.vim"[J
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network[J

line 2: "            PLUGIN SECTION[J

line 3: " Date:^I^INov 07, 2014[J

line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>[J

line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim[J

line 6: " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like anything else that's free,[J

line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided[J

line 11: "               *as is* and comes with no warranty of any kind, either[J

line 12: "               expressed or implied. By using this plugin, you agree that[J

line 13: "               in no event will the copyright holder be liable for any damages[J

line 14: "               resulting from the use of this software.[J

line 15: "[J

line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1[J

line 17: "  (James 1:22 RSV)[J

line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-[J

line 19: " Load Once: {{{1[J

line 20: if &cp || exists("g:loaded_netrwPlugin")[J

line 21:  finish[J

line 22: endif[J

line 23: let g:loaded_netrwPlugin = "v153"[J

line 24: if v:version < 702[J

line 25:  echohl WarningMsg[J

line 26:  echo "***warning*** you need vim version 7.2 for this version of netrw"[J

line 27:  echohl None[J

line 28:  finish[J

line 29: endif[J

line 30: if v:version < 703 || (v:version == 703 && !has("patch465"))[J

line 31:  echohl WarningMsg[J

line 32:  echo "***warning*** this version of netrw needs vim 7.3.465 or later"[J

line 33:  echohl Normal[J

line 34:  finish[J

line 35: endif[J

line 36: let s:keepcpo = &cpo[J

line 37: set cpo&vim[J

line 38: "DechoRemOn[J

line 39: [J

line 40: " ---------------------------------------------------------------------[J

line 41: " Public Interface: {{{1[J

line 42: [J

line 43: " Local Browsing Autocmds: {{{2[J

line 44: augroup FileExplorer[J

line 45:  au![J

line 46:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif[J

line 47:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))[J

line 48:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))[J

line 49:  if has("win32") || has("win95") || has("win64") || has("win16")[J

line 50:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))[J

line 51:  endif[J

line 52: augroup END[J

line 53: [J

line 54: " Network Browsing Reading Writing: {{{2[J

line 55: augroup Network[J

line 56:  au![J

line 57:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlRead(expand("<amatch>"))[J

line 58:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))[J

line 59:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))[J

line 60:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))[J

line 61:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))[J

line 62:  try                                                       [J

line 63:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))[J

line 64:  catch /^Vim\%((\a\+)\)\=:E216/                            [J

line 65:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))[J

line 66:  endtry[J

line 67: augroup END[J

line 68: [J

line 69: " Commands: :Nread, :Nwrite, :NetUserPass {{{2[J

line 70: com! -count=1 -nargs=*^INread^I^Icall netrw#SavePosn()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call netrw#RestorePosn()[J

line 71: com! -range=% -nargs=*^INwrite^I^Icall netrw#SavePosn()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call netrw#RestorePosn()[J

line 72: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)[J

line 73: com! -nargs=*^I        Nsource^I^Icall netrw#SavePosn()<bar>call netrw#NetSource(<f-args>)<bar>call netrw#RestorePosn()[J

line 74: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(<q-args>)[J

line 75: [J

line 76: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2[J

line 77: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)[J

line 78: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)[J

line 79: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)[J

line 80: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)[J

line 81: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)[J

line 82: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)[J

line 83: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)[J

line 84: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)[J

line 85: [J

line 86: " Commands: NetrwSettings {{{2[J

line 87: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()[J

line 88: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)[J

line 89: [J

line 90: " Maps:[J

line 91: if !exists("g:netrw_nogx")[J

line 92:  if maparg('gx','n') == ""[J

line 93:   if !hasmapto('<Plug>NetrwBrowseX')[J

line 94:    nmap <unique> gx <Plug>NetrwBrowseX[J

line 95:   endif[J

line 96:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>[J

line 97:  endif[J

line 98:  if maparg('gx','v') == ""[J

line 99:   if !hasmapto('<Plug>NetrwBrowseXVis')[J

line 100:    vmap <unique> gx <Plug>NetrwBrowseXVis[J

line 101:   endif[J

line 102:   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>[J

line 103:  endif[J

line 104: endif[J

line 105: [J

line 106: " ---------------------------------------------------------------------[J

line 107: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2[J

line 108: fun! s:LocalBrowse(dirname)[J

line 150: [J

line 151: " ---------------------------------------------------------------------[J

line 152: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2[J

line 153: "             Its purpose: to look over all windows and run s:LocalBrowse() on[J

line 154: "             them, which checks if they're directories and will create a directory[J

line 155: "             listing when appropriate.[J

line 156: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()[J

line 157: "             has already been called.[J

line 158: fun! s:VimEnter(dirname)[J

line 166: [J

line 167: " ---------------------------------------------------------------------[J

line 168: " NetrwStatusLine: {{{1[J

line 169: fun! NetrwStatusLine()[J

line 180: [J

line 181: " ------------------------------------------------------------------------[J

line 182: " NetUserPass: set username and password for subsequent ftp transfer {{{1[J

line 183: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password[J

line 184: "^I    :call NetUserPass("uid")^I^I-- will prompt for password[J

line 185: "^I    :call NetUserPass("uid","password") -- sets global userid and password[J

line 186: fun! NetUserPass(...)[J

line 210: [J

line 211: " ------------------------------------------------------------------------[J

line 212: " Modelines And Restoration: {{{1[J

line 213: let &cpo= s:keepcpo[J

line 214: unlet s:keepcpo[J

line 215: " vim:ts=8 fdm=marker[J

finished sourcing /usr/share/vim/vim74/plugin/netrwPlugin.vim[J
chdir(/usr/share/vim/vim74/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim74/plugin/rrhelper.vim"[J
line 1: " Vim plugin with helper function(s) for --remote-wait[J

line 2: " Maintainer: Flemming Madsen <fma@cci.dk>[J

line 3: " Last Change: 2008 May 29[J

line 4: [J

line 5: " Has this already been loaded?[J

line 6: if exists("loaded_rrhelper") || !has("clientserver")[J

line 7:   finish[J

finished sourcing /usr/share/vim/vim74/plugin/rrhelper.vim[J
chdir(/usr/share/vim/vim74/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim74/plugin/spellfile.vim"[J
line 1: " Vim plugin for downloading spell files[J

line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2006 Feb 01[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded[J

line 7: " - when 'compatible' is set[J

line 8: " - some autocommands are already taking care of spell files[J

line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")[J

line 10:   finish[J

line 11: endif[J

line 12: let loaded_spellfile_plugin = 1[J

line 13: [J

line 14: " The function is in the autoload directory.[J

line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))[J

finished sourcing /usr/share/vim/vim74/plugin/spellfile.vim[J
chdir(/usr/share/vim/vim74/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim74/plugin/stdheader.vim"[J
line 1: " **************************************************************************** "[J

line 2: "                                                                              "[J

line 3: "                                                         :::      ::::::::    "[J

line 4: "    stdheader.vim                                      :+:      :+:    :+:    "[J

line 5: "                                                     +:+ +:+         +:+      "[J

line 6: "    By: zaz <zaz@staff.42.fr>                      +#+  +:+       +#+         "[J

line 7: "                                                 +#+#+#+#+#+   +#+            "[J

line 8: "    Created: 2013/06/15 12:45:56 by zaz               #+#    #+#              "[J

line 9: "    Updated: 2013/07/26 16:59:00 by zaz              ###   ########.fr        "[J

line 10: "                                                                              "[J

line 11: " **************************************************************************** "[J

line 12: [J

line 13: [J

line 22: let s:asciiart = ["        :::      ::::::::","      :+:      :+:    :+:","    +:+ +:+         +:+  ","  +#+  +:+       +#+     ","+#+#+#+#+#+   +#+        ","     #+#    #+#          ","    ###   ########.fr    "][J

line 23: [J

line 57: let s:styles = [{'extensions': ['\.c$', '\.h$', '\.cc$', '\.hh$', '\.cpp$', '\.hpp$'],'start': '/*', 'end': '*/', 'fill': '*'},{'extensions': ['\.htm$', '\.html$', '\.xml$'],'start': '<!--', 'end': '-->', 'fill': '*'},{'extensions': ['\.js$'],'start': '//', 'end': '//', 'fill': '*'},{'extensions': ['\.tex$'],'start': '%', 'end': '%', 'fill': '*'},{'extensions': ['\.ml$', '\.mli$', '\.mll$', '\.mly$'],'start': '(*', 'end': '*)', 'fill': '*'},{'extensions': ['\.vim$', 'vimrc$', '\.myvimrc$', 'vimrc$'],'start': '"', 'end': '"', 'fill': '*'},{'extensions': ['\.el$', '\.emacs$', '\.myemacs$'],'start': ';', 'end': ';', 'fill': '*'},{'extensions': ['\.f90$', '\.f95$', '\.f03$', '\.f$', '\.for$'],'start': '!', 'end': '!', 'fill': '/'}][J

line 58: [J

line 59: let s:linelen^I^I= 80[J

line 60: let s:marginlen^I^I= 5[J

line 61: let s:contentlen^I= s:linelen - (3 * s:marginlen - 1) - strlen(s:asciiart[0])[J

line 62: [J

line 63: function s:trimlogin ()[J

line 70: [J

line 71: function s:trimemail ()[J

line 78: [J

line 79: function s:midgap ()[J

line 82: [J

line 83: function s:lmargin ()[J

line 86: [J

line 87: function s:rmargin ()[J

line 90: [J

line 91: function s:empty_content ()[J

line 94: [J

line 95: function s:left ()[J

line 98: [J

line 99: function s:right ()[J

line 102: [J

line 103: function s:bigline ()[J

line 106: [J

line 107: function s:logo1 ()[J

line 110: [J

line 111: function s:fileline ()[J

line 115: [J

line 116: function s:logo2 ()[J

line 119: [J

line 120: function s:coderline ()[J

line 124: [J

line 125: function s:logo3 ()[J

line 128: [J

line 129: function s:dateline (prefix, logo)[J

line 134: [J

line 135: function s:createline ()[J

line 138: [J

line 139: function s:updateline ()[J

line 142: [J

line 143: function s:emptyline ()[J

line 146: [J

line 147: function s:filetype ()[J

line 164: [J

line 165: function s:insert ()[J

line 181: [J

line 182: function s:update ()[J

line 192: [J

line 193: command Stdheader call s:insert ()[J

line 194: nmap <F1> :Stdheader<CR>[J

line 195: autocmd BufWritePre * call s:update ()[J

finished sourcing /usr/share/vim/vim74/plugin/stdheader.vim[J
chdir(/usr/share/vim/vim74/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim74/plugin/tarPlugin.vim"[J
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles[J

line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>[J

line 3: " Modified by Charles E. Campbell[J

line 4: " Distributed under the GNU General Public License.[J

line 5: "[J

line 6: " Updates are available from <http://michael.toren.net/code/>.  If you[J

line 7: " find this script useful, or have suggestions for improvements, please[J

line 8: " let me know.[J

line 9: " Also look there for further comments and documentation.[J

line 10: "[J

line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.[J

line 12: " ---------------------------------------------------------------------[J

line 13: "  Load Once: {{{1[J

line 14: if &cp || exists("g:loaded_tarPlugin")[J

line 15:  finish[J

line 16: endif[J

line 17: let g:loaded_tarPlugin = "v29"[J

line 18: let s:keepcpo          = &cpo[J

line 19: set cpo&vim[J

line 20: [J

line 21: " ---------------------------------------------------------------------[J

line 22: "  Public Interface: {{{1[J

line 23: augroup tar[J

line 24:   au![J

line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)[J

line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)[J

line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))[J

line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))[J

line 29: [J

line 30:   if has("unix")[J

line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)[J

line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)[J

line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))[J

line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))[J

line 35:   endif[J

line 36: [J

line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))[J

line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))[J

line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))[J

line 42:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 43:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))[J

line 44:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))[J

line 45:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 46: augroup END[J

line 47: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)[J

line 48: [J

line 49: " ---------------------------------------------------------------------[J

line 50: " Restoration And Modelines: {{{1[J

line 51: " vim: fdm=marker[J

line 52: let &cpo= s:keepcpo[J

line 53: unlet s:keepcpo[J

finished sourcing /usr/share/vim/vim74/plugin/tarPlugin.vim[J
chdir(/usr/share/vim/vim74/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim74/plugin/tohtml.vim"[J
line 1: " Vim plugin for converting a syntax highlighted file to HTML.[J

line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>[J

line 3: " Last Change: 2015 Sep 08[J

line 4: "[J

line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and[J

line 6: " $VIMRUNTIME/syntax/2html.vim[J

line 7: "[J

line 8: " TODO: {{{[J

line 9: "   * Options for generating the CSS in external style sheets. New :TOcss[J

line 10: "     command to convert the current color scheme into a (mostly) generic CSS[J

line 11: "     stylesheet which can be re-used. Alternate stylesheet support? Good start[J

line 12: "     by Erik Falor[J

line 13: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).[J

line 14: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,[J

line 15: "     term) to use for the styling. Suggestion by "nacitar".[J

line 16: "   * Add way to override or specify which RGB colors map to the color numbers[J

line 17: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".[J

line 18: "   * Disable filetype detection until after all processing is done.[J

line 19: "   * Add option for not generating the hyperlink on stuff that looks like a[J

line 20: "     URL? Or just color the link to fit with the colorscheme (and only special[J

line 21: "     when hovering)?[J

line 22: "   * Bug: Opera does not allow printing more than one page if uncopyable[J

line 23: "     regions is turned on. Possible solution: Add normal text line numbers with[J

line 24: "     display:none, set to display:inline for print style sheets, and hide[J

line 25: "     <input> elements for print, to allow Opera printing multiple pages (and[J

line 26: "     other uncopyable areas?). May need to make the new text invisible to IE[J

line 27: "     with conditional comments to prevent copying it, IE for some reason likes[J

line 28: "     to copy hidden text. Other browsers too?[J

line 29: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is[J

line 30: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome[J

line 31: "     on Windows). Perhaps it is font related?[J

line 32: "   * Bug: still some gaps in the fold column when html_prevent_copy contains[J

line 33: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps[J

line 34: "     on diff lines though.[J

line 35: "   * Undercurl support via CSS3, with fallback to dotted or something:[J

line 36: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion[J

line 37: "   * Redo updates for modified default foldtext (v11) when/if the patch is[J

line 38: "     accepted to modify it.[J

line 39: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold[J

line 40: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress[J

line 41: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml[J

line 42: "     does not show the whole diff filler as it is supposed to?[J

line 43: "   * Bug: when 'isprint' is wrong for the current encoding, will generate[J

line 44: "     invalid content. Can/should anything be done about this? Maybe a separate[J

line 45: "     plugin to correct 'isprint' based on encoding?[J

line 46: "   * Check to see if the windows-125\d encodings actually work in Unix without[J

line 47: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.[J

line 48: "   * Font auto-detection similar to[J

line 49: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of[J

line 50: "     platforms.[J

line 51: "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.[J

line 52: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :[J

line 53: "^I- listchars support[J

line 54: "^I- full-line background highlight[J

line 55: "^I- other?[J

line 56: "   * Make it so deleted lines in a diff don't create side-scrolling (get it[J

line 57: "     free with full-line background highlight above).[J

line 58: "   * Restore open/closed folds and cursor position after processing each file[J

line 59: "     with option not to restore for speed increase.[J

line 60: "   * Add extra meta info (generation time, etc.)?[J

line 61: "   * Tidy up so we can use strict doctype in even more situations[J

line 62: "   * Implementation detail: add threshold for writing the lines to the html[J

line 63: "     buffer before we're done (5000 or so lines should do it)[J

line 64: "   * TODO comments for code cleanup scattered throughout[J

line 65: "}}}[J

line 66: [J

line 67: if exists('g:loaded_2html_plugin')[J

line 68:   finish[J

line 69: endif[J

line 70: let g:loaded_2html_plugin = 'vim7.4_v2'[J

line 71: [J

line 72: "[J

line 73: " Changelog: {{{[J

line 74: "   7.4_v2  (this version): Fix error raised when converting a diff containing[J

line 75: "                           an empty buffer. Jan Stocker: allow g:html_font to[J

line 76: "                           take a list so it is easier to specfiy fallback[J

line 77: "                           fonts in the generated CSS.[J

line 78: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and[J

line 79: "^I^I^I    also for version-specific modelines like "vim>703:".[J

line 80: "[J

line 81: "   7.3 updates: {{{[J

line 82: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using[J

line 83: "^I^I^I    g:html_line_ids=0. Allow customizing[J

line 84: "^I^I^I    important IDs (like line IDs and fold IDs) using[J

line 85: "^I^I^I    g:html_id_expr evalutated when the buffer conversion[J

line 86: "^I^I^I    is started.[J

line 87: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and[J

line 88: "^I^I^I    insert modeline to set it to manual.[J

line 89: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a[J

line 90: "^I^I^I    duplicate of one buffer instead of including both.[J

line 91: "^I^I^I    Add anchors to each line so you can put '#L123'[J

line 92: "^I^I^I    or '#123' at the end of the URL to jump to line 123[J

line 93: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds[J

line 94: "^I^I^I    to show the anchor being jumped to if it is hidden.[J

line 95: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.[J

line 96: "^I^I^I    Allow TOhtml to chain together with other commands[J

line 97: "^I^I^I    using |.[J

line 98: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple[J

line 99: "^I^I^I    highlight groups make up the start-of-modeline text.[J

line 100: "^I^I^I    Improve render time of page with uncopyable regions[J

line 101: "^I^I^I    by not using one-input-per-char. Change name of[J

line 102: "^I^I^I    uncopyable option from html_unselectable to[J

line 103: "^I^I^I    html_prevent_copy. Added html_no_invalid option and[J

line 104: "^I^I^I    default to inserting invalid markup for uncopyable[J

line 105: "^I^I^I    regions to prevent MS Word from pasting undeletable[J

line 106: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).[J

line 107: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to[J

line 108: "^I^I^I    eliminate post-processing substitute commands in[J

line 109: "^I^I^I    favor of doing the work up front. Remove unnecessary[J

line 110: "^I^I^I    special treatment of 'LineNr' highlight group. Minor[J

line 111: "^I^I^I    speed improvements. Fix modeline mangling in[J

line 112: "^I^I^I    generated output so it works for text in the first[J

line 113: "^I^I^I    column. Fix missing line number and fold column in[J

line 114: "^I^I^I    diff filler lines. Fix that some fonts have a 1px[J

line 115: "^I^I^I    gap (using a dirty hack, improvements welcome). Add[J

line 116: "^I^I^I    "colorscheme" meta tag. Does NOT include support for[J

line 117: "^I^I^I    the new default foldtext added in v11, as the patch[J

line 118: "^I^I^I    adding it has not yet been included in Vim.[J

line 119: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian[J

line 120: "^I^I^I    Brabandt in[J

line 121: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.[J

line 122: "^I^I^I    This patch has not yet been included in Vim, thus[J

line 123: "^I^I^I    these changes are removed in the next version.[J

line 124: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside[J

line 125: "^I^I^I    multiple nested folds with dynamic folding on.[J

line 126: "^I^I^I    Also fix problem with foldtext in this situation.[J

line 127: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css[J

line 128: "^I^I^I    and without html_no_pre, default value same as[J

line 129: "^I^I^I    'wrap' option, (Andy Spencer). Don't use[J

line 130: "^I^I^I    'fileencoding' for converted document encoding if[J

line 131: "^I^I^I    'buftype' indicates a special buffer which isn't[J

line 132: "^I^I^I    written.[J

line 133: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab[J

line 134: "^I^I^I    characters in generated output (Andy Spencer).[J

line 135: "^I^I^I    Escape text that looks like a modeline so Vim[J

line 136: "^I^I^I    doesn't use anything in the converted HTML as a[J

line 137: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts[J

line 138: "^I^I^I    before the conversion range. Remove fold column when[J

line 139: "^I^I^I    there are no folds.[J

line 140: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:[J

line 141: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.[J

line 142: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not[J

line 143: "^I^I^I    supported by all major browsers according to[J

line 144: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and[J

line 145: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make[J

line 146: "^I^I^I    HTML encoding to Vim encoding detection be[J

line 147: "^I^I^I    case-insensitive for built-in pairs.[J

line 148: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be[J

line 149: "^I^I^I    called in restricted mode (Andy Spencer). Use[J

line 150: "^I^I^I    'fencoding' instead of 'encoding' to determine by[J

line 151: "^I^I^I    charset, and make sure the 'fenc' of the generated[J

line 152: "^I^I^I    file matches its indicated charset. Add charsets for[J

line 153: "^I^I^I    all of Vim's natively supported encodings.[J

line 154: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other[J

line 155: "^I^I^I    user settings interfering with diff mode generation,[J

line 156: "^I^I^I    trailing whitespace (e.g. line number column) when[J

line 157: "^I^I^I    using html_no_pre, and bugs when using[J

line 158: "^I^I^I    html_hover_unfold.[J

line 159: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync[J

line 160: "^I^I^I    folds in diff mode when first line was folded.[J

line 161: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode[J

line 162: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css[J

line 163: "^I^I^I    default to true when not set to anything. Use strict[J

line 164: "^I^I^I    doctypes where possible. Rename use_xhtml option to[J

line 165: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension[J

line 166: "^I^I^I    when using this option. Add meta tag for settings.[J

line 167: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the[J

line 168: "^I^I^I    diff colors and the normal syntax colors[J

line 169: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output[J

line 170: "}}}[J

line 171: "}}}[J

line 172: [J

line 173: " Define the :TOhtml command when:[J

line 174: " - 'compatible' is not set[J

line 175: " - this plugin was not already loaded[J

line 176: " - user commands are available. {{{[J

line 177: if !&cp && !exists(":TOhtml") && has("user_commands")[J

line 178:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)[J

line 179: endif "}}}[J

line 180: [J

line 181: " Make sure any patches will probably use consistent indent[J

line 182: "   vim: ts=8 sw=2 sts=2 noet fdm=marker[J

finished sourcing /usr/share/vim/vim74/plugin/tohtml.vim[J
chdir(/usr/share/vim/vim74/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim74/plugin/vimballPlugin.vim"[J
line 1: " vimballPlugin : construct a file containing both paths and files[J

line 2: " Author: Charles E. Campbell, Jr.[J

line 3: " Copyright: (c) 2004-2010 by Charles E. Campbell, Jr.[J

line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt[J

line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".[J

line 6: "            No warranty, express or implied.[J

line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***[J

line 8: "[J

line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who[J

line 10: "      judge. For in that which you judge another, you condemn yourself. For[J

line 11: "      you who judge practice the same things.[J

line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim[J

line 13: [J

line 14: " ---------------------------------------------------------------------[J

line 15: "  Load Once: {{{1[J

line 16: if &cp || exists("g:loaded_vimballPlugin")[J

line 17:  finish[J

line 18: endif[J

line 19: let g:loaded_vimballPlugin = "v35"[J

line 20: let s:keepcpo              = &cpo[J

line 21: set cpo&vim[J

line 22: [J

line 23: " ------------------------------------------------------------------------------[J

line 24: " Public Interface: {{{1[J

line 25: com! -ra   -complete=file -na=+ -bang MkVimball^I^I^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)[J

line 26: com! -na=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)[J

line 27: com! -na=0                VimballList^I^I^I^I^I^Icall vimball#Vimball(0)[J

line 28: com! -na=* -complete=dir  RmVimball^I^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()[J

line 29: au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")[J

line 30: au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if expand("%")!=expand("<afile>")|close|endif[J

line 31: au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif[J

line 32: au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")[J

line 33: au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if expand("%")!=expand("<afile>")|close|endif[J

line 34: au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif[J

line 35: [J

line 36: " =====================================================================[J

line 37: " Restoration And Modelines: {{{1[J

line 38: " vim: fdm=marker[J

line 39: let &cpo= s:keepcpo[J

line 40: unlet s:keepcpo[J

finished sourcing /usr/share/vim/vim74/plugin/vimballPlugin.vim[J
chdir(/usr/share/vim/vim74/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim74/plugin/zipPlugin.vim"[J
line 1: " zipPlugin.vim: Handles browsing zipfiles[J

line 2: "            PLUGIN PORTION[J

line 3: " Date:^I^I^IJun 07, 2013[J

line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>[J

line 5: " License:^I^IVim License  (see vim's :help license)[J

line 6: " Copyright:    Copyright (C) 2005-2013 Charles E. Campbell {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like anything else that's free,[J

line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty[J

line 11: "               of any kind, either expressed or implied. By using this[J

line 12: "               plugin, you agree that in no event will the copyright[J

line 13: "               holder be liable for any damages resulting from the use[J

line 14: "               of this software.[J

line 15: "[J

line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.[J

line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.[J

line 18: " ---------------------------------------------------------------------[J

line 19: " Load Once: {{{1[J

line 20: if &cp || exists("g:loaded_zipPlugin")[J

line 21:  finish[J

line 22: endif[J

line 23: let g:loaded_zipPlugin = "v27"[J

line 24: let s:keepcpo          = &cpo[J

line 25: set cpo&vim[J

line 26: [J

line 27: " ---------------------------------------------------------------------[J

line 28: " Options: {{{1[J

line 29: if !exists("g:zipPlugin_ext")[J

line 30:  let g:zipPlugin_ext= '*.zip,*.jar,*.xpi,*.ja,*.war,*.ear,*.celzip,*.oxt,*.kmz,*.wsz,*.xap,*.docx,*.docm,*.dotx,*.dotm,*.potx,*.potm,*.ppsx,*.ppsm,*.pptx,*.pptm,*.ppam,*.sldx,*.thmx,*.xlam,*.xlsx,*.xlsm,*.xlsb,*.xltx,*.xltm,*.xlam,*.crtx,*.vdw,*.glox,*.gcsx,*.gqsx'[J

line 31: endif[J

line 32: [J

line 33: " ---------------------------------------------------------------------[J

line 34: " Public Interface: {{{1[J

line 35: augroup zip[J

line 36:  au![J

line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)[J

line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)[J

line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))[J

line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))[J

line 41: [J

line 42:  if has("unix")[J

line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)[J

line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)[J

line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))[J

line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))[J

line 47:  endif[J

line 48: [J

line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'[J

line 49: au BufReadCmd *.zip,*.jar,*.xpi,*.ja,*.war,*.ear,*.celzip,*.oxt,*.kmz,*.wsz,*.xap,*.docx,*.docm,*.dotx,*.dotm,*.potx,*.potm,*.ppsx,*.ppsm,*.pptx,*.pptm,*.ppam,*.sldx,*.thmx,*.xlam,*.xlsx,*.xlsm,*.xlsb,*.xltx,*.xltm,*.xlam,*.crtx,*.vdw,*.glox,*.gcsx,*.gqsx call zip#Browse(expand("<amatch>"))[J

line 50: augroup END[J

line 51: [J

line 52: " ---------------------------------------------------------------------[J

line 53: "  Restoration And Modelines: {{{1[J

line 54: "  vim: fdm=marker[J

line 55: let &cpo= s:keepcpo[J

line 56: unlet s:keepcpo[J

finished sourcing /usr/share/vim/vim74/plugin/zipPlugin.vim[J
Searching for "/usr/share/vim/vimfiles/after/plugin/**/*.vim"[J
Searching for "/Users/ygarrot/.vim/plugged/vim-snipmate/after/plugin/**/*.vim"[J
chdir(/Users/ygarrot/.vim/plugged/vim-snipmate/after/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/ygarrot/.vim/plugged/vim-snipmate/after/plugin/snipMate.vim"[J
line 1: " snipMate maps[J

line 2: " These maps are created here in order to make sure we can reliably create maps[J

line 3: " after SuperTab.[J

line 4: [J

line 5: let s:save_cpo = &cpo[J

line 6: set cpo&vim[J

line 7: [J

line 8: function! s:map_if_not_mapped(lhs, rhs, mode) abort[J

line 14: [J

line 15: if !exists('g:snips_no_mappings') || !g:snips_no_mappings[J

line 16: ^Iif exists('g:snips_trigger_key')[J

line 17: ^I^Iechom 'g:snips_trigger_key is deprecated. See :h snipMate-mappings'[J

line 18: ^I^Iexec 'imap <unique>' g:snips_trigger_key '<Plug>snipMateTrigger'[J

line 19: ^I^Iexec 'smap <unique>' g:snips_trigger_key '<Plug>snipMateSNext'[J

line 20: ^I^Iexec 'xmap <unique>' g:snips_trigger_key '<Plug>snipMateVisual'[J

line 21: ^Ielse[J

line 22: ^I^I" Remove SuperTab map if it exists[J

line 23: ^I^Ilet s:overwrite = maparg('<Tab>', 'i') ==? '<Plug>SuperTabForward'[J

line 24: ^I^Icall s:map_if_not_mapped('<Tab>', '<Plug>snipMateNextOrTrigger', 'i')[J

calling function <SNR>60_map_if_not_mapped[J('<Tab>', '<Plug>snipMateNextOrTrigger', 'i')

line 1:     let l:unique = s:overwrite ? '' : ' <unique>'[J

line 2:     if !hasmapto(a:rhs, a:mode)[J

line 3: ^Isilent! exe a:mode . 'map' . l:unique a:lhs a:rhs[J

line 4:     endif[J

function <SNR>60_map_if_not_mapped returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vim-snipmate/after/plugin/snipMate.vim[J

line 25: ^I^Icall s:map_if_not_mapped('<Tab>', '<Plug>snipMateNextOrTrigger', 's')[J

calling function <SNR>60_map_if_not_mapped[J('<Tab>', '<Plug>snipMateNextOrTrigger', 's')

line 1:     let l:unique = s:overwrite ? '' : ' <unique>'[J

line 2:     if !hasmapto(a:rhs, a:mode)[J

line 3: ^Isilent! exe a:mode . 'map' . l:unique a:lhs a:rhs[J

line 4:     endif[J

function <SNR>60_map_if_not_mapped returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vim-snipmate/after/plugin/snipMate.vim[J

line 26: ^I^Ilet s:overwrite = 0[J

line 27: ^I^Icall s:map_if_not_mapped('<Tab>', '<Plug>snipMateVisual', 'x')[J

calling function <SNR>60_map_if_not_mapped[J('<Tab>', '<Plug>snipMateVisual', 'x')

line 1:     let l:unique = s:overwrite ? '' : ' <unique>'[J

line 2:     if !hasmapto(a:rhs, a:mode)[J

line 3: ^Isilent! exe a:mode . 'map' . l:unique a:lhs a:rhs[J

line 4:     endif[J

function <SNR>60_map_if_not_mapped returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vim-snipmate/after/plugin/snipMate.vim[J

line 28: ^Iendif[J

line 29: [J

line 30: ^Iif exists('g:snips_trigger_key_backwards')[J

line 31: ^I^Iechom 'g:snips_trigger_key_backwards is deprecated. See :h snipMate-mappings'[J

line 32: ^I^Iexec 'imap <unique>' g:snips_trigger_key_backwards '<Plug>snipMateIBack'[J

line 33: ^I^Iexec 'smap <unique>' g:snips_trigger_key_backwards '<Plug>snipMateSBack'[J

line 34: ^Ielse[J

line 35: ^I^Ilet s:overwrite = maparg('<S-Tab>', 'i') ==? '<Plug>SuperTabBackward'[J

line 36: ^I^Icall s:map_if_not_mapped('<S-Tab>', '<Plug>snipMateBack', 'i')[J

calling function <SNR>60_map_if_not_mapped[J('<S-Tab>', '<Plug>snipMateBack', 'i')

line 1:     let l:unique = s:overwrite ? '' : ' <unique>'[J

line 2:     if !hasmapto(a:rhs, a:mode)[J

line 3: ^Isilent! exe a:mode . 'map' . l:unique a:lhs a:rhs[J

line 4:     endif[J

function <SNR>60_map_if_not_mapped returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vim-snipmate/after/plugin/snipMate.vim[J

line 37: ^I^Icall s:map_if_not_mapped('<S-Tab>', '<Plug>snipMateBack', 's')[J

calling function <SNR>60_map_if_not_mapped[J('<S-Tab>', '<Plug>snipMateBack', 's')

line 1:     let l:unique = s:overwrite ? '' : ' <unique>'[J

line 2:     if !hasmapto(a:rhs, a:mode)[J

line 3: ^Isilent! exe a:mode . 'map' . l:unique a:lhs a:rhs[J

line 4:     endif[J

function <SNR>60_map_if_not_mapped returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vim-snipmate/after/plugin/snipMate.vim[J

line 38: ^I^Ilet s:overwrite = 0[J

line 39: ^Iendif[J

line 40: [J

line 41: ^Icall s:map_if_not_mapped('<C-R><Tab>', '<Plug>snipMateShow', 'i')[J

calling function <SNR>60_map_if_not_mapped[J('<C-R><Tab>', '<Plug>snipMateShow', 'i')

line 1:     let l:unique = s:overwrite ? '' : ' <unique>'[J

line 2:     if !hasmapto(a:rhs, a:mode)[J

line 3: ^Isilent! exe a:mode . 'map' . l:unique a:lhs a:rhs[J

line 4:     endif[J

function <SNR>60_map_if_not_mapped returning #0[J

continuing in /Users/ygarrot/.vim/plugged/vim-snipmate/after/plugin/snipMate.vim[J

line 42: endif[J

line 43: [J

line 44: let &cpo = s:save_cpo[J

line 45: [J

line 46: " vim:noet:[J

finished sourcing /Users/ygarrot/.vim/plugged/vim-snipmate/after/plugin/snipMate.vim[J
Searching for "/Users/ygarrot/.vim/after/plugin/**/*.vim"[J
Searching for "/Users/ygarrot/.opam/default/share/merlin/vim/plugin/**/*.vim"[J
Reading viminfo file "/Users/ygarrot/.viminfo" info oldfiles[J[?1000h
Press ENTER or type command to continue[?1000l[?12l[?25h[?1000h[?1049h[?1h=[1;57r[?12;25h[?12l[?25h[27m[m[38;5;223m[48;5;234m[H[2J[?25l[57;1HExecuting CursorMoved Auto commands for "*"
autocommand call <sid>on_cursor_moved()[?1000l
[38;5;121mPress ENTER or type command to continue[?12l[?25h[?1000h[m[38;5;223m[48;5;234m
[?25lline 0: call <sid>on_cursor_moved()
[1;1H[4L[1;1H[38;5;214m[48;5;237m1   [m[38;5;223m[48;5;234m
[38;5;239m~                                                                                                                  [3;1H~                                                                                                                  [4;1H~                                                                                                                  [5;1H~                                                                                                                  [6;1H~                                                                                                                  [7;1H~                                                                                                                  [8;1H~                                                                                                                  [9;1H~                                                                                                                  [10;1H~                                                                                                                  [11;1H~                                                                                                                  [12;1H~                                                                                                                  [13;1H~                                                                                                                  [14;1H~                                                                                                                  [15;1H~                                                                                                                  [16;1H~                                                                                                                  [17;1H~                                                                                                                  [18;1H~                                                                                                                  [19;1H~                                                                                                                  [20;1H~                                                                                                                  [21;1H~                                                                                                                  [22;1H~                                                                                                                  [23;1H~                                                                                                                  [24;1H~                                                                                                                  [25;1H~                                                                                                                  [26;1H~                                                                                                                  [27;1H~                                                                                                                  [28;1H~                                                                                                                  [29;1H~                                                                                                                  [30;1H~                                                                                                                  [31;1H~                                                                                                                  [32;1H~                                                                                                                  [33;1H~                                                                                                                  [34;1H~                                                                                                                  [35;1H~                                                                                                                  [36;1H~                                                                                                                  [37;1H~                                                                                                                  [38;1H~                                                                                                                  [39;1H~                                                                                                                  [40;1H~                                                                                                                  [41;1H~                                                                                                                  [42;1H~                                                                                                                  [43;1H~                                                                                                                  [44;1H~                                                                                                                  [45;1H~                                                                                                                  [46;1H~                                                                                                                  [47;1H~                                                                                                                  [48;1H~                                                                                                                  [49;1H~                                                                                                                  [50;1H~                                                                                                                  [51;1H~                                                                                                                  [52;1H~                                                                                                                  [53;1H~                                                                                                                  [54;1H~                                                                                                                  [55;1H~                                                                                                                  [m[38;5;223m[48;5;234m[57;1Hcalling function SyntasticStatuslineFlag[57;41H[K[57;41H()
line 1:     return g:SyntasticLoclist.current().getStatuslineFlag()
function SyntasticStatuslineFlag aborted
[56;1H[7m[38;5;239m[48;5;223m                                                                                                                   [m[38;5;223m[48;5;234m[57;1Hcalling function SyntasticStatuslineFlag()
line 1:     return g:SyntasticLoclist.current().getStatuslineFlag()
function SyntasticStatuslineFlag aborted
[56;1H[7m[38;5;239m[48;5;223m                                                                                                                   [1;5H[?12l[?25h[?25l[m[38;5;223m[48;5;234m[57;1HType  :quit<Enter>  to exit Vim[?1000l
Interrupt: [1m[38;5;208mPress ENTER or type command to continue[?12l[?25h[?1000h[m[38;5;223m[48;5;234m[1;1H[7L[?25l[1;1H[38;5;214m[48;5;237m1   [m[38;5;223m[48;5;234m
[38;5;239m~                                                                                                                  [3;1H~                                                                                                                  [4;1H~                                                                                                                  [5;1H~                                                                                                                  [6;1H~                                                                                                                  [7;1H~                                                                                                                  [m[38;5;223m[48;5;234m[57;1H[K[57;1H
calling function SyntasticStatuslineFlag()
line 1:     return g:SyntasticLoclist.current().getStatuslineFlag()
calling function SyntasticStatuslineFlag[1]..39()
line 1:     let buf = a:0 ? a:1 : bufnr('')
line 2:     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
calling function SyntasticStatuslineFlag[1]..39[2]..syntastic#util#getbufvar(1, 'syntastic_loclist', {})
line 1:     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)
function SyntasticStatuslineFlag[1]..39[2]..syntastic#util#getbufvar returning {}
continuing in function SyntasticStatuslineFlag[1]..39
line 3:     if type(loclist) != type({}) || empty(loclist)
line 4:[9Cunlet! loclist
line 5:[9Clet loclist = g:SyntasticLoclist.New([])
calling function SyntasticStatuslineFlag[1]..39[5]..38([])
line 1:     let newObj = copy(self)
line 2:
line 3:     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
line 4:
line 5:     for e in llist
line 6:[9Cif get(e, 'type', '') ==# ''
line 7:[13Clet e['type'] = 'E'
line 8:[9Cendif
line 9:     endfor
line 10:
line 11:     let newObj._rawLoclist = llist
line 12:     let newObj._name = ''
line 13:     let newObj._owner = bufnr('')
line 14:     let newObj._sorted = 0
line 15:     let newObj._columns = g:syntastic_cursor_columns
line 16:
line 17:     return newObj
function SyntasticStatuslineFlag[1]..39[5]..38 returning {'_sorted': 0, 'decorate': function('...ction('51'), 'war
[56;115Hn[57;1Hings': function('59')}
continuing in function SyntasticStatuslineFlag[1]..39
line 6:     endif
line 7:     return loclist
function SyntasticStatuslineFlag[1]..39 returning {'_sorted': 0, 'decorate': function('...ction('51'), 'warnings':
function('59')}
continuing in function SyntasticStatuslineFlag
calling function SyntasticStatuslineFlag[1]..48()
line 1:     if !exists('self._stl_format')
line 2:[9Clet self._stl_format = ''
line 3:     endif
line 4:     if !exists('self._stl_flag')
line 5:[9Clet self._stl_flag = ''
line 6:     endif
line 7:
line 8:     if g:syntastic_stl_format !=# self._stl_format
line 9:[9Clet self._stl_format = g:syntastic_stl_format
line 10:
line 11:[9Cif !empty(self._rawLoclist)
line 12:[13Clet errors = self.errors()
line 13:[13Clet warnings = self.warnings()
line 14:
line 15:[13Clet num_errors = len(errors)
line 16:[13Clet num_warnings = len(warnings)
line 17:[13Clet num_issues = len(self._rawLoclist)
[?1000l[1m[38;5;214m-- More --[?12l[?25h[m[38;5;223m[48;5;234m[57;1H[K[?1000h[57;1H
[?25lfunction SyntasticStatuslineFlag[1]..48 aborted
continuing in function SyntasticStatuslineFlag
function SyntasticStatuslineFlag aborted
[56;1H[7m[38;5;239m[48;5;223m                                                                                                                   [1;5H[?12l[?25h[?25l[m[38;5;223m[48;5;234m[57;1HType  :quit<Enter>  to exit Vim[27m[m[38;5;223m[48;5;234m[H[2J[1;1H[38;5;214m[48;5;237m1   [m[38;5;223m[48;5;234m
[38;5;239m~                                                                                                                  [3;1H~                                                                                                                  [4;1H~                                                                                                                  [5;1H~                                                                                                                  [6;1H~                                                                                                                  [7;1H~                                                                                                                  [8;1H~                                                                                                                  [9;1H~                                                                                                                  [10;1H~                                                                                                                  [11;1H~                                                                                                                  [12;1H~                                                                                                                  [13;1H~                                                                                                                  [14;1H~                                                                                                                  [15;1H~                                                                                                                  [16;1H~                                                                                                                  [17;1H~                                                                                                                  [18;1H~                                                                                                                  [19;1H~                                                                                                                  [20;1H~                                                                                                                  [21;1H~                                                                                                                  [22;1H~                                                                                                                  [23;1H~                                                                                                                  [24;1H~                                                                                                                  [25;1H~                                                                                                                  [26;1H~                                                                                                                  [27;1H~                                                                                                                  [28;1H~                                                                                                                  [29;1H~                                                                                                                  [30;1H~                                                                                                                  [31;1H~                                                                                                                  [32;1H~                                                                                                                  [33;1H~                                                                                                                  [34;1H~                                                                                                                  [35;1H~                                                                                                                  [36;1H~                                                                                                                  [37;1H~                                                                                                                  [38;1H~                                                                                                                  [39;1H~                                                                                                                  [40;1H~                                                                                                                  [41;1H~                                                                                                                  [42;1H~                                                                                                                  [43;1H~                                                                                                                  [44;1H~                                                                                                                  [45;1H~                                                                                                                  [46;1H~                                                                                                                  [47;1H~                                                                                                                  [48;1H~                                                                                                                  [49;1H~                                                                                                                  [50;1H~                                                                                                                  [51;1H~                                                                                                                  [52;1H~                                                                                                                  [53;1H~                                                                                                                  [54;1H~                                                                                                                  [55;1H~                                                                                                                  [m[38;5;223m[48;5;234m[57;1Hcalling function SyntasticStatuslineFlag()
line 1:     return g:SyntasticLoclist.current().getStatuslineFlag()
calling function SyntasticStatuslineFlag[1]..39()
line 1:     let buf = a:0 ? a:1 : bufnr('')
line 2:     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
calling function SyntasticStatuslineFlag[1]..39[2]..syntastic#util#getbufvar(1, 'syntastic_loclist', {})
line 1:     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)
function SyntasticStatuslineFlag[1]..39[2]..syntastic#util#getbufvar returning {}
continuing in function SyntasticStatuslineFlag[1]..39
line 3:     if type(loclist) != type({}) || empty(loclist)
line 4:[9Cunlet! loclist
line 5:[9Clet loclist = g:SyntasticLoclist.New([])
calling function SyntasticStatuslineFlag[1]..39[5]..38([])
line 1:     let newObj = copy(self)
line 2:
line 3:     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
line 4:
line 5:     for e in llist
line 6:[9Cif get(e, 'type', '') ==# ''
line 7:[13Clet e['type'] = 'E'
line 8:[9Cendif
line 9:     endfor
line 10:
line 11:     let newObj._rawLoclist = llist
line 12:     let newObj._name = ''
line 13:     let newObj._owner = bufnr('')
line 14:     let newObj._sorted = 0
line 15:     let newObj._columns = g:syntastic_cursor_columns
line 16:
line 17:     return newObj
function SyntasticStatuslineFlag[1]..39[5]..38 returning {'_sorted': 0, 'decorate': function('...ction('51'), 'war
[56;115Hn[57;1Hings': function('59')}
continuing in function SyntasticStatuslineFlag[1]..39
line 6:     endif
line 7:     return loclist
function SyntasticStatuslineFlag[1]..39 returning {'_sorted': 0, 'decorate': function('...ction('51'), 'warnings':
function('59')}
continuing in function SyntasticStatuslineFlag
calling function SyntasticStatuslineFlag[1]..48()
line 1:     if !exists('self._stl_format')
line 2:[9Clet self._stl_format = ''
line 3:     endif
line 4:     if !exists('self._stl_flag')
line 5:[9Clet self._stl_flag = ''
line 6:     endif
line 7:
line 8:     if g:syntastic_stl_format !=# self._stl_format
line 9:[9Clet self._stl_format = g:syntastic_stl_format
line 10:
line 11:[9Cif !empty(self._rawLoclist)
line 12:[13Clet errors = self.errors()
line 13:[13Clet warnings = self.warnings()
line 14:
line 15:[13Clet num_errors = len(errors)
line 16:[13Clet num_warnings = len(warnings)
line 17:[13Clet num_issues = len(self._rawLoclist)
[?1000l[1m[38;5;214m-- More --[?12l[?25h[m[38;5;223m[48;5;234m[57;1H[K[?1000h[57;1H
[?25lfunction SyntasticStatuslineFlag[1]..48 aborted
continuing in function SyntasticStatuslineFlag
function SyntasticStatuslineFlag aborted
[56;1H[7m[38;5;239m[48;5;223m                                                                                                                   [m[38;5;223m[48;5;234m[57;1Hcalling function SyntasticStatuslineFlag()
line 1:     return g:SyntasticLoclist.current().getStatuslineFlag()
function SyntasticStatuslineFlag aborted
[56;1H[7m[38;5;239m[48;5;223m                                                                                                                   [1;5H[?12l[?25h[?25l[m[38;5;223m[48;5;234m[57;1HType  :quit<Enter>  to exit Vim[27m[m[38;5;223m[48;5;234m[H[2J[1;1H[38;5;214m[48;5;237m1   [m[38;5;223m[48;5;234m
[38;5;239m~                                                                                                                  [3;1H~                                                                                                                  [4;1H~                                                                                                                  [5;1H~                                                                                                                  [6;1H~                                                                                                                  [7;1H~                                                                                                                  [8;1H~                                                                                                                  [9;1H~                                                                                                                  [10;1H~                                                                                                                  [11;1H~                                                                                                                  [12;1H~                                                                                                                  [13;1H~                                                                                                                  [14;1H~                                                                                                                  [15;1H~                                                                                                                  [16;1H~                                                                                                                  [17;1H~                                                                                                                  [18;1H~                                                                                                                  [19;1H~                                                                                                                  [20;1H~                                                                                                                  [21;1H~                                                                                                                  [22;1H~                                                                                                                  [23;1H~                                                                                                                  [24;1H~                                                                                                                  [25;1H~                                                                                                                  [26;1H~                                                                                                                  [27;1H~                                                                                                                  [28;1H~                                                                                                                  [29;1H~                                                                                                                  [30;1H~                                                                                                                  [31;1H~                                                                                                                  [32;1H~                                                                                                                  [33;1H~                                                                                                                  [34;1H~                                                                                                                  [35;1H~                                                                                                                  [36;1H~                                                                                                                  [37;1H~                                                                                                                  [38;1H~                                                                                                                  [39;1H~                                                                                                                  [40;1H~                                                                                                                  [41;1H~                                                                                                                  [42;1H~                                                                                                                  [43;1H~                                                                                                                  [44;1H~                                                                                                                  [45;1H~                                                                                                                  [46;1H~                                                                                                                  [47;1H~                                                                                                                  [48;1H~                                                                                                                  [49;1H~                                                                                                                  [50;1H~                                                                                                                  [51;1H~                                                                                                                  [52;1H~                                                                                                                  [53;1H~                                                                                                                  [54;1H~                                                                                                                  [55;1H~                                                                                                                  [m[38;5;223m[48;5;234m[57;1Hcalling function SyntasticStatuslineFlag()
line 1:     return g:SyntasticLoclist.current().getStatuslineFlag()
calling function SyntasticStatuslineFlag[1]..39()
line 1:     let buf = a:0 ? a:1 : bufnr('')
line 2:     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
calling function SyntasticStatuslineFlag[1]..39[2]..syntastic#util#getbufvar(1, 'syntastic_loclist', {})
line 1:     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)
function SyntasticStatuslineFlag[1]..39[2]..syntastic#util#getbufvar returning {}
continuing in function SyntasticStatuslineFlag[1]..39
line 3:     if type(loclist) != type({}) || empty(loclist)
line 4:[9Cunlet! loclist
line 5:[9Clet loclist = g:SyntasticLoclist.New([])
calling function SyntasticStatuslineFlag[1]..39[5]..38([])
line 1:     let newObj = copy(self)
line 2:
line 3:     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
line 4:
line 5:     for e in llist
line 6:[9Cif get(e, 'type', '') ==# ''
line 7:[13Clet e['type'] = 'E'
line 8:[9Cendif
line 9:     endfor
line 10:
line 11:     let newObj._rawLoclist = llist
line 12:     let newObj._name = ''
line 13:     let newObj._owner = bufnr('')
line 14:     let newObj._sorted = 0
line 15:     let newObj._columns = g:syntastic_cursor_columns
line 16:
line 17:     return newObj
function SyntasticStatuslineFlag[1]..39[5]..38 returning {'_sorted': 0, 'decorate': function('...ction('51'), 'war
[56;115Hn[57;1Hings': function('59')}
continuing in function SyntasticStatuslineFlag[1]..39
line 6:     endif
line 7:     return loclist
function SyntasticStatuslineFlag[1]..39 returning {'_sorted': 0, 'decorate': function('...ction('51'), 'warnings':
function('59')}
continuing in function SyntasticStatuslineFlag
calling function SyntasticStatuslineFlag[1]..48()
line 1:     if !exists('self._stl_format')
line 2:[9Clet self._stl_format = ''
line 3:     endif
line 4:     if !exists('self._stl_flag')
line 5:[9Clet self._stl_flag = ''
line 6:     endif
line 7:
line 8:     if g:syntastic_stl_format !=# self._stl_format
line 9:[9Clet self._stl_format = g:syntastic_stl_format
line 10:
line 11:[9Cif !empty(self._rawLoclist)
line 12:[13Clet errors = self.errors()
line 13:[13Clet warnings = self.warnings()
line 14:
line 15:[13Clet num_errors = len(errors)
line 16:[13Clet num_warnings = len(warnings)
line 17:[13Clet num_issues = len(self._rawLoclist)
[?1000l[1m[38;5;214m-- More --[?12l[?25h[m[38;5;223m[48;5;234m[57;1H[K[?1000h[57;1H
[?25lfunction SyntasticStatuslineFlag[1]..48 aborted
continuing in function SyntasticStatuslineFlag
function SyntasticStatuslineFlag aborted
[56;1H[7m[38;5;239m[48;5;223m                                                                                                                   [m[38;5;223m[48;5;234m[57;1Hcalling function SyntasticStatuslineFlag()
line 1:     return g:SyntasticLoclist.current().getStatuslineFlag()
function SyntasticStatuslineFlag aborted
[56;1H[7m[38;5;239m[48;5;223m                                                                                                                   [1;5H[?12l[?25h[?25l[m[38;5;223m[48;5;234m[57;1HType  :quit<Enter>  to exit Vim[27m[m[38;5;223m[48;5;234m[H[2J[1;1H[38;5;214m[48;5;237m1   [m[38;5;223m[48;5;234m
[38;5;239m~                                                                                                                  [3;1H~                                                                                                                  [4;1H~                                                                                                                  [5;1H~                                                                                                                  [6;1H~                                                                                                                  [7;1H~                                                                                                                  [8;1H~                                                                                                                  [9;1H~                                                                                                                  [10;1H~                                                                                                                  [11;1H~                                                                                                                  [12;1H~                                                                                                                  [13;1H~                                                                                                                  [14;1H~                                                                                                                  [15;1H~                                                                                                                  [16;1H~                                                                                                                  [17;1H~                                                                                                                  [18;1H~                                                                                                                  [19;1H~                                                                                                                  [20;1H~                                                                                                                  [21;1H~                                                                                                                  [22;1H~                                                                                                                  [23;1H~                                                                                                                  [24;1H~                                                                                                                  [25;1H~                                                                                                                  [26;1H~                                                                                                                  [27;1H~                                                                                                                  [28;1H~                                                                                                                  [29;1H~                                                                                                                  [30;1H~                                                                                                                  [31;1H~                                                                                                                  [32;1H~                                                                                                                  [33;1H~                                                                                                                  [34;1H~                                                                                                                  [35;1H~                                                                                                                  [36;1H~                                                                                                                  [37;1H~                                                                                                                  [38;1H~                                                                                                                  [39;1H~                                                                                                                  [40;1H~                                                                                                                  [41;1H~                                                                                                                  [42;1H~                                                                                                                  [43;1H~                                                                                                                  [44;1H~                                                                                                                  [45;1H~                                                                                                                  [46;1H~                                                                                                                  [47;1H~                                                                                                                  [48;1H~                                                                                                                  [49;1H~                                                                                                                  [50;1H~                                                                                                                  [51;1H~                                                                                                                  [52;1H~                                                                                                                  [53;1H~                                                                                                                  [54;1H~                                                                                                                  [55;1H~                                                                                                                  [m[38;5;223m[48;5;234m[57;1Hcalling function SyntasticStatuslineFlag()
line 1:     return g:SyntasticLoclist.current().getStatuslineFlag()
calling function SyntasticStatuslineFlag[1]..39()
line 1:     let buf = a:0 ? a:1 : bufnr('')
line 2:     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
calling function SyntasticStatuslineFlag[1]..39[2]..syntastic#util#getbufvar(1, 'syntastic_loclist', {})
line 1:     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)
function SyntasticStatuslineFlag[1]..39[2]..syntastic#util#getbufvar returning {}
continuing in function SyntasticStatuslineFlag[1]..39
line 3:     if type(loclist) != type({}) || empty(loclist)
line 4:[9Cunlet! loclist
line 5:[9Clet loclist = g:SyntasticLoclist.New([])
calling function SyntasticStatuslineFlag[1]..39[5]..38([])
line 1:     let newObj = copy(self)
line 2:
line 3:     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
line 4:
line 5:     for e in llist
line 6:[9Cif get(e, 'type', '') ==# ''
line 7:[13Clet e['type'] = 'E'
line 8:[9Cendif
line 9:     endfor
line 10:
line 11:     let newObj._rawLoclist = llist
line 12:     let newObj._name = ''
line 13:     let newObj._owner = bufnr('')
line 14:     let newObj._sorted = 0
line 15:     let newObj._columns = g:syntastic_cursor_columns
line 16:
line 17:     return newObj
function SyntasticStatuslineFlag[1]..39[5]..38 returning {'_sorted': 0, 'decorate': function('...ction('51'), 'war
[56;115Hn[57;1Hings': function('59')}
continuing in function SyntasticStatuslineFlag[1]..39
line 6:     endif
line 7:     return loclist
function SyntasticStatuslineFlag[1]..39 returning {'_sorted': 0, 'decorate': function('...ction('51'), 'warnings':
function('59')}
continuing in function SyntasticStatuslineFlag
calling function SyntasticStatuslineFlag[1]..48()
line 1:     if !exists('self._stl_format')
line 2:[9Clet self._stl_format = ''
line 3:     endif
line 4:     if !exists('self._stl_flag')
line 5:[9Clet self._stl_flag = ''
line 6:     endif
line 7:
line 8:     if g:syntastic_stl_format !=# self._stl_format
line 9:[9Clet self._stl_format = g:syntastic_stl_format
line 10:
line 11:[9Cif !empty(self._rawLoclist)
line 12:[13Clet errors = self.errors()
line 13:[13Clet warnings = self.warnings()
line 14:
line 15:[13Clet num_errors = len(errors)
line 16:[13Clet num_warnings = len(warnings)
line 17:[13Clet num_issues = len(self._rawLoclist)
[?1000l[1m[38;5;214m-- More --[?12l[?25h[m[38;5;223m[48;5;234m[57;1H[K[?1000h[57;1H
[?25lfunction SyntasticStatuslineFlag[1]..48 aborted
continuing in function SyntasticStatuslineFlag
function SyntasticStatuslineFlag aborted
[56;1H[7m[38;5;239m[48;5;223m                                                                                                                   [m[38;5;223m[48;5;234m[57;1Hcalling function SyntasticStatuslineFlag()
line 1:     return g:SyntasticLoclist.current().getStatuslineFlag()
function SyntasticStatuslineFlag aborted
[56;1H[7m[38;5;239m[48;5;223m                                                                                                                   [1;5H[?12l[?25h[?25l[m[38;5;223m[48;5;234m[57;1HType  :quit<Enter>  to exit Vim[27m[m[38;5;223m[48;5;234m[H[2J[1;1H[38;5;214m[48;5;237m1   [m[38;5;223m[48;5;234m
[38;5;239m~                                                                                                                  [3;1H~                                                                                                                  [4;1H~                                                                                                                  [5;1H~                                                                                                                  [6;1H~                                                                                                                  [7;1H~                                                                                                                  [8;1H~                                                                                                                  [9;1H~                                                                                                                  [10;1H~                                                                                                                  [11;1H~                                                                                                                  [12;1H~                                                                                                                  [13;1H~                                                                                                                  [14;1H~                                                                                                                  [15;1H~                                                                                                                  [16;1H~                                                                                                                  [17;1H~                                                                                                                  [18;1H~                                                                                                                  [19;1H~                                                                                                                  [20;1H~                                                                                                                  [21;1H~                                                                                                                  [22;1H~                                                                                                                  [23;1H~                                                                                                                  [24;1H~                                                                                                                  [25;1H~                                                                                                                  [26;1H~                                                                                                                  [27;1H~                                                                                                                  [28;1H~                                                                                                                  [29;1H~                                                                                                                  [30;1H~                                                                                                                  [31;1H~                                                                                                                  [32;1H~                                                                                                                  [33;1H~                                                                                                                  [34;1H~                                                                                                                  [35;1H~                                                                                                                  [36;1H~                                                                                                                  [37;1H~                                                                                                                  [38;1H~                                                                                                                  [39;1H~                                                                                                                  [40;1H~                                                                                                                  [41;1H~                                                                                                                  [42;1H~                                                                                                                  [43;1H~                                                                                                                  [44;1H~                                                                                                                  [45;1H~                                                                                                                  [46;1H~                                                                                                                  [47;1H~                                                                                                                  [48;1H~                                                                                                                  [49;1H~                                                                                                                  [50;1H~                                                                                                                  [51;1H~                                                                                                                  [52;1H~                                                                                                                  [53;1H~                                                                                                                  [54;1H~                                                                                                                  [55;1H~                                                                                                                  [m[38;5;223m[48;5;234m[57;1Hcalling function SyntasticStatuslineFlag()
line 1:     return g:SyntasticLoclist.current().getStatuslineFlag()
calling function SyntasticStatuslineFlag[1]..39()
line 1:     let buf = a:0 ? a:1 : bufnr('')
line 2:     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
calling function SyntasticStatuslineFlag[1]..39[2]..syntastic#util#getbufvar(1, 'syntastic_loclist', {})
line 1:     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)
function SyntasticStatuslineFlag[1]..39[2]..syntastic#util#getbufvar returning {}
continuing in function SyntasticStatuslineFlag[1]..39
line 3:     if type(loclist) != type({}) || empty(loclist)
line 4:[9Cunlet! loclist
line 5:[9Clet loclist = g:SyntasticLoclist.New([])
calling function SyntasticStatuslineFlag[1]..39[5]..38([])
line 1:     let newObj = copy(self)
line 2:
line 3:     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
line 4:
line 5:     for e in llist
line 6:[9Cif get(e, 'type', '') ==# ''
line 7:[13Clet e['type'] = 'E'
line 8:[9Cendif
line 9:     endfor
line 10:
line 11:     let newObj._rawLoclist = llist
line 12:     let newObj._name = ''
line 13:     let newObj._owner = bufnr('')
line 14:     let newObj._sorted = 0
line 15:     let newObj._columns = g:syntastic_cursor_columns
line 16:
line 17:     return newObj
function SyntasticStatuslineFlag[1]..39[5]..38 returning {'_sorted': 0, 'decorate': function('...ction('51'), 'war
[56;115Hn[57;1Hings': function('59')}
continuing in function SyntasticStatuslineFlag[1]..39
line 6:     endif
line 7:     return loclist
function SyntasticStatuslineFlag[1]..39 returning {'_sorted': 0, 'decorate': function('...ction('51'), 'warnings':
function('59')}
continuing in function SyntasticStatuslineFlag
calling function SyntasticStatuslineFlag[1]..48()
line 1:     if !exists('self._stl_format')
line 2:[9Clet self._stl_format = ''
line 3:     endif
line 4:     if !exists('self._stl_flag')
line 5:[9Clet self._stl_flag = ''
line 6:     endif
line 7:
line 8:     if g:syntastic_stl_format !=# self._stl_format
line 9:[9Clet self._stl_format = g:syntastic_stl_format
line 10:
line 11:[9Cif !empty(self._rawLoclist)
line 12:[13Clet errors = self.errors()
line 13:[13Clet warnings = self.warnings()
line 14:
line 15:[13Clet num_errors = len(errors)
line 16:[13Clet num_warnings = len(warnings)
line 17:[13Clet num_issues = len(self._rawLoclist)
[?1000l[1m[38;5;214m-- More --[?12l[?25h